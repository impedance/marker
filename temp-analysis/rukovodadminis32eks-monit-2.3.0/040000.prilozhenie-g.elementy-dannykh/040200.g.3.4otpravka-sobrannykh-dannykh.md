# Г.3.4Отправка собранных данных

Параметр "тип памяти" поддерживается на платформах Linux, AIX, FreeBSD и Solaris.

Три общих значения параметра "тип памяти" поддерживаются на всех этих платформах: pmem, rss и vsize. Кроме того, для некоторых платформ поддерживаются специфичные для этих платформ значения "типа памяти".

Для AIX значения, поддерживаемые для параметра "тип памяти", приведены в таблице 43.

1. Значения для AIX

| Поддерживаемое значение | Описание | Источник в структуре procentry64 | Пытается быть совместимым с |
| --- | --- | --- | --- |
| v`size` | `Р`азмер виртуальной памяти | `pi_size` |  |
| p`mem` | `П`роцент физической памяти | `pi_prm` | `ps -o pmem` |
| r`ss` | `Р`азмер резидентного набора | `pi_trss + pi_drss` | `ps -o rssize` |
| s`ize` | `Р`азмер процесса (код + данные) | `pi_dvm` | `"ps gvw"` колонка `SIZE` |
| d`size` | `Р`азмер данных | `pi_dsize` |
| t`size` | `Р`азмер текста (кода) | `pi_tsize` | `"ps gvw"` колонка `TSIZ` |
| s`dsize` | `Р`азмер данных из разделяемой библиотеки | `pi_sdsize` |
| d`rss` | `Р`азмер резидентного набора данных | `pi_drss` |  |
| t`rss` | `Р`азмер резидентного набора текста | `pi_trss` |  |

Примечания:

- При выборе параметров для ключа элемента данных `proc.mem[] `на AIX следует указать узкие критерии выбора процесса. Иначе есть риск того, что в результат proc.mem[] окажутся сосчитаны нежелательные процессы.

Пример:

```bash Terminal
$ zabbix_agentd -t proc.mem[,,,НесуществующийПроцесс,rss]
proc.mem[,,,НесуществующийПроцесс,rss] [u|2879488]
```

Данный пример иллюстрирует, как указание только параметра командной строки (в виде регулярного выражения) приводит к тому, что Агент считает и себя тоже.

- Не следует использовать "ps -ef" для просмотра процессов, показывающий только процессы, не относящиеся к ядру. Используют `"ps -Af",` чтобы увидеть все процессы, которые будет видеть Агент.
- proc.mem[] Агента выбирает процессы на примере использования topasrec:

```bash Terminal
$ ps -Af | grep topasrec
root 1074798410Mar 16-0:00 /usr/bin/topasrec-L -s 300 -R 1 -r 6 -o /var/perf daily/ -ypersistent=1 -O type=bin -yStart_time=04:08:54,Mar16,2023
```

proc.mem[] имеет аргументы:

```bash Terminal
proc.mem[<имя>,<пользователь>,<режим>,<cmdline>,<тип памяти>]
```

Первый критерий – имя процесса (аргумент <имя>). В этом примере Агент увидит его как topasrec. Для соответствия нужно либо указать topasrec, либо оставить его пустым. Второй критерий – имя пользователя (аргумент <пользователь>). Для соответствия нужно либо указать root, либо оставить его пустым. Третий критерий, используемый при выборе процесса, – это аргумент <cmdline>. Агент увидит его значение как "/usr/bin/topasrec -L -s 300 -R 1 -r 6 -o /var/perf/daily/ -ypersistent=1 -O type=bin -yStart_time=04:08:54,Mar16,2023". Для сопоставления нужно либо указать регулярное выражение, соответствующее этой строке, либо оставить его пустым.

Аргументы <режим> и <тип памяти> применяются после использования трех критериев, упомянутых выше.

Для FreeBSD значения, поддерживаемые для параметра "тип памяти", приведены в таблице 44.

1. Значения для FreeBSD

| Поддерживаемое значение | Описание | Источник в структуре kinfo_proc | Пытается быть совместимым с |
| --- | --- | --- | --- |
| v`size` | `Р`азмер виртуальной памяти | `kp_eproc.e_vm.vm_map.size и`ли` ki_size` | `ps -o vsz` |
| p`mem` | `П`роцент физической памяти | вычисляется из` rss` | `ps -o pmem` |
| r`ss` | `Р`азмер резидентного набора | `kp_eproc.e_vm.vm_rssize и`ли` ki_rssize` | `ps -o rss` |
| s`ize` | `Р`азмер процесса (код + данные + стек) | `tsize + dsize + ssize` |  |
| t`size` | `Р`азмер текста (кода) | `kp_eproc.e_vm.vm_tsize и`ли` ki_tsize` | `ps -o tsiz` |
| d`size` | `Р`азмер данных | `kp_eproc.e_vm.vm_dsize и`ли` ki_dsize` | `ps -o dsiz` |
| s`size` | `Р`азмер стека | `kp_eproc.e_vm.vm_ssize и`ли` ki_ssize` | `ps -o ssiz` |

Для Linux значения, поддерживаемые для параметра "тип памяти", приведены в таблице 45.

1. Значения для FreeBSD

| Поддерживаемое значение | Описание | Источник в файле `/proc/<pid>/status` |
| --- | --- | --- |
| v`size` | `Р`азмер виртуальной памяти | `VmSize` |
| p`mem` | `П`роцент физической памяти | `(VmRSS/total_memory) * 100` |
| r`ss` | `Р`азмер резидентного набора | `VmRSS` |
| d`ata` | `Р`азмер сегмента данных | `VmData` |
| e`xe` | `Р`азмер сегмента кода | `VmExe` |
| h`wm` | `П`иковый размер резидентного набора | `VmHWM` |
| l`ck` | `Р`азмер заблокированной памяти | `VmLck` |
| l`ib` | `Р`азмер разделяемых библиотек | `VmLib` |
| p`eak` | `П`иковый размер виртуальной памяти | `VmPeak` |
| p`in` | `Р`азмер закрепленных страниц | `VmPin` |
| p`te` | `Р`азмер записей таблицы страниц | `VmPTE` |
| s`ize` | `Р`азмер сегментов кода + данных + стека процесса | `VmExe + VmData + VmStk` |
| s`tk` | `Р`азмер сегмента стека | `VmStk` |
| s`wap` | `Р`азмер используемого места в разделе подкачки | `VmSwap` |

Примечания для Linux:

- Не все значения параметра "тип памяти" поддерживаются старыми версиями ядер Linux. Например, ядра Linux 2.4 не поддерживают значения `hwm,` `pin,` `peak,` `pte и` `swap.`
- Процесс самодиагностики активных проверок Агента с `proc.mem[...,...,...,...,data] о`тображает значение, которое на 4 КБ больше, чем отдает строка `VmData `в файле Агента /proc/<pid>/status. Во время измерения себя сегмент данных Агента увеличивается на 4 КБ и затем возвращается к предыдущему размеру.

Для Solaris значения, поддерживаемые для параметра "тип памяти", приведены в таблице 46.

1. Значения для Solaris

| Поддерживаемое значение | Описание | Источник в структуре psinfo | Пытается быть совместимым с |
| --- | --- | --- | --- |
| v`size `(по умолчанию) | Размер образа процесса | `pr_size` | `ps -o vsz` |
| p`mem` | `П`роцент физической памяти | `pr_pctmem` | `ps -o pmem` |
| r`ss` | `Р`азмер резидентного набораОн может быть недооценен – см. описание `rss `в `man ps.` | `pr_rssize` | `ps -o rss` |

# Г.4 Минимальный уровень прав для элементов данных Агента Windows

# Г.5 Кодировка получаемых значений

Некоторые программы используют изменение своей командной строки как метод отображения своей текущей активности. Пользователь может увидеть эту активность, запуская команды ps и top. Примеры таких программ: PostgreSQL, Sendmail, Zabbix.

Пример из Linux. Наблюдение количество процессов Агента.

Команда ps отобразит интересующие процессы следующим образом:

```bash Terminal
$ ps -fu Zabbix
UID PID PPID C STIME TTY TIME CMD
...
zabbix 6318 1 0 12:01 ? 00:00:00 sbin/zabbix_agentd -c /home/zabbix/ZBXNEXT-1078/zabbix_agentd.conf
zabbix 6319 6318 0 12:01 ? 00:00:01 sbin/zabbix_agentd: collector [idle 1 sec]
zabbix 6320 6318 0 12:01 ? 00:00:00 sbin/zabbix_agentd: LISTENer #1 [waiting for connection]
zabbix 6321 6318 0 12:01 ? 00:00:00 sbin/zabbix_agentd: LISTENer #2 [waiting for connection]
zabbix 6322 6318 0 12:01 ? 00:00:00 sbin/zabbix_agentd: LISTENer #3 [waiting for connection]
zabbix 6323 6318 0 12:01 ? 00:00:00 sbin/zabbix_agentd: active checks #1 [idle 1 sec] ...
```

Выбор процессов по имени и пользователю выполняет задачу:

```bash Terminal
$ zabbix_get -s localhost -k "proc.num[zabbix_agentd,zabbix]"6
```

После переименования исполняемого файла zabbix_agentd в zabbix_agentd_30 команда перезапускается.

Здесь ps отображает:

```bash Terminal
$ ps -fu Zabbix
UID PID PPID C STIME TTY TIME CMD
...
zabbix 6715 1 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30 -c /home/zabbix/ZBXNEXT-1078/zabbix_agentd.conf
zabbix 6716 6715 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30: collector [idle 1 sec]
zabbix 6717 6715 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30: LISTENer #1 [waiting for connection]
zabbix 6718 6715 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30: LISTENer #2 [waiting for connection]
zabbix 6719 6715 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30: LISTENer #3 [waiting for connection]
zabbix 6720 6715 0 12:53 ? 00:00:00 sbin/zabbix_agentd_30: active checks #1 [idle 1 sec] ...
```

Здесь выбор процессов по имени и пользователю выдает неверный результат:

```bash Terminal
$ zabbix_get -s localhost -k "proc.num[zabbix_agentd_30,zabbix]"1
```

В данном случае простое переименование исполняемого файла на более длинное имя приводит к совершенно другому результату.

Агент начинает с проверки имени процесса. Открывается файл /proc/<pid>/status и проверяется строка Name. В этом случае строки Name это:

```bash Terminal
$ grep Name /proc/{6715,6716,6717,6718,6719,6720}/status
/proc/6715/status:Name: zabbix_agentd_3
/proc/6716/status:Name: zabbix_agentd_3
/proc/6717/status:Name: zabbix_agentd_3
/proc/6718/status:Name: zabbix_agentd_3
/proc/6719/status:Name: zabbix_agentd_3
/proc/6720/status:Name: zabbix_agentd_3
```

Имя процесса в файле status обрезается до 15 символов.

Аналогичный результат можно увидеть при помощи команды ps:

```bash Terminal
$ ps -u zabbix PID TTY TIME CMD
...
6715 ? 00:00:00 zabbix_agentd_3
6716 ? 00:00:01 zabbix_agentd_3
6717 ? 00:00:00 zabbix_agentd_3
6718 ? 00:00:00 zabbix_agentd_3
6719 ? 00:00:00 zabbix_agentd_3
6720 ? 00:00:00 zabbix_agentd_3
...
```

Очевидно, что этот вывод не идентичен значению zabbix_agentd_30 в параметре name ключа proc.num[]. Не найдя совпадение по имени процесса в файле status, Агент обращается к файлу /proc/<pid>/cmdline.

То, как Агент просматривает файл cmdline, может быть проиллюстрировано при помощи выполнения команды:

```bash Terminal
$ for i in 6715 6716 6717 6718 6719 6720; do cat /proc/$i/cmdline | awk "{gsub(/\x0/,"<NUL>"); print};"; done
sbin/zabbix_agentd_30<NUL>-c<NUL>/home/zabbix/ZBXNEXT-1078/zabbix_agentd.conf<NUL>
sbin/zabbix_agentd_30: collector [idle 1 sec]<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>...
sbin/zabbix_agentd_30: LISTENer #1 [waiting for connection]<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>...
sbin/zabbix_agentd_30: LISTENer #2 [waiting for connection]<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>...
sbin/zabbix_agentd_30: LISTENer #3 [waiting for connection]<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>...
sbin/zabbix_agentd_30: active checks #1 [idle 1 sec]<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>...
```

В рассматриваемом случае файлы /proc/<pid>/cmdline содержат невидимые непечатаемые нулевые байты, которые используются для завершения строки в языке C. В этом примере нулевые байты отображаются как <NUL>.

Агент проверяет cmdline основного процесса и извлекает zabbix_agentd_30, которое соответствует значению zabbix_agentd_30 параметра name. Таким образом, основной процесс учитывается элементом данных proc.num[zabbix_agentd_30,zabbix].

При проверке следующего процесса Агент из файла cmdline получает zabbix_agentd_30: collector [idle 1 sec], и это не соответствует значению zabbix_agentd_30 в параметре name. Таким образом, будет сосчитан только основной процесс, который не меняет свою командную строку. Остальные процессы Агента модифицируют свои командные строки и игнорируются.

Этот пример показывает, что в данном случае параметр name нельзя использовать в proc.mem[] и proc.num[] для выбора процессов.

Использование параметра cmdline с надлежащим регулярным выражением даст правильный результат:

```bash Terminal
$ zabbix_get -s localhost -k "proc.num[,zabbix,,zabbix_agentd_30[ :]]"6
```

Следует с осторожностью использовать элементы данных proc.mem[] и proc.num[] при наблюдении за программами, которые модифицируют свои командные строки.

Перед тем как поместить параметры name и cmdline в элементы данных proc.mem[] и proc.num[], возможно, потребуется протестировать эти параметры, используя элемент данных proc.num[] и команду ps.

# Г.6 Поддержка больших файлов

Нельзя выбрать потоки при помощи параметров cmdline в элементах данных proc.mem[] и proc.num[].

Например, один из потоков ядра:

```bash Terminal
$ ps -ef| grep kthreadd
root 2 0 0 09:33 ? 00:00:00 [kthreadd]
```

Его можно выбрать при помощи параметра имя:

```bash Terminal
$ zabbix_get -s localhost -k "proc.num[kthreadd,root]"
1
```

Но выбор при помощи параметра cmdline не работает:

```bash Terminal
$ zabbix_get -s localhost -k "proc.num[,root,,kthreadd]"
0
```

Причина такого поведения кроется в том, что Агент берет регулярное выражение, которое указано в параметре cmdline, и применяет его к содержимому относящегося к процессу файла /proc/<pid>/cmdline. В случае потоков ядра их файлы /proc/<pid>/cmdline – пустые. Поэтому параметр cmdline никогда не совпадет.

Потоки ядра Linux подсчитываются элементом данных proc.num[], но не сообщают информацию о памяти в элементе данных proc.mem[] item, например:

```bash Terminal
$ ps -ef | grep kthreadd
root 2 0 0 09:51 ? 00:00:00 [kthreadd]
$ zabbix_get -s localhost -k "proc.num[kthreadd]"
1
$ zabbix_get -s localhost -k "proc.mem[kthreadd]"
ZBX_NOTSUPPORTED: Cannot get amount of "VmSize" memory.
```

Если имеется пользовательский процесс с таким же именем, как и у потока ядра, то:

```bash Terminal
$ ps -ef | grep kthreadd
root 2 0 0 09:51 ? 00:00:00 [kthreadd]
zabbix 9611 6133 0 17:58 pts/1 00:00:00 ./kthreadd
$ zabbix_get -s localhost -k "proc.num[kthreadd]"
2
$ zabbix_get -s localhost -k "proc.mem[kthreadd]"
4157440
```

proc.num[] подсчитал как поток ядра, так и пользовательский процесс.

proc.mem[] сообщил информацию о памяти только по пользовательскому процессу и вычислил память потока ядра, как будто оно было нулевым. Это отличается от случая выше, когда сообщалось ZBX_NOTSUPPORTED.

Следует внимательно использовать элементы данных proc.mem[] и proc.num[] при совпадении имени процесса с одним из потоков.

Перед добавлением параметров в элементы данных proc.mem[] и proc.num[], возможно, потребуется протестировать эти параметры, используя элемент данных proc.num[] и команду ps.

# Г.7 Датчики

В этом разделе подробно описана реализация проверок net.tcp.service и net.udp.service для различных сервисов, которые можно указать в параметре service.

- Параметры элемента данных `net.tcp.service:`
  - `ftp –` создает TCP-соединение и ожидает, что первые 4 символа ответа будут `"220 ",` после чего посылает `"QUIT\r\n".` По умолчанию используется порт 21, если он не указан;
  - `http `– создает TCP-соединение без ожидания и отсылки чего-либо. По умолчанию используется порт 80, если он не указан;
  - `https –` использует (и работает только с) libcurl, не проверяет подлинность сертификата, не проверяет имя хоста в SSL-сертификате, только извлекает заголовок ответа (запрос HEAD). По умолчанию используется порт 443, если он не указан;
  - `imap `– создает TCP-соединение и ожидает, что первые 4 символа ответа будут `"* OK",` после чего посылает `"a1 LOGOUT\r\n".` По умолчанию используется порт 143, если он не указан;
  - `ldap `– открывает соединение на сервер LDAP и выполняет операцию поиска (LDAP search) с фильтром, выставленным в (`objectClass=*)`. Ожидает успешного извлечения первого параметра у первого элемента. По умолчанию используется порт 389, если он не указан;
  - `nntp `– создает TCP-соединение и ожидает, что первые 3 символа ответа будут "`200"` или "`201"`, после чего посылает "`QUIT\r\n"`. По умолчанию используется порт 119, если он не указан;
  - `pop `– создает TCP-соединение и ожидает, что первые 3 символа ответа будут "`+OK"`, после чего посылает "`QUIT\r\n"`. По умолчанию используется порт 110, если он не указан;
  - `smtp `– создает TCP-соединение и ожидает, что первые 3 символа ответа будут "`220"`, после которых идет пробел, конец строки или минус. Строки, содержащие минус, относятся к многострочному ответу, и ответ будет заново читаться до тех пор, пока не будет получена строка без минуса. После этого отсылается "`QUIT\r\n"`. По умолчанию используется порт 25, если он не указан;
  - `ssh `– создает TCP-соединение. Если соединение было установлено, обе стороны обмениваются строками идентификации (`SSH-major.minor-XXXX)`, где `major `и `minor `являются версиями протокола, а `XXXX `– строкой. Подсистема проверяет, найдена ли соответствующая спецификации строка, и затем отсылает назад строку "SSH-major.minor-zabbix_agent\r\n" или "0\n" при несовпадении. По умолчанию используется порт 22, если он не указан;
  - `tcp `– создает TCP-соединение без ожидания и отсылки чего-либо. В отличие от остальных проверок, требует указания параметра "`порт"`;
  - `telnet `– создает TCP-соединение и ожидает приглашение на ввод имени пользователя (`":" `в конце строки). По умолчанию используется порт 23, если он не указан.

Параметры элемента данных net.udp.service:

- `ntp `– отсылает по UDP пакет SNTP и проверяет ответ в соответствии с RFC 4330. По умолчанию используется порт 123, если он не указан.

# Г.8 Параметр "тип памяти" в элементах данных proc.mem

Несколько параметров конфигурации определяют, каким должно быть поведение Сервера, если агентские проверки (Подсистемы, SNMP, IPMI, JMX) завершаются с ошибками и узел сети становится недостижимым.

1. Недостижимый интерфейс

Интерфейс узла сети считается недостижимым после ошибки при проверке (сетевая ошибка, превышение времени ожидания) посредством Подсистемы, SNMP, IPMI или JMX Агентов. Следует учесть, что активные проверки Агента никак не влияют на доступность интерфейса.

С этого момента UnreachableDelay определяет, как часто в этой ситуации недостижимости интерфейс будет проверяться повторно, используя один из элементов данных (включая правила LLD), причем такие повторные проверки выполняются уже с помощью unreachable-поллеров (или IPMI-поллеров для IPMI-проверок). По умолчанию – 15 секунд до следующей проверки.

В журнале Сервера недостижимость обозначается записями такого рода:

```bash Terminal
Zabbix agent item "system.cpu.load[percpu,avg1]" on host "New host" failed: first network error, wait for 15 seconds
Zabbix agent item "system.cpu.load[percpu,avg15]" on host "New host" failed: another network error, wait for 15 seconds
```

Следует обратить внимание, что здесь указывается, какой именно элемент данных выполнился с ошибкой, а также тип этого элемента данных (Агент).

Параметр Timeout также будет влиять на то, как быстро интерфейс будет проверен повторно в течение периода недостижимости. Если время ожидания составляет 20 секунд и UnreachableDelay составляет 30 секунд, то следующая проверка будет через 50 секунд после первой попытки.

Параметр UnreachablePeriod определяет общую длительность периода недостижимости. По умолчанию UnreachablePeriod равен 45 секундам. UnreachablePeriod должен быть в несколько раз больше, чем UnreachableDelay, чтобы интерфейс проверялся повторно более одного раза, прежде чем он станет недоступным.

По окончании периода недостижимости интерфейс опрашивается заново со снижением приоритета элемента данных, который перевел интерфейс в недостижимое состояние. Если устанавливается связь с интерфейсом, который был недостижимым, мониторинг автоматически возвращается к норме:

```bash Terminal
resuming Zabbix agent checks on host "New host": connection restored
```

После того как интерфейс становится доступным, опрос всех элементов данных немедленно не осуществляется узлом сети по двум причинам:

- это может создать слишком большую нагрузку на узел сети;
- время восстановления интерфейса не всегда совпадает с плановым опросом элемента данных согласно заданному расписанию проверок.

Поэтому, когда интерфейс становится доступным, опрос элементов данных производится не сразу, а перепланируется в соответствии с расписанием их следующих проверок.

1. Недоступный интерфейс

После того как UnreachablePeriod завершился, а интерфейс так и не стал доступным, он считается недоступным.

В журнале Сервера это обозначается записями такого рода:

```bash Terminal
temporarily disabling Zabbix agent checks on host "New host": interface unavailable
```

При этом в веб-интерфейсе иконка доступности узла сети меняет свой цвет с зеленого/серого на желтый/красный (при наведении указателя "мыши" на иконку доступности узла сети можно видеть информацию о недостижимости интерфейса) (рисунок 1).

::sign-image
---
src: /image2.png
sign: Рисунок 16 – Доступность узла сети
---
::

1. Доступность узла сети

Параметр UnavailableDelay определяет, как часто интерфейс проверяется повторно в течение его недоступности.

По умолчанию – раз в 60 секунд (таким образом, в этом случае "temporarily disabling" из файла журнала будет означать деактивацию проверок сроком на одну минуту).

Когда соединение c интерфейсом будет восстановлено, мониторинг тоже автоматически вернется к норме:

```bash Terminal
enabling Zabbix agent checks on host "New host": interface became available
```

# Г.9 Выбор процессов в элементах данных proc.mem и proc.num

Некоторые внутренние метрики Сервера и Прокси можно сделать доступными удаленно для другого экземпляра Подсистемы или сторонних утилит. Может быть полезно, чтобы поставщики поддержки/сервисов имели возможность удаленно мониторить Сервер/Прокси своих клиентов, или в организациях, где Подсистема не является основным инструментом мониторинга, чтобы внутренние метрики Подсистемы могли контролироваться сторонней системой при использовании зонтичного мониторинга.

Внутренняя статистика Подсистемы открыта для настраиваемого списка адресов, перечисленных в новом параметре StatsAllowedIP Сервера/Прокси. Запросы будут приниматься только с этих адресов.

Для настройки запроса внутренней статистики с другого экземпляра Подсистемы можно использовать два элемента данных:

- Внутренний элемент данных `zabbix[stats,<ip>,<порт>] `– для прямых удаленных запросов к Серверу/Прокси. <ip> и <порт> используются для идентификации необходимого целевого экземпляра.
- Элемент данных Агента `zabbix.stats[<ip>,<порт>] `для удаленных запросов к Серверу/Прокси через Агента. <ip> и <порт> используются для идентификации необходимого целевого экземпляра.

Рисунок 2 иллюстрирует использование обоих элементов данных в зависимости от контекста.

::sign-image
---
src: /image3.png
sign: Рисунок 3 – Использование элементов данных
---
::

1. Использование элементов данных
  - – Сервер → внешний экземпляр (`zabbix[stats,<ip>,<порт>])`;
    ::sign-image
    ---
    src: /image4.png
    sign: Image image4
    ---
    ::
  - – Сервер → Прокси → внешний экземпляр (`zabbix[stats,<ip>,<порт>])`;
    ::sign-image
    ---
    src: /image5.png
    sign: Image image5
    ---
    ::
  - – Сервер → Агент → внешний экземпляр (`zabbix.stats[<ip>,<порт>])`;
    ::sign-image
    ---
    src: /image6.png
    sign: Image image6
    ---
    ::
  - – Сервер → Прокси → Агент → внешний экземпляр (`zabbix.stats[<ip>,<порт>])`.
    ::sign-image
    ---
    src: /image7.png
    sign: Image image7
    ---
    ::

Чтобы убедиться, что целевой экземпляр разрешает запросы к себе со стороны внешнего экземпляра, указывают адрес внешнего экземпляра в параметре StatsAllowedIP на целевом экземпляре.

Используя предоставляемые метрики, элементы данных собирают статистику одним запросом и возвращают JSON, который является основой зависимых элементов данных и из которого они получают данные. Любым из двух элементов данных возвращаются следующие внутренние метрики:

- `zabbix[boottime];`
- `zabbix[hosts];`
- `zabbix[items];`
- `zabbix[items_unsupported];`
- `zabbix[preprocessing_queue] (`только Сервер);
- `zabbix[process,<тип>,<режим>,<состояние>] (с`татистика только на основе типов процессов);
- `zabbix[rcache,<кэш>,<режим>];`
- `zabbix[requiredperformance];`
- `zabbix[triggers] (`только Сервер);
- `zabbix[uptime];`
- `zabbix[vcache,buffer,<режим>] (`только Сервер);
- `zabbix[vcache,cache,<параметр>];`
- `zabbix[version];`
- `zabbix[vmware,buffer,<режим>];`
- `zabbix[wcache,<кэш>,<режим>] (`тип кэша `trends;` только Сервер).

Доступные шаблоны для удаленного мониторинга внутренних метрик Сервера или Прокси с внешнего экземпляра:

- Remote Zabbix server;
- Remote Zabbix proxy.

Следует обратить внимание, что при использовании шаблонов удаленного мониторинга нескольких внешних экземпляров для мониторинга каждого внешнего экземпляра потребуется отдельный узел сети.

Получение запросов внутренних метрик с внешнего экземпляра Подсистемы обрабатывается процессом траппер, который проверяет запрос, собирает метрики, создает буфер данных JSON и отправляет назад подготовленный JSON, например, с Сервера:

```bash Terminal
{
"response": success,
"data":
{
"boottime": N,
"uptime": N,
"hosts": N,
"items": N,
"items_unsupported": N,
"preprocessing_queue": N,
"process": {
"alert manager": {
"busy": {
"avg": N,
"max": N,
"min": N
},
"idle": {
"avg": N,
"max": N,
"min": N
},
"count": N
},
...
},
"queue": N,
"rcache": {
"total": N,
"free": N,
"pfree": N,
"used": N,
"pused": N
},
"requiredperformance": N,
"triggers": N,
"uptime": N,
"vcache": {
"buffer": {
"total": N,
"free": N,
"pfree": N,
"used": N,
"pused": N
},
"cache": {
"requests": N,
"hits": N,
"misses": N,
"mode": N
}
},
"vmware": {
"total": N,
"free": N,
"pfree": N,
"used": N,
"pused": N
},
"version": "N",
"wcache": {
"values": {
"all": N,
"float": N,
"uint": N,
"str": N,
log: N,
"text": N,
"not supported": N
},
"history": {
"pfree": N,
"free": N,
"total": N,
"used": N,
"pused": N
},
"index": {
"pfree": N,
"free": N,
"total": N,
"used": N,
"pused": N
},
"trend": {
"pfree": N,
"free": N,
"total": N,
"used": N,
"pused": N
}
}
}
}
```

Также имеются два других элемента данных, которые позволяют получить внутреннюю статистику очереди удаленным запросом с другого экземпляра Подсистемы:

- Внутренний элемент данных `zabbix[stats,<ip>,<порт>,queue,<от>,<до>] –` для прямых запросов внутренней очереди с удаленного Сервера/Прокси;
- Элемент данных Агента `zabbix.stats[<ip>,<порт>,queue,<от>,<до>] –` для запросов внутренней очереди удаленного Сервера/Прокси через Агента.

## Г.9.1 Процессы, изменяющие свою командную строку

Аутентификацию Kerberos можно использовать в веб-мониторинге и HTTP-элементах данных в Подсистеме.

В этом разделе описывается пример настройки Kerberos с Сервером для выполнения веб-мониторинга страницы www.example.com под пользователем zabbix по шагам:

1. установить пакет Kerberos:
  - для Debian/Ubuntu:
  - для RHEL:
2. настроить файл конфигурации Kerberos:

```bash Terminal
apt install krb5-user
```

```bash Terminal
dnf install krb5-workstation
```

```bash Terminal
``` {.java} cat /etc/krb5.conf
[libdefaults] default_realm = EXAMPLE.COM
```

Следующие переменные krb5.conf предназначены только для MIT Kerberos:

```bash Terminal
kdc_timesync = 1
ccache_type = 4
forwardable = true
proxiable = true
[realms]
EXAMPLE.COM = {
}
[domain_realm]
.example.com=EXAMPLE.COM
example.com=EXAMPLE.COM
```
```

1. создать билет Kerberos для пользователя `zabbix,` выполнив следующую команду под пользователем `zabbix:`

```bash Terminal
kinit zabbix
```

Важно выполнить команду выше именно под пользователем zabbix. Если выполнить ее под root, аутентификация не будет работать.

1. создать веб-сценарий или элемент данных типа "`HTTP Агент"` с типом аутентификации Kerberos.

Опционально можно протестировать при помощи следующей команды:

```bash Terminal
curl -v --negotiate -u : http://example.com
```

Следует обратить внимание, что для длительного веб-мониторинга потребуется позаботиться о продлении срока действия билета Kerberos. По умолчанию время истечения срока действия билета – 10 часов.

## Г.9.2 Потоки ядра Linux

В таблице 47 представлены детальные описания параметров элемента данных modbus.get[].

1. Параметры `modbus.get`

| Параметр | Описание | По умолчанию |
| --- | --- | --- |
| т`очка входа` | Протокол и адрес точки входа, определяемый в виде `протокол://строка_подключения`Возможные значения протокола: `rtu,` `ascii `(только Агент-2), `tcp`Формат строки подключения:– для `tcp `– `адрес:порт`– для последовательной линии: `rtu,` `ascii `– `имя_порта:скорость:параметры`где:– `скорость `– 1200, 9600 и т.д.;– `параметры `– количество бит (5,6,7 или 8), четность (n,e или o для нет(none)/чет(even)/нечет(odd)), стоп-битов (1 или 2). | `протокол: `нет`протокол: `rtu/ascii:`имя_порта: `нет`скорость: `115200`параметры: `8n1`протокол: `tcp:`адрес: `нет`порт: `502 |
| i`d ведомого` | Адрес modbus устройства, для которого он предназначен (от 1 до 247), устройство tcp (не GW) будет игнорировать это поле | для последовательной линии: 1для tcp: 255 (0xFF) |
| ф`ункция` | Пусто или значение поддерживаемой функции:1 – Чтение Флага,2 – Чтение Дискретного Входа,3 – Чтение Регистров Временного Хранения,4 – Чтение Входных Регистров | пусто |
| а`дрес` | Адрес первого регистра, флага или входа.Если параметр "функция" пустой, то "адрес" должен быть в диапазоне для:Флага – 00001 – 09999Дискретного входа – 10001 – 19999Входного регистра – 30001 – 39999Регистра Временного Хранения – 40001 – 49999Если параметр "функция" не пуст, то поле "адрес" будет от 0 до 65535 использоваться без модификации (PDU) | пустая функция: 00001непустая функция: 0 |
| к`оличество` | Количество последовательных "типов", которые будут считаны с устройства, где:для флага или дискретного входа "тип" = 1 битв остальных случаях: (количество*тип)/2 = реальное количество регистров для чтенияЕсли "сдвиг" не равен 0, то значение будет добавлено к "реальному количеству"Допустимый диапазон для "реального количества" составляет 1:65535 | 1 |
| т`ип` | Тип данных:– для Чтения Флага и Чтения Дискретного Входа – `bit`– для Чтения Регистров Временного Хранения и Чтения Входных Регистров:`int8 `– 8 бит`uint8 `– 8 бит (без знака)`int16 `– 16 бит`uint16 `– 16 бит (без знака)`int32 `– 32 бита`uint32 `– 32 бита (без знака)`float `– 32 бита`uint64 `– 64 бита (без знака)`double `– 64 бита | bituint16 |
| п`орядок следования байтов` | Тип порядка следования байтов:`be `– Big Endian`le `– Little Endian`mbe `– Mid-Big Endian`mle `– Mid-Little EndianОграничения:для 1 бит – `be`для 8 бит – `be,leд`ля 16 бит – `be,le` | be |
| с`двиг` | Количество регистров, начиная с "адреса", результаты которых будут отброшены.Размер каждого регистра составляет 16 бит (требуется для поддержки оборудования, не поддерживающего произвольный доступ для чтения). | 0 |

Приложение Д. Типы элементов данных

# Г.10 Реализация проверок net.tcp.service и net.udp.service

Эти проверки используют общение с Агентом для сбора данных.

Существуют пассивные и активные проверки (п.Г.3). При настройке элемента данных, можно выбрать требуемый тип:

- `Агент `– для пассивных проверок;
- `Агент (активный) `– для активных проверок.

В таблице 48-58 приводится подробная информация о поддерживаемых ключах элементов данных, которые можно использовать с элементами данных Агента, сгруппированная по семействам элементов данных.

Параметры без угловых скобок обязательны. Параметры, обозначенные угловыми скобками "<>", опциональны.

Следует обратить внимание, что при тестировании или использовании ключей элементов данных в zabbix_agentd или zabbix_get с командной строкой также нужно учитывать синтаксис командной оболочки.

Например, если какой-то параметр ключа должен быть заключен в двойные кавычки, придется явно экранировать эти двойные кавычки, иначе они будут обрезаны командной оболочкой как специальные символы и не будут переданы утилите:

```bash Terminal
zabbix_agentd -t "vfs.dir.count[/var/log,,,"file,dir",,0]"
zabbix_agentd -t vfs.dir.count[/var/log,,,\"file,dir\",,0]
```

1. Ключи элемента данных

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| a`gent.HostMetadata` |
| Метаданные узла сети Агента. | Строка |  | Получение значения параметров `HostMetadata `или `HostMetadataItem,` или пустая строка, если ничего не задано. |
| a`gent.Hostname` |
| Имя хоста Агента. | Строка |  | Возвращает:– пассивной проверкой – имя первого узла сети, указанное в параметре `Hostname `в файле конфигурации Агента;– активной проверкой – текущее значение имени хоста. |
| a`gent.ping` |
| Проверка доступности Агента. | Ничего – недоступен1 – доступен |  | Использовать триггерную функцию `nodata() `для проверки недоступности узла сети. |
| a`gent.variant` |
| Проверка разновидности Агента (Агент-1 или Агент-2) | Целое число |  | Примеры возвращаемых значений:1 – Агент-1;2 – Агент-2. |
| a`gent.version` |
| Версия Агента. | Строка |  | Пример возвращаемого значения:1.0.0 |
| z`abbix.stats[<ip>,<порт>]` |
| Возвращает набор внутренних метрик с удаленного Сервера или Прокси. | JSON объект | ip – список IP/DNS/сетевой маски опрашиваемых удаленно Серверов / Прокси (по умолчанию 127.0.0.1)порт – порт опрашиваемого удаленно Сервера / Прокси (по умолчанию 10051) | Обратить внимание, что запрос статистики будет приниматься только с адресов, которые перечислены в параметре `StatsAllowedIP `Сервера/Прокси на удаленном экземпляре.Этим элементом данных возвращается выбранный список внутренних метрик. |
| z`abbix.stats[<ip>,<порт>,queue,<от>,<до>]` |
| Возвращает количество наблюдаемых элементов данных в очереди, которые задерживаются на удаленном Сервере или Прокси. | JSON объект | `– ip `– список IP/DNS/сетевой маски опрашиваемых удаленно Серверов / Прокси (по умолчанию 127.0.0.1);– `порт `– порт опрашиваемого удаленно Сервера / Прокси (по умолчанию 10051);– `queue `– константа (используется как есть);– `от `– с задержкой как минимум (по умолчанию от 6 секунд);– `до `– с задержкой как максимум (по умолчанию до бесконечности) | Обратить внимание, что запрос статистики будет приниматься только с адресов, которые перечислены в параметре `StatsAllowedIP `Сервера/Прокси на удаленном экземпляре. |

Примечания:

- (Специфичное для Linux) Агент должен иметь права "только на чтение" на файловую систему `/proc.` Патчи к ядру от www.grsecurity.org ограничивают права доступа непривилегированных пользователей.
- `vfs.dev.read[],` `vfs.dev.write[]:` Агент будет прерывать потерянные подключения к устройствам, если значения элементов данных не опрашиваются более 3 часов. Это может произойти, если система имеет устройства с динамически меняющимися путями или если устройство было удалено вручную. Следует обратить также внимание, что эти элементы данных при использовании интервала обновления от 3 часов и более всегда будут возвращать значение "0".
- `vfs.dev.read[],` `vfs.dev.write[]:` если первым параметром используется параметр по умолчанию `all,` то ключ вернет суммарную статистику, включая все блочные устройства, такие как sda, sdb и их разделы (sda1, sda2, sdb3…) и несколько устройств (MD raid) на основе этих блочных устройств/разделов и логические разделы (LVM) на основе этих блочных устройств/разделов. В этих случаях возвращаемые значения следует рассматривать как относительные значения (изменяемые во времени), но не как абсолютные значения.
- SSL (HTTPS) поддерживается, только если Агент скомпилирован с поддержкой cURL. Иначе элемент данных станет неподдерживаемым.

Чтобы убедиться, что полученные данные не повреждены, можно указать корректную кодировку для обработки проверки (например, в "vfs.file.contents") в параметре кодировка. Список поддерживаемых кодировок (идентификаторов кодовых страниц) можно найти в документации к libiconv (GNU Project) или в документации к Microsoft Windows SDK по "Идентификаторам кодовых страниц"​. ​

Если кодировка не задана в параметре ​кодировка, то применяются следующие стратегии преобразования:

- если кодировка не задана (или указана пустая строка), то предполагается наличие UTF-8-кодировки и данные обрабатываются "как есть";
- анализ BOM – применяется к элементам данных "vfs.file.contents", "vfs.file.regexp", "vfs.file.regmatch". Предпринимается попытка определить корректную кодировку при помощи использования маркера последовательности байтов (BOM) в начале файла. Если BOM отсутствует, применяется стандартное преобразование.

Для поиска проблем с элементами данных Агента при использовании с пассивным Агентом, возможно, значение конфигурации Сервера Timeout потребуется выставить выше, чем Timeout в файле конфигурации Агента. Иначе элемент данных может не получить никакого значения по причине того, что время ожидания запроса на стороне Сервера истечет раньше, чем на стороне Агента.

1. Ключи элемента данных ядра

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| k`ernel.maxfiles` |
| Максимальное количество открытых файлов, поддерживаемое ОС. | Целое число |  |  |
| k`ernel.maxproc` |
| Максимальное количество процессов, поддерживаемое ОС. | Целое число |  |  |
| k`ernel.openfiles` |
| Получение количества открытых в данное время файловых дескрипторов. | Целое число |  |  |

1. Ключи элемента данных журналов

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| **l**`og[файл,<регулярное выражение>,<кодировка>,<макс. кол-во строк>,<режим>,<вывод>,<максзадержка>,<опции>,<постоянное_хранилище>]` |
| Мониторинг файлов журналов (логов). | Журнал (лог) | `–файл – а`бсолютный путь и имя файла журнала;`–регулярное выражение – р`егулярное выражение, описывающее необходимый шаблон содержимого;`–кодировка – и`дентификатор кодовой страницы`–макс. кол-во строк – м`аксимальное количество новых строк в секунду, которое Агент будет отправлять Серверу или Прокси. Этот параметр переопределяет значение "`MaxLinesPerSecond"` в `zabbix_agentd.conf;–режим – в`озможные значения:` all `(по умолчанию), `skip `– пропуск обработки старых данных (влияет только на недавно созданные элементы данных, которые еще не получали никаких данных);`– вывод – `опциональный шаблон форматирования вывода. `\0 – у`правляющая последовательность заменяется найденной частью текста (начиная от первого символа совпадения, заканчивая символом, где совпадение заканчивается), при этом `\N (где N=1...9) – у`правляющая последовательность заменяется N-ой совпадающей группой (или пустой строкой, если N превышает количество найденных групп);`– максзадержка – м`аксимальная задержка в секундах. Тип: число с плавающей точкой. Значения: 0 – (по умолчанию) никогда не игнорировать строки в файлах журналов; > 0.0 – игнорировать более старые строки с целью получения наиболее новых строк, проанализированных в течение "`максзадержка"` секунд;`– опции` `– д`ополнительные опции;`– постоянное_хранилище` (только в zabbix_agentd на UNIX-системах; не поддерживается в Агент-2) – абсолютный путь к директории, где хранить данные долговременного хранения. | Элемент данных должен быть настроен как активная проверка.Если файл не существует или доступ к нему не разрешен, элемент данных перейдет в неподдерживаемое состояние. Если параметр вывод оставить пустым – будет возвращена вся строка, содержащая текст, соответствующий регулярному выражению. Обратить внимание, что все глобальные регулярные выражения, исключая "`Результат ИСТИНА"`, всегда возвращают всю строку, соответствующую выражению, и параметр `вывод и`гнорируется.Извлечение содержимого согласно параметру `вывод п`роизводится на стороне Агента. |
| l`og.count[файл,<регулярное выражение>,<кодировка>,<макс. кол-во строк>,<режим>,<максзадержка>,<опции>,<постоянное_хранилище>]` |
| Подсчет количества совпадающих строк в наблюдаемом файле журнала (логе). | Целое число | `–файл `– абсолютный путь и имя файла журнала;`–регулярное выражение `– регулярное выражение, описывающее необходимый шаблон содержимого;`–кодировка `– идентификатор кодовой страницы;`–макс. кол-во строк `– максимальное количество новых строк в секунду, которое Агент будет анализировать (не может превышать 10000). Значением по умолчанию является 10*"`MaxLinesPerSecond"` в `zabbix_agentd.conf.–режим `– возможные значения:`all `(по умолчанию), `skip `– пропуск обработки старых данных (влияет только на недавно созданные элементы данных);`–максзадержка `– максимальная задержка в секундах. Тип: число с плавающей точкой. Значения: 0 – (по умолчанию) никогда не игнорировать строки в файлах журналов; > 0.0 – игнорировать более старые строки с целью получения наиболее новых строк, проанализированных в течение "`максзадержка"` секунд; `–опции `– дополнительные опции;`–постоянное_хранилище` `(`только в zabbix_agentd на UNIX системах; не поддерживается в Агент-2) – абсолютный путь к директории, где хранить данные долговременного хранения. См. также дополнительные заметки о файлах долговременного хранения. | Элемент данных должен быть настроен как активная проверка.Количество совпадающих строк вычисляется за счет новых строк, начиная со времени последней проверки журнала Агентом; таким образом, количество зависит от интервала обновления элемента данных.Если файл не существует или доступ к нему не разрешен, элемент данных переходит в неподдерживаемое состояние.Этот элемент данных не поддерживается для Журнала событий Windows. |
| l`ogrt[регулярное_выражение_файла,<регулярное выражение>,<кодировка>,<макс. кол-во строк>,<режим>,<вывод>,<максзадержка>,<опции>,<постоянное_хранилище>]` |
| Мониторинг файлов журналов (логов) с поддержкой ротации файлов журналов. | Журнал (лог) | `–регулярное_выражение_файла – а`бсолютный путь к файлу и регулярное выражение, описывающее его имя. Обратить внимание, регулярным выражением является только имя файла;`регулярное выражение – р`егулярное выражение, описывающее необходимый шаблон содержимого;`кодировка – и`дентификатор кодовой страницы;`макс. кол-во строк – м`аксимальное количество новых строк в секунду, которое Агент будет отправлять Серверу или Прокси. Этот параметр переопределяет значение "`MaxLinesPerSecond"` в `zabbix_agentd.conf;–режим – в`озможные значения:`all `(по умолчанию), `skip `– пропуск обработки старых данных (влияет только на недавно созданные элементы данных, которые еще не получали никаких данных);`–вывод – о`пциональный шаблон форматирования вывода. `\0 –` управляющая последовательность заменяется найденной частью текста (начиная от первого символа совпадения, заканчивая символом, где совпадение заканчивается), то `\N (где N=1...9)` – управляющая последовательность заменяется N-ой совпадающей группой (или пустой строкой, если N превышает количество найденных групп);`максзадержка `– максимальная задержка в секундах. Тип: число с плавающей точкой. Значения: 0 – (по умолчанию) никогда не игнорировать строки в файлах журналов; > 0.0 – игнорировать более старые строки с целью получения наиболее новых строк, проанализированных в течение "`максзадержка"` секунд. `–опции – `тип ротации файлов журналов и другие опции. Возможные значения:`rotate `(по умолчанию),`copytruncate `– следует обратить внимание, что `copytruncate `нельзя использовать вместе с `maxdelay.` В этом случае `maxdelay `должен быть равен 0 или не указан; `mtime-reread `– не уникальные записи, перечитывать, если время модификации или размер изменились (по умолчанию),`mtime-noreread `– не уникальные записи, перечитывать, только если размер файла изменяется (игнорирование изменения времени модификации);`–постоянное_хранилище ( т`олько в` z`abbix_agentd на UNIX системах; не поддерживается в Agent2) – абсолютный путь к директории, где хранить данные долговременного хранения. | Элемент данных должен быть настроен как активная проверка.Ротация журналов основывается на времени последней модификации файлов.Обратить внимание, что `logrt `разработан для работы с одним активным файлом журнала, с несколькими другими совпадающими уже устаревшими неактивными файлами. Если, например, директория содержит множество активных файлов журналов, по каждому такому файлу необходимо создавать отдельный `logrt `элемент данных. Иначе, если один `logrt `элемент данных подхватит слишком много файлов, это может привести к исчерпанию памяти и сбою в мониторинге.Если параметр вывод оставить пустым – будет возвращена вся строка, содержащая соответствующий регулярному выражению текст. Обратить внимание, что все глобальные регулярные выражения, исключая "`Результат ИСТИНА"`, всегда возвращают всю соответствующую выражению строку, и параметр вывод игнорируется.Извлечение содержимого согласно параметру вывод производится на стороне Агента. |
| l`ogrt.count[регулярное_выражение_файла ,<регулярное выражение>,<кодировка>,<макс. кол-во строк>,<режим>,<максзадержка>,<опции>,<постоянное_хранилище>]` |
| Подсчет количества совпадающих строк в наблюдаемом файле журнала (логе) с поддержкой ротации файлов журналов. | Целое число | `–регулярное_выражение_файла – а`бсолютный путь к файлу и регулярное выражение, описывающее его имя. Обратить внимание, регулярным выражением является только имя файла;`–регулярное выражение `– регулярное выражение, описывающее необходимый шаблон содержимого;`–кодировка `– идентификатор кодовой страницы;`–макс. кол-во строк `– максимальное количество новых строк в секунду, которое Агент будет анализировать (не может превышать 10000). Значением по умолчанию является 10*"`MaxLinesPerSecond"` в `zabbix_agentd.conf;–режим `– возможные значения:`all `(по умолчанию), `skip `– пропуск обработки старых данных (влияет только на недавно созданные элементы данных);`–максзадержка `– максимальная задержка в секундах. Тип: число с плавающей точкой. Значения: 0 – (по умолчанию) никогда не игнорировать строки в файлах журналов; > 0.0 – игнорировать более старые строки с целью получения наиболее новых строк, проанализированных в течение "`максзадержка"` секунд;`–опции `– тип ротации файлов журналов и другие опции. Возможные значения:`rotate `(по умолчанию),`copytruncate `– следует обратить внимание, что `copytruncate н`ельзя использовать вместе с `maxdelay.` В этом случае `maxdelay д`олжен быть равен 0 или не указан; `mtime-reread `– не уникальные записи, перечитывать, если время модификации или размер изменились (по умолчанию),`mtime-noreread `– не уникальные записи, перечитывать, только если размер файла изменяется (игнорирование изменения времени модификации);`–постоянное_хранилище (`только в zabbix_agentd на UNIX системах; не поддерживается в Агент-2) – абсолютный путь к директории, где хранить данные долговременного хранения. См. также дополнительные заметки о файлах долговременного хранения. | Элемент данных должен быть настроен как активная проверка.Количество совпадающих строк вычисляется за счет новых строк, начиная со времени последней проверки журнала Агентом; таким образом, количество зависит от интервала обновления элемента данных.Этот элемент данных не поддерживается для журнала событий Windows. |

1. Ключи элемента данных Modbus

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| m`odbus.get[точка входа,<id ведомого>,<функция>,<адрес>,<количество>,<тип>,<порядок следования байтов>,<сдвиг>]` |
| Чтение данных Modbus. | JSON объект | `–точка входа `– точка входа, определяемая в виде `протокол://строка_подключения;–id ведомого `– ID ведомого;`–функция `– функция Modbus;`–адрес `– адрес первого регистра, флага или входа;`–количество `– количество записей для чтения;`–тип `– тип данных;`–порядок следования байтов `– настройка порядка следования байтов;`–сдвиг `– количество регистров, начиная с "адреса", результаты которых будут отброшены. |  |

1. Ключи элемента сетевых данных

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| n`et.dns[<ip>,имя,<тип>,<время ожидания>,<количество>,<протокол>]` |
| Проверка работы DNS- сервиса | 0 – DNS не работает (Сервер не ответил или ответ DNS некорректен)1 – DNS работает | `–ip `– IP-адрес DNS-сервера (оставить пустым, чтобы использовались DNS-сервера по умолчанию, на Windows поддерживается Агентом-2, игнорируется Агентом-1);`–имя `– проверяемое имя DNS;`–тип `– запрашиваемый тип записи (по умолчанию SOA);`–время ожидания `– время ожидания ответа в секундах (по умолчанию 1 секунда);`–количество `– количество попыток запросов (по умолчанию 2);`–протокол `– используемый протокол при выполнении DNS-запросов: `udp `(по умолчанию) или `tcp` | Возможные значения для `тип:ANY,` `A,` `NS,` `CNAME,` `MB,` `MG,` `MR,` `PTR,` `MD,` `MF,` `MX,` `SOA,` `NULL,` `WKS `(не поддерживается Агентом на Windows, Агентом-2 на всех ОС), `HINFO,` `MINFO,` `TXT,` `AAAA,` `SRV.`Национальные доменные имена не поддерживаются; вместо них использовать имена в IDNA-кодировке. |
| n`et.dns.record[<ip>,имя,<тип>,<время ожидания>,<количество>,<протокол>]` |
| Выполнение DNS- запроса. | Строка символов с требуемым типом информации | `–ip `– IP-адрес DNS-сервера (оставить пустым, чтобы использовались DNS-сервера по умолчанию);`–имя –` проверяемое имя DNS;`–тип `– запрашиваемый тип записи (по умолчанию `SOA)`;`–время ожидания `– время ожидания ответа в секундах (по умолчанию 1 секунда);`–количество `– количество попыток запросов (по умолчанию 2);`–протокол –` используемый протокол при выполнении DNS-запросов: `udp `(по умолчанию) или `tcp.` | Возможные значения для `тип:ANY,` `A,` `NS,` `CNAME,` `MB,` `MG,` `MR,` `PTR,` `MD,` `MF,` `MX,` `SOA,` `NULL,` `WKS `(не поддерживается Агентом-1 на Windows, Агентом-2 на всех ОС), `HINFO,` `MINFO,` `TXT,` `AAAA,` `SRV.`Национальные доменные имена не поддерживаются; вместо них использовать имена в IDNA-кодировке. |
| n`et.if.collisions[if]` |
| Коллизии за пределами окна (out-of-window). | Целое число | `–if `– имя сетевого интерфейса |  |
| n`et.if.discovery` |
| Список сетевых интерфейсов. Используется низкоуровневым обнаружением. | Объект JSON |  | В некоторых версиях Windows (например, Server 2008) может потребоваться установка последних обновлений для поддержки не-ASCII символов в именах интерфейсов. |
| n`et.if.in[if,<режим>]` |
| Статистика по входящему трафику сетевого интерфейса. | Целое число | `–if `– имя сетевого интерфейса (UNIX); полное описание сетевого интерфейса или IPv4-адрес; или, если в фигурных скобках, GUID сетевого интерфейса (Windows);`–режим `– возможные значения:`Bytes `– количество байтов (по умолчанию);`packets `– количество пакетов;`errors `– количество ошибок;`dropped `– количество отброшенных пакетов;`overruns (fifo) `– количество ошибок FIFO-буфера;`frame `– количество ошибок кадрирования пакетов;`compressed `– количество сжатых пакетов, полученных драйвером устройства;`multicast `– количество кадров многоадресного вещания, которые получены драйвером устройства. | В Windows элемент данных берет значения из 64-битных счетчиков, если они доступны. 64-битные счетчики статистики по интерфейсам введены в Windows Vista и Windows Server 2008. Если 64-битные счетчики недоступны, Агент будет использовать 32-битные счетчики.Можно получить описания сетевых интерфейсов в Windows, используя элементы данных `net.if.discovery и`ли `net.if.list.`Можно использовать этот ключ с шагом предобработки "`Изменение в секунду"` для получения статистики байтов в секунду. |
| n`et.if.out[if,<режим>]` |
| Статистика по исходящему трафику сетевого интерфейса. | Целое число | `–if `– имя сетевого интерфейса (UNIX); полное описание сетевого интерфейса или IPv4-адрес; или, если в фигурных скобках, GUID сетевого интерфейса (Windows);`–режим `– возможные значения:`Bytes `– количество байтов (по умолчанию);`packets `– количество пакетов;`errors `– количество ошибок;`dropped `– количество отброшенных пакетов;`overruns (fifo) `– количество ошибок FIFO-буфера;`collisions (colls) `– количество коллизий, обнаруженных на интерфейсе;`carrier `– количество потерь несущей, обнаруженных драйвером устройства;`compressed `– количество сжатых пакетов, переданных драйвером устройства. | В Windows элемент данных берет значения из 64-битных счетчиков, если они доступны. 64-битные счетчики статистики по интерфейсам введены в Windows Vista и Windows Server 2008. Если 64-битные счетчики недоступны, Агент будет использовать 32-битные счетчики.Можно получить описания сетевых интерфейсов в Windows, используя элементы данных `net.if.discovery `или `net.if.list.`Можно использовать этот ключ с шагом предобработки "`Изменение в секунду"` для получения статистики байтов в секунду. |
| n`et.if.total[if,<режим>]` |
| Суммарная статистика входящего и исходящего трафика на сетевом интерфейсе. | Целое число | `–if `– имя сетевого интерфейса (UNIX); полное описание сетевого интерфейса или IPv4-адрес; или, если в фигурных скобках, GUID сетевого интерфейса (Windows);`–режим –` возможные значения:`Bytes `– количество байтов (по умолчанию);`packets `– количество пакетов;`errors `– количество ошибок;`dropped `– количество отброшенных пакетов;`overruns (fifo) `– количество ошибок FIFO-буфера;`compressed `– количество сжатых пакетов, переданных или полученных драйвером устройства. | В Windows элемент данных берет значения из 64-битных счетчиков, если они доступны. 64-битные счетчики статистики по интерфейсам введены в Windows Vista и Windows Server 2008. Если 64-битные счетчики недоступны, Агент будет использовать 32-битные счетчики.Можно получить описания сетевых интерфейсов в Windows, используя элементы данных `net.if.discovery `или `net.if.list.`Можно использовать этот ключ с шагом предобработки "`Изменение в секунду"` для получения статистики байтов в секунду.Обратить внимание: отброшенные пакеты поддерживаются, только если оба ключа `net.if.in `и `net.if.out р`аботают с отброшенными пакетами на вашей платформе. |
| n`et.tcp.LISTEN[порт]` |
| Проверка, находится ли TCP- порт в состоянии `LISTEN.` | 0 – не находится в состоянии `LISTEN`1 – находится в состоянии `LISTEN` | `–порт `– номер TCP-порта |  |
| n`et.tcp.port[<ip>,порт]` |
| Проверка возможности создания TCP подключения на указанный номер порта. | 0 – не удалось подключиться1 – удалось подключиться | `–ip `– IP-адрес или DNS-имя (по умолчанию 127.0.0.1);`–порт `– номер порта. | Пример:`=> net.tcp.port[,80] → м`ожно использовать для проверки доступности веб-сервера, работающего на 80 порту.Для простого тестирования производительности TCP использовать `net.tcp.service.perf[tcp,<ip>,<порт>]`Обратить внимание, что эти проверки могут привести к дополнительным записям в системных файлах журналов (обычно сессии SMTP и SSH журналируются). |
| n`et.tcp.service[сервис,<ip>,<порт>]` |
| Проверка, запущен ли сервис и принимает ли он TCP подключения. | 0 – сервис недоступен1 – сервис запущен | `–сервис `– один из:`ssh,` `ldap,` `smtp,` `ftp,` `http,` `pop,` `nntp,` `imap,` `tcp,` `https,` `telnet;` `–ip –` IP-адрес или DNS-имя (по умолчанию 127.0.0.1);`–порт `– номер порта (по умолчанию используется стандартный номер порта сервиса). | Пример:`=> net.tcp.service[ftp,,45] `можно использовать для тестирования доступности FTP-сервера на TCP 45 порту.Обратить внимание, что эти проверки могут привести к дополнительным записям в системных файлах журналов (обычно сессии SMTP и SSH журналируются).Проверка шифрованных протоколов (таких как IMAP на 993 порту или POP на 995 порту) в настоящее время не поддерживается. В качестве обходного решения для подобных проверок использовать `net.tcp.port.`Проверка LDAP и HTTPS на платформе Windows поддерживается только Агентом-2.Обратить внимание, что telnet проверка ищет запрос на вход (с ":" в конце). |
| n`et.tcp.service.perf[сервис,<ip>,<порт>]` |
| Проверка производительности TCP-сервиса. | 0 – сервис недоступенсекунды – количество секунд, потраченное на подключение к сервису | `–сервис `– один из:`ssh,` `ldap,` `smtp,` `ftp,` `http,` `pop,` `nntp,` `imap,` `tcp,` `https,` `telnet `;`–ip `– IP-адрес или DNS-имя (по умолчанию 127.0.0.1);`–порт `– номер порта (по умолчанию используется стандартный номер порта сервиса). | Пример:`=> net.tcp.service.perf[ssh] м`ожно использовать для тестирования скорости изначального ответа от SSH-сервера.Проверка шифрованных протоколов (таких как IMAP на 993 порту или POP на 995 порту) в настоящее время не поддерживается. В качестве обходного решения для подобных проверок использовать `net.tcp.service.perf[tcp,<ip>,<порт>].`Проверка LDAP и HTTPS на платформе Windows поддерживается только Агентом-2.Обратить внимание, что telnet проверка ищет запрос на вход (с ":" в конце). |
| n`et.tcp.socket.count[<локальный_адрес>,<локальный_порт>,<удаленный_адрес>,<удаленный_порт>,<состояние>]` |
| Получение количества TCP-сокетов, соответствующих заданным параметрам. | Целое число | `–локальный_адрес `– локальный IPv4/6-адрес или CIDR-подсеть;`–локальный_порт `– номер локального порта или имя сервиса;`–удаленный_адрес `– удаленный IPv4/6-адрес или CIDR-подсеть;`–удаленный_порт `– номер удаленного порта или имя сервиса;`–состояние `– состояние соединения (`established,` `syn_sent,` `syn_recv,` `fin_wait1,` `fin_wait2,` `time_wait, close,` `close_wait,` `last_ack,` `LISTEN,` `closing)` | Этот элемент данных поддерживается только на Linux как Агентом-1, так и Агентом-2. В Агенте-2 этот ключ также поддерживается на 64-битной Windows.Например:`=> net.tcp.socket.count[,80,,,established]–` проверка, имеется ли локальный TCP порт 80 в состоянии` established` |
| n`et.udp.LISTEN[порт]` |
| Проверка, находится ли UDP-порт в состоянии `LISTEN.` | 0 – не находится в состоянии `LISTEN`1 – находится в состоянии `LISTEN` | `–порт `– номер UDP-порта | Например:`=> net.udp.LISTEN[68]` |
| n`et.udp.service[сервис,<ip>,<порт>]` |
| Проверка, запущен ли сервис и принимает ли он UDP подключения. | 0 – сервис недоступен1 – сервис запущен | `–сервис `– `ntp;–ip `– IP-адрес или DNS-имя (по умолчанию 127.0.0.1);`–порт `– номер порта (по умолчанию используется стандартный номер порта сервиса) | Пример:`=> net.udp.service[ntp,,45] м`ожно использовать для тестирования доступности NTP сервиса на 45 порту UDP. |
| n`et.udp.service.perf[сервис,<ip>,<порт>]` |
| Проверка производительности UDP сервиса. | 0 – сервис недоступенсекунды – количество секунд, потраченное на ожидание ответа от сервиса | `–сервис `– `ntp;` `–ip `– IP-адрес или DNS-имя (по умолчанию 127.0.0.1);`–порт `– номер порта (по умолчанию используется стандартный номер порта сервиса) | Пример:`=> net.udp.service.perf[ntp] м`ожно использовать для тестирования времени отклика от NTP-сервиса. |
| n`et.udp.socket.count[<локальный_адрес>,<локальный_порт>,<удаленный_адрес>,<удаленный_порт>,<состояние>]` |
| Получение количества UDP-сокетов, соответствующих заданным параметрам. | Целое число | `–локальный_адрес `– локальный IPv4/6-адрес или CIDR-подсеть;`–локальный_порт –` номер локального порта или имя сервиса;–удаленный_адрес – удаленный IPv4/6-адрес или CIDR-подсеть;`–удаленный_порт `– номер удаленного порта или имя сервиса;`–состояние `– состояние соединения (`established,` `unconn)`. | Этот элемент данных поддерживается только на Linux как Агентом-1, так и Агентом-2. В Агенте-2 этот ключ также поддерживается на 64-битной Windows.Например:`=> net.tcp.socket.count[,,,,established] `возвращает количество UDP-сокетов в состоянии `established` |

1. Ключ элемента данных процессов

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| p`roc.cpu.util[<имя>,<пользователь>,<тип>,<cmdline>,<режим>,<зона>]` |
| Использование CPU процесса в процентах. | Число с плавающей точкой | `–имя `– имя процесса (по умолчанию все процессы); `–пользователь `– имя пользователя (по умолчанию все пользователи);`–тип `– тип использования CPU: `total (`по умолчанию), `user,` `system;–cmdline `– фильтр по командной строке (является регулярным выражением);`–режим `– режим сбора данных: `avg1 (`по умолчанию), `avg5,` `avg15;–зона `– целевая зона: `current (`по умолчанию), `all.` Этот параметр поддерживается только на платформе Solaris. | Примеры:`=> proc.cpu.util[,root] – `Использование CPU по всем процессам, работающим под пользователем `root;=> proc.cpu.util[zabbix_server,zabbix] `– Использование CPU по всем процессам zabbix_server работающими под пользователем `zabbix.`Возвращаемое значение основывается на использовании одного ядра CPU в процентах. Например, утилизация CPU процесса, полностью использующего два ядра, равна 200%.Данные использования CPU процессами собираются коллекторами, которые поддерживают максимально до 1024 уникальных (по имени, пользователю и командной строке) запросов. Запросы, к которым не было обращения в течение последних 24 часов, удаляются из коллектора.Обратить внимание, что в случае, если Агент скомпилирован на Solaris без поддержки зон, если задать параметр `зона `значением `current `(или по умолчанию) и запустить его на более новом Solaris, где зоны поддерживаются, то Агент вернет `NOTSUPPORTED `(Агент не может ограничить результаты в пределах только текущей зоны). Значение `all `в этом случае поддерживается. |
| p`roc.mem[<имя>,<пользователь>,<режим>,<cmdline>,<тип памяти>]` |
| Количество памяти, используемое процессом, в байтах. | Целое число – с `режимом `равным `max,` `min,` `sum`Дробное число – с `режимом р`авным `avg` | `–имя `– имя процесса (по умолчанию `все процессы)`;`–пользователь `– имя пользователя (по умолчанию `все пользователи)`;`–режим `– возможные значения: `avg,` `max,` `min,` `sum (`по умолчанию);`–cmdline `– фильтр по командной строке (является регулярным выражением);`–тип памяти `– тип памяти, используемый процессом. | Пример:`=> proc.mem[,root] –` память, используемая всеми процессами запущенными под пользователем `root.`Обратить внимание: если несколько процессов используют разделяемую память, сумма используемой процессами памяти может дать в результате большие, нереальные значения.Если этот элемент данных вызывается с командной строки и содержит параметр командной строки (например, при использовании тестового режима Агента: `zabbix_agentd -t proc.mem[,,,apache2])`, будет засчитан один дополнительный процесс, так как Агент посчитает самого себя. |
| p`roc.num[<имя>,<пользователь>,<состояние>,<cmdline>,<зона>]` |
| Количество процессов. | Целое число | `–имя –` имя процесса (по умолчанию `все процессы)`;`–пользователь `– имя пользователя (по умолчанию `все пользователи)`;`–состояние `– возможные значения:`all `(по умолчанию),`disk `– непрерывный сон,`run `– в процессе работы,`sleep `– прерываемый сон,`trace `– остановлен,`zomb `– зомби`–cmdline `– фильтр по командной строке (является регулярным выражением);`–зона `– целевая зона: `current `(по умолчанию), `all.` Этот параметр поддерживается только на платформе Solaris. | Примеры ключей:`=> proc.num[,mysql] `– количество процессов, выполняемых под пользователем mysql;`=> proc.num[apache2,www-data] `– количество процессов apache2, выполняемых под пользователем `www-data.`В Windows, поддерживаются только параметры `имя и` `пользователь.`Если этот элемент данных вызывается с командной строки и содержит параметр командной строки (например, при использовании тестового режима Агента: `zabbix_agentd -t proc.num[,,,apache2])`, будет засчитан один дополнительный процесс, так как Агент посчитает самого себя.Обратить внимание, что в случае, когда Агент скомпилирован на Solaris без поддержки зон, если задать параметр `зона `значением `current `(или по умолчанию) и запустить его на более новом Solaris, где зоны поддерживаются, то Агент вернет `NOTSUPPORTED `(Агент не может ограничить результаты в пределах только текущей зоны). Значение `all `в этом случае поддерживается. |

1. Ключ элемента данных датчиков

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| s`ensor[устройство,сенсор,<режим>]` |
| Чтение аппаратного сенсора. | Число с плавающей точкой | `–устройство `– имя устройства; может быть регулярным выражением, если режим не указан;`–сенсор `– имя сенсора; может быть регулярным выражением, если режим не указан;`–режим `– возможные значения:`avg,` `max,` `min `(если этот параметр не указан, то устройство и сенсор обрабатываются дословно). | В Linux 2.4 читается `/proc/sys/dev/sensors.`Пример:`=> sensor[w83781d-i2c-0-2d,temp1]` |
|  |  |  | В Linux 2.6+ читается `/sys/class/hwmon.` |
|  |  |  | В OpenBSD, читается MIB `hw.sensors.`Примеры:`=> sensor[cpu0,temp0] `– температура одного CPU`=> sensor[cpu[0-2]$,temp,avg] `– средняя температура первых трех CPU |

1. Ключ элемента данных о системе

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| s`ystem.boottime` |
| Штамп времени (timestamp) загрузки системы. | Целое число (UNIX timestamp) |  |  |
| s`ystem.cpu.discovery` |
| Список найденных CPU/CPU ядер. Используется низкоуровневым обнаружением. | Объект JSON |  |  |
| s`ystem.cpu.intr` |
| Прерывания устройств. | Целое число |  |  |
| s`ystem.cpu.load[<cpu>,<режим>]` |
| . | Число с плавающей точкой | `–cpu `– возможные значения:`all (`по умолчанию), `percpu `(общая загрузка делится на количество CPU онлайн);`–режим `– возможные значения:`avg1 `(усреднение за одну минуту, по умолчанию), `avg5,` `avg15` | Пример:`=> system.cpu.load[,avg5]` |
| s`ystem.cpu.num[<тип>]` |
| Количество CPU. | Целое число | `–тип `– возможные значения:`online `(по умолчанию), `max` | Пример:`=> system.cpu.num` |
| s`ystem.cpu.switches` |
| Количество переключений контекста. | Целое число |  |  |
| s`ystem.cpu.util[<cpu>,<тип>,<режим>,<логический_или_физический>]` |
| Утилизация CPU в процентах. | Число с плавающей точкой | `–cpu `– `<номер CPU> и`ли `all (`по умолчанию);`–тип `– возможные значения:`user (`по умолчанию), `idle,` `nice,` `system `(по умолчанию для Windows), `iowait,` `interrupt,` `softirq,` `steal,` `guest (`на ядрах Linux 2.6.24 и выше), `guest_nice (`на ядрах Linux 2.6.33 и выше);`–режим `– возможные значения:`avg1 (`усреднение за одну минуту, по умолчанию), `avg5,` `avg15;–логический_или_физический `(только на AIX) – возможные значения: `logical (`по умолчанию), `physical.` Этот параметр поддерживается только на AIX. | На Windows значение получается с использованием счетчика производительности "`Processor Time"`. Обратить внимание, начиная с Windows 8 его Менеджер Задач отображает утилизацию CPU, используя счетчик производительности "`Processor Utility".`Пример:`=> system.cpu.util[0,user,avg5]` |
| s`ystem.Hostname[<тип>, <преобразование>]` |
| Системное имя хоста. | Строка | `–тип `– возможные значения: `netbios `(по умолчанию на Windows), `host `(по умолчанию на Linux), `shorthost `возвращает часть хоста до первой точки, всю строку для имен без точек);`–преобразование –` возможные значения:`none `(по умолчанию), `lower `(конвертация в нижний регистр) | Значение опрашивается на платформе Windows либо функцией `GetComputerName() `(для `netbios)`, либо функцией `getHostname() `(для `host)`, а на остальных системах – забирая значение `nodename `из вывода системного API `uname().` |
| s`ystem.hw.chassis[<информация>]` |
| Информация о шасси. | Строка | `–информация `– одно из `full `(по умолчанию), `model,` `serial,` `type `или `vendor` | Пример:`system.hw.chassis[full]Hewlett-Packard HP Pro 3010 Small Form Factor PC CZXXXXXXXX Desktop]`Этот ключ зависит от наличия  таблицы.Будет выполнена попытка чтения DMI таблицы из `sysfs;` если доступ к `sysfs `будет неудачным, то будет попытка чтения напрямую из памяти.Требуются права** **`root,` потому что значение читается из `sysfs `или памяти. |
| s`ystem.hw.cpu[<cpu>,<информация>]` |
| Информация о CPU. | Строка или целое число | `–cpu `– `<номер CPU> `или `all `(по умолчанию);`–информация `– возможные значения:`full `(по умолчанию), `curfreq,` `maxfreq,` `model `или `vendor` | Пример:`=> system.hw.cpu[0,vendor] → AuthenticAMD`Информация собирается из `/proc/cpuinfo и` из `/sys/devices/system/cpu/[cpunum]/cpufreq/cpuinfo_max_freq.`Если указаны номер CPU и `curfreq `или `maxfreq,` то возвращается числовое значение (Гц). |
| s`ystem.hw.devices[<тип>]` |
| Список PCI или USB устройств. | Текст | `–тип `– `pci `(по умолчанию) или `usb` | Пример:`=> system.hw.devices[pci] → 00:00.0 Host bridge: Advanced Micro Devices [AMD] RS780 Host Bridge[..]`Возвращает вывод утилит `lspci `или `lsusb `(выполняются без каких-либо параметров). |
| s`ystem.hw.macaddr[<интерфейс>,<формат>]` |
| Список MAC адресов. | Строка | `–интерфейс `– `all `(по умолчанию) или регулярное выражение;`–формат `– `full `(по умолчанию) или `short.` | Список MAC-адресов интерфейсов, чьи имена совпадают с заданным в параметре `интерфейс `регулярным выражением (`all `список всех интерфейсов).Пример: `=> system.hw.macaddr["eth0$",full] => [eth0] 00:11:22:33:44:55Е`сли `формат `задан значением `short,` имена интерфейсов и одинаковые MAC-адреса не попадут в список. |
| s`ystem.localtime[<тип>]` |
| Системное время. | Целое число – с `тип `как `utc`Строка – с `тип `как `local.` | `–type `– возможные значения:`utc `– (по умолчанию) время с начала Эпохи (00:00:00 UTC, Январь 1, 1970), измеренное в секундах.`local `– время в формате "гггг-мм-дд,чч:мм:сс.ннн,+чч:мм" | Необходимо использовать только как пассивную проверку.Например:`=> system.localtime[local] `– создать элемент данных, используя этот ключ, и далее использовать его для отображения времени узла сети в элементе Комплексного экрана `Часы.` |
| s`ystem.run[команда,<режим>]` |
| Выполнение указанной команды на узле сети. | Текст с результатом выполнения команды1 – c `режимом `со значением `nowait `(независимо от результата выполнения команды) | `–команда `– выполняемая команда;`–режим `– возможные значения:`wait `– ожидать завершения выполнения (по умолчанию),`nowait `– не ожидать | Возвращаемое значение элемента данных является стандартным выводом совместно со стандартным выводом ошибок, которые получены от команды. Код завершения не проверяется.Для корректной обработки, возвращаемое командой значение должно иметь тип данных `текст.` Пустой результат также допустим.Возвращаемое значение ограничено 16 МБ (включая конечные пробелы, которые усекаются); также применяются ограничения баз данных.Обратить внимание, что элементы данных `system.run `по умолчанию запрещены. Пример:`=> system.run[ls -l /] `– подробный список файлов в корневой директории. |
| s`ystem.stat[ресурс,<тип>]` |
| Статистика системы. | Целое число или число с плавающей точкой | `–ent `– количество процессорных единиц, выделенных на ресурс (с плавающей точкой);`–kthr,<тип> `– информация о состояниях потоков ядра:`r `– среднее количество запускаемых потоков ядра (дробное)`b `– среднее количество потоков ядра, помещенных в очередь ожидания Менеджера Виртуальный Памяти (с плавающей точкой);`–memory,<тип> `– информация об использовании виртуальной и реальной памяти:`avm `– активные виртуальные страницы (целое)`fre `– размер свободного списка (целое);`–page,<тип> `– информация об ошибках страниц и активности страниц:`fi `– операции страничного ввода файлов в секунду (с плавающей точкой)`fo `– операции страничного вывода файлов в секунду (с плавающей точкой)`pi `– страницы, выгружаемые из подкачки (с плавающей точкой)`po `– страницы, загружаемые в подкачку (с плавающей точкой)`fr `– замененные страницы (с плавающей точкой)`sr `– количество страниц, сканированных алгоритмом замещения страниц (с плавающей точкой);`–faults,<тип> `– соотношение ловушек и прерываний:`in `– прерывания устройства (с плавающей точкой);`sy `– системные вызовы (с плавающей точкой);`cs `– переключения контекста потока ядра (с плавающей точкой);`–cpu,<тип> `– распределение процессорного времени в процентах:`us `– пользовательское время (с плавающей точкой);`sy `– системное время (с плавающей точкой);`id `– время простоя (с плавающей точкой);`wa `– время простоя, в ходе которого система обрабатывала запросы I/O диска/NFS (с плавающей точкой);`pc `– количество использованных физических процессоров (с плавающей точкой);`ec `– процентное соотношение размеченного занятого пространства (с плавающей точкой);`lbusy `– отображает утилизацию в процентах для логических процессор(ов), которая произошла при выполнении уровней пользователя и системы (с плавающей точкой);`app `– отображает количество доступных физических процессоров в распределенном пуле (с плавающей точкой);`–disk,<тип> `– статистика о дисках:`bps `– отображает суммарное количество данных переданных (чтением или записью) на диск в байтах в секунду (целое);`tps `– показывает количество передач за секунду, которые произошли на физическом диске/ленте (с плавающей точкой). | Этот элемент данных поддерживается только на AIX.Учесть следующие ограничения этих ключей:`=> system.stat[cpu,app] `– поддерживается только на AIX LPAR с типом `Shared;=> system.stat[cpu,ec] `– поддерживается на AIX LPAR с типом `Shared `и `Dedicated `(`Dedicated `всегда возвращает 100 (процентов));`=> system.stat[cpu,lbusy] `– поддерживается только на AIX LPAR с типом `Shared;=> system.stat[cpu,pc] `– поддерживается на AIX LPAR с типом `Shared `и `Dedicated;=> system.stat[ent] `– поддерживается на AIX LPAR с типом `Shared `и `Dedicated.` |
| s`ystem.sw.arch` |
| Информация об архитектуре программного обеспечения. | Строка | Пример:`=> system.sw.arch → i686`Для получения информации используется функция `uname().` |
| s`ystem.sw.os[<информация>]` |
| Информация об операционной системе. | Строка | `–информация `– возможные значения: `full `(по умолчанию), `short `или `name` | Пример:`=> system.sw.os[short] → Ubuntu 2.6.35-28.50-generic 2.6.35.11`Информация извлекается из (Следует обратить внимание, что не все файлы и опции представлены во всех дистрибутивах):`/proc/version (full)/proc/version_signature (short)П`араметр `PRETTY_NAME `из `/etc/os-release `на системах, которые его поддерживают, или `/etc/issue.net (name)` |
| s`ystem.sw.packages[<регулярное выражение>,<менеджер>,<формат>]` |
| Список установленных пакетов. | Текст | `–регулярное выражение `– `all `(по умолчанию) или регулярное выражение;`–менеджер –` `all `(по умолчанию) или конкретный менеджер пакетов;`–формат `– `full `(по умолчанию) или `short.` | Список (в алфавитном порядке) установленных пакетов, имена которых совпадают с регулярным выражением, заданным в `пакет `(`all `списки всех).Пример:`=> system.sw.packages[mini,dpkg,short]→ python-minimal, python2.6-minimal, ubuntu-minimal`Поддерживаемые менеджеры пакетов (выполняемые команды):`dpkg (dpkg --get-selections)pkgtool (ls /var/log/packages)rpm (rpm -qa)pacman (pacman -Q)`Если `формат `указан значением `full,` пакеты группируются по менеджерам пакетов (каждый менеджер с отдельной строки, которая начинается с его имени, заключенного в квадратные скобки).Если `формат `указан значением `short,` пакеты не группируются и отображаются одной строкой. |
| s`ystem.swap.in[<устройство>,<тип>]` |
| Статистика файла подкачки в (с устройства в память). | Целое число | `–устройство `– устройство, используемое для файла подкачки (по умолчанию `all)`;`–тип `– возможные значения:`count `(количество swapins), `sectors `(секторов swapped in), `pages `(страниц swapped in). | Пример:`=> system.swap.in[,pages]`Источником этой информации является:`/proc/swaps, /proc/partitions, /proc/stat (`Linux 2.4)`/proc/swaps, /proc/diskstats, /proc/vmstat (`Linux 2.6) |
| s`ystem.swap.out[<устройство>,<тип>]` |
| Статистика файла подкачки из (из памяти в устройство). | Целое число. | `–устройство `– устройство, используемое для файла подкачки (по умолчанию `all)`;`–тип `– возможные значения:`count `(количество swapouts), `sectors `(секторов swapped out), `pages `(страниц swapped out). | Пример:`=> system.swap.out[,pages]`Источником этой информации является:/`/proc/swaps, /proc/partitions, /proc/stat (`Linux 2.4)`/proc/swaps, /proc/diskstats, /proc/vmstat (`Linux 2.6) |
| s`ystem.swap.size[<устройство>,<тип>]` |
| Размер файла подкачки в байтах или процентах от общего размера. | Целое число – для количества байтЧисло с плавающей точкой – для процентов. | `–устройство `– устройство, используемое для файла подкачки (по умолчанию `all)`;`–тип `– возможные значения:`free `(свободно в файле подкачки, по умолчанию), `pfree `(свободно в файле подкачки, в процентах), `pused `(используемое место в файле подкачки, в процентах), `total `(полный размер файла подкачки), `used `(используется места в файле подкачки)Обратить внимание, что `pfree,` `pused `не поддерживаются на Windows, если размер файла подкачки нулевой. | Пример:`=> system.swap.size[,pfree] – `свободное место в файле подкачки в процентахЕсли `устройство `не указано, Агент будет брать во внимание только swap-устройства (файлы), физическая память будет игнорироваться. Например, на Solaris системах команда "`swap -s"` включает часть физической памяти и swap-устройства (в отличие от "`swap -l"`).Обратить внимание, этот ключ может возвращать некорректные данные размера места в файле подкачки, а также в процентах, на виртуализированных (VMware ESXi, VirtualBox) Windows платформах. В этом случае можно использовать ключ `perf_counter[\700(_Total)\702] `для получения корректного использования файла подкачки в процентах. |
| s`ystem.uname` |
| Идентификация системы. | Строка |  | Пример возвращаемого значения (UNIX):`FreeBSD localhost 4.2-RELEASE FreeBSD 4.2-RELEASE #0: Mon Nov i386`Пример возвращаемого значения (Windows):`Windows ZABBIX-WIN 6.0.6001 Microsoft® Windows Server® 2008 Standard Service Pack 1 x86В` UNIX значение этого элемента данных извлекается при помощи системного вызова `uname().` Ранее эта информация запрашивалась с помощью системного вызова "`uname -a"`. Значение этого элемента данных может отличаться от вывода "`uname -a"` и может не включать дополнительную информацию, которую "`uname -a"` выводит на основании на других источников.В Windows значение этого элемента данных извлекается при помощи классов WMI `Win32_OperatingSystem `и `Win32_Processor.` Ранее эта информация запрашивалась при помощи непостоянных вызовов Windows API и недокументированных ключей реестра. Имя ОС (включая редакцию) может быть переведено на пользовательский язык интерфейса. Некоторые версии Windows содержат символы товарных знаков и дополнительные пробелы.Обратить внимание, что этот элемент данных в Windows возвращает архитектуру ОС, при этом в UNIX он возвращает архитектуру CPU. |
| s`ystem.uptime` |
| Время работы в секундах. | Целое число |  | При настройке элемента данных использовать единицы измерения `s `или `uptime `для получения читабельных значений. |
| s`ystem.users.num` |
| Количество пользователей, находящихся в системе. | Целое число |  | Для получения значений используется команда `who `на стороне Агента. |

1. Ключ элемента данных виртуальных файловых систем

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| v`fs.dev.discovery` |
| Список блочных устройств и их типов. Используется низкоуровневым обнаружением. | JSON объект |  | Этот элемент данных поддерживается только на платформе Linux. |
| v`fs.dev.read[<устройство>,<тип>,<режим>]` |
| Статистика чтения диска. | Целое число при `тип `равном: `sectors,` `operations,` `Bytes`Число с плавающей точкой при `тип `равном: `sps,` `ops,` `bps`Обратить внимание: если используется интервал обновления три часа и более**2**, будет всегда возвращаться значение "0" | `–устройство `– дисковое устройство (по умолчанию `all `**3**);`–тип `– возможные значения:`sectors,` `operations,` `Bytes,` `sps,` `ops,` `bps`Обратить внимание, что поддержка и умолчания параметра `тип `зависят от платформы. См. подробную информацию о зависимости от платформы.`sps,` `ops,` `bps `соответствуют: секторам, операциям, байтам в секунду соответственно`–режим `– возможные значения:`avg1 `(усреднение за минуту, по умолчанию), `avg5 `(усреднение за 5 минут), `avg15 `(усреднение за 15 минут).Третий параметр поддерживается, только если `тип `один из: `sps, ops, bps.` | Можно использовать относительные имена устройств (например, `sda)`, а также необязательный префикс` /dev/ `(например, `/dev/sda)`.Поддерживаются логические тома LVM.Значения по умолчанию параметра "`тип"` для различных ОС:AIX – `operations`FreeBSD – `bps`Linux – `sps`OpenBSD – `operations`Solaris – `Bytes`Пример:`=> vfs.dev.read[,operations]ops,` `bps `и `sps `на поддерживаемых платформах ранее было ограничено 8 устройствами (7 отдельных устройств и одно `all)`. |
| v`fs.dev.write[<устройство>,<тип>,<режим>]` |
| Статистика записи на диск. | Целое число при `тип `равном: `sectors,` `operations,` `Bytes`Число с плавающей точкой при `тип `равном: `sps,` `ops,` `bps`Обратить внимание: если используется интервал обновления три часа и более**2**, будет всегда возвращаться значение "0" | `–устройство `– дисковое устройство (по умолчанию `all `**3**);`–тип `– возможные значения:`sectors,` `operations,` `Bytes,` `sps,` `ops,` `bps`Обратить внимание, что поддержка и умолчания параметра `тип `зависят от платформы. `sps,` `ops,` `bps `соответствуют: секторам, операциям, байтам в секунду соответственно;`–режим `– возможные значения:`avg1 `(усреднение за минуту, по умолчанию), `avg5 `(усреднение за 5 минут), `avg15 `(усреднение за 15 минут).Третий параметр поддерживается только если `тип `один из:` sps, ops, bps.` | Можно использовать относительные имена устройств (например, `sda)`, а также необязательный префикс `/dev/ `(например, `/dev/sda)`.Поддерживаются логические тома LVM.Значения по умолчанию параметра "`тип"` для различных ОС:AIX – `operations`FreeBSD – `bps`Linux – `sps`OpenBSD – `operations`Solaris – `Bytes`Пример: `=> vfs.dev.write[,operations]ops,` `bps `и `sps `на поддерживаемых платформах ранее было ограничено 8 устройствами (7 отдельных устройств и одно `all)`. |
| v`fs.dir.count[директория,<regex_вкл>,<regex_искл>,<типы_вкл>,<типы_искл>,<макс_глубина>,<мин_размер>,<макс_размер>,<мин_возраст>,<макс_возраст>,<regex_искл_директории>]` |
| Количество записей в директории. | Целое число | `–директория `– абсолютный путь к директории;`–regex_вкл `– регулярное выражение, описывающее шаблон включаемых имен сущностей (файлов, директорий и символических ссылок); если пусто, включается все (по умолчанию);`–regex_искл `– регулярное выражение, описывающее шаблон исключаемых имен сущностей (файлов, директорий и символических ссылок); если пусто (по умолчанию), исключения не применяются;`–типы_вкл `– перечисление типов записей в директории, которые будут подсчитываться, возможные значения:`file `– обычный файл, `dir `– поддиректория, `sym `– символическая ссылка, `sock `– сокет, `bdev `– блочное устройство, `cdev `– устройство посимвольного ввода-вывода, `fifo-` FIFO, `dev-` синоним к "`bdev,cdev"`, `all-` все вышеупомянутые типы (по умолчанию), т.е. "`file,`dir,sym,sock,`bdev,cdev,`fifo". Несколько типов необходимо разделять запятой и весь список заключать в двойные кавычки;`–типы_искл `– перечисление типов записей (см. `<типы_вкл>)` в директории, которые не будут подсчитываться. Если какие-либо типы записей указаны как в `<типы_вкл>,` так и в `<типы_искл>,` записи этих типов в директории не будут подсчитаны;`–макс_глубина `– максимальная глубина сканируемых поддиректорий. `-1 `(по умолчанию) – без ограничения, `0 `– не опускаться в поддиректории;`–мин_размер `– минимальный размер (в байтах) подсчитываемых файлов. Файлы, которые меньше этого значения, не будут подсчитаны. Можно использовать суффиксы памяти;`–макс_размер `– максимальный размер (в байтах) подсчитываемых файлов. Файлы, которые больше этого значения, не будут подсчитаны. Можно использовать суффиксы памяти;`–мин_возраст `– минимальный возраст (в секундах) подсчитываемой записи директории. Более свежие записи не будут подсчитаны. Можно использовать суффиксы времени;`–макс_возраст `– максимальный возраст (в секундах) подсчитываемой записи директории. Записи этого возраста и более старые (время модификации) не будут подсчитаны. Можно использовать суффиксы времени;`–regex_искл_директории `– регулярное выражение, описывающее шаблон имен исключаемых директорий. Все содержимое директории будет исключено (в отличие от `regex_искл)` | Переменные среды, такие как `%APP_HOME%, $HOME и %TEMP%,` не поддерживаются.Псевдо-директории "." и ".." никогда не учитываются.При обходе директорий символические ссылки никогда используются.В Windows символические ссылки директорий пропускаются.Оба параметра `regex_вкл `и `regex_искл `применяются к файлам и директориям при вычислении общего количества, но игнорируются при выборе поддиректорий для обхода (если `regex_вкл `равен "`(?i)^.+\.zip$"` и `макс_глубина `не задана, то будут обойдены все поддиректории, но посчитаны только файлы с типом zip).Время выполнения ограничено значением времени ожидания в конфигурации Агента. Так как сканирование большой директории может занять более длительное время, чем время ожидания, то никакие данные не возвратятся, и элемент данных будет отмечен как "Не поддерживается". Результат частичного подсчета не возвращается.При фильтрации по размеру только обычные файлы имеют осмысленные размеры. В Linux и BSD директории также имеют ненулевые размеры (в основном несколько Кб). Устройства имеют нулевые размеры; например, размер `/dev/sda1 `не отражает размер соответствующего раздела. Поэтому, при использовании параметров `<мин_размер> `и `<макс_размер> `рекомендуется указать `<типы_вкл> `равным "`file"`, чтобы избежать неожиданностей.Примеры:⇒` vfs.dir.count[/dev] `– мониторинг количества устройств в `/dev `(Linux)⇒` vfs.dir.count["C:\Users\ADMINI~1\AppData\Local\Temp"] `– мониторинг количества файлов во временной директории (Windows) |
| v`fs.dir.get[директория,<regex_вкл>,<regex_искл>,<типы_вкл>,<типы_искл>,<макс_глубина>,<мин_размер>,<макс_размер>,<мин_возраст>,<макс_возраст>,<regex_искл_директории>]` |
| Список содержимого директории. | JSON | `–директория `– абсолютный путь к директории;`–regex_вкл `– регулярное выражение, описывающее шаблон включаемых имен сущностей (файлов, директорий и символических ссылок); если пусто, включается все (по умолчанию);`–regex_искл `– регулярное выражение, описывающее шаблон исключаемых имен сущностей (файлов, директорий и символических ссылок); если пусто (по умолчанию), исключения не применяются;`–типы_вкл `– перечисление типов записей в директории, которые будут добавлены в список, возможные значения:`file `– обычный файл, `dir `– поддиректория, `sym `– символическая ссылка, `sock `– сокет, `bdev `– блочное устройство, `cdev `– устройство посимвольного ввода-вывода, `fifo-` FIFO, `dev-` синоним к "`bdev,cdev"`, `all-` все вышеупомянутые типы (по умолчанию), т.е. "`file,dir,sym,sock,bdev,cdev,fifo"`. Несколько типов необходимо разделять запятой и весь список заключить в двойные кавычки;`–типы_искл `– перечисление типов записей (см. `<типы_вкл>)` в директории, которые не будут добавлены в список. Если какие-либо типы записей указаны как в `<типы_вкл>,` так и в `<типы_искл>,` записи этих типов в директории не будут добавлены в список;`–макс_глубина `– максимальная глубина сканируемых поддиректорий. `-1 `(по умолчанию) – без ограничения, `0 `– не опускаться в поддиректории;`–мин_размер `– минимальный размер (в байтах) добавляемых в список файлов. Файлы, которые меньше этого значения, не будут добавлены в список. Можно использовать суффиксы памяти;`–макс_размер `– максимальный размер (в байтах) добавляемых в список файлов. Файлы, которые больше этого значения, не будут добавлены в список. Можно использовать суффиксы памяти;`–мин_возраст `– минимальный возраст (в секундах) добавляемой в список записи директории. Более свежие записи не будут добавлены в список. Можно использовать суффиксы времени;`–макс_возраст `– максимальный возраст (в секундах) добавляемой в список записи директории. Записи этого возраста и более старые (время модификации) не будут добавлены в список. Можно использовать суффиксы времени;`–regex_искл_директории `– регулярное выражение, описывающее шаблон имен исключаемых директорий. Все содержимое директории будет исключено (в отличие от `regex_искл)` | Переменные среды, такие как `%APP_HOME%, $HOME и %TEMP%,` не поддерживаются.Псевдо-директории "." и ".." никогда не учитываются.При обходе директорий символические ссылки никогда используются.В Windows символические ссылки директорий пропускаются.Оба параметра `regex_вкл `и `regex_искл `применяются к файлам и директориям при генерации списка содержимого директории, но игнорируются при выборе поддиректорий для обхода (если `regex_вкл `равен "`(?i)^.+\.zip$"` и `макс_глубина `не задана, то будут обойдены все поддиректории, но в список будут добавлены только файлы с типом zip).Время выполнения ограничено значением времени ожидания в конфигурации Агента. Так как сканирование большой директории может занять более длительное время, чем время ожидания, то никакие данные не возвратятся, и элемент данных будет отмечен как "`Не поддерживается"`. Частичный список не возвращается.При фильтрации по размеру только обычные файлы имеют осмысленные размеры. В Linux и BSD директории также имеют ненулевые размеры (в основном несколько Кб). Устройства имеют нулевые размеры; например, размер `/dev/sda1 `не отражает размер соответствующего раздела. Поэтому, при использовании параметров `<мин_размер> `и `<макс_размер> `рекомендуется указать `<типы_вкл> `равным "`file"`, чтобы избежать неожиданностей.Примеры:⇒` vfs.dir.get[/dev] `– получение списка устройств в `/dev `(Linux)⇒` vfs.dir.get["C:\Users\ADMINI~1\AppData\Local\Temp"] `– получение списка файлов во временной директории (Windows) |
| v`fs.dir.size[директория,<regex_вкл>,<regex_искл>,<режим>,<макс_глубина>,<regex_искл_директории>]` |
| Размер директории (в байтах). | Целое число | `–директория `– абсолютный путь к директории`regex_вкл `– регулярное выражение, описывающее шаблон включаемых имен сущностей (файлов, директорий и символических ссылок); если пусто, включается все (по умолчанию)`regex_искл `– регулярное выражение, описывающее шаблон исключаемых имен сущностей (файлов, директорий и символических ссылок); если пусто (по умолчанию), исключения не применяются;`–режим `– возможные значения:`apparent `(по умолчанию) – получение реальных размеров файлов вместо использования диска (работает как `du -sb директория)`, `disk `– получение использования диска (работает как `du -s -B1 директория)`. В отличие от команды du, элемент данных vfs.dir.size при вычислении размера директории учитывает скрытые файлы (работает как `du -sb .[^.]* * `в пределах директории).`макс_глубина `– максимальная глубина сканируемых поддиректорий. `-1 `(по умолчанию) – без ограничения, `0 `– не опускаться в поддиректории;`–regex_искл_директории `– регулярное выражение, описывающее шаблон имен исключаемых директорий. Все содержимое директории будет исключено (в отличие от `regex_искл)` | Подсчитываются только те директории, к которым пользователь `zabbix `имеет по крайней мере права чтения.В Windows любая символическая ссылка пропускается, а жесткие ссылки учитываются только один раз.При наличии больших директорий или медленных дисков этот элемент данных может превысить время ожидания из-за настройки `Timeout `в файлах конфигурации Агента и Сервера/Прокси. При необходимости увеличить эти значения времени ожидания.Примеры:⇒` vfs.dir.size[/tmp,log] `– вычисление размеров всех файлов в /tmp, которые содержат в своем имени `log`⇒` vfs.dir.size[/tmp,log,^.+\.old$] `– вычисление размеров всех файлов в /tmp, которые содержат в своем имени `log,` исключая файлы с именами, оканчивающимися на "`.old"`Ограничение размера файлов зависит от наличия поддержки больших файлов. |
| v`fs.file.cksum[файл,<режим>]` |
| Контрольная сумма файла, вычисленная по алгоритму, используемому в UNIX cksum. | Целое число – с `режимом `в значении `crc32`Строка – с `режимом `в значениях `md5,` `sha256` | `–файл `– абсолютный путь к файлу;`–режим `– `crc32 `(по умолчанию), `md5,` `sha256` | Пример:`=> vfs.file.cksum[/etc/passwd]`Пример возвращаемых значений (для crc32/md5/sha256 соответственно):`6754361019845acf68b73991eb7fd7ee0ded23c44ae67546e4aac995e5c921042d0cf0f1f7147703aa42bfbfb65404b30f238f2dcО`граничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.contents[файл,<кодировка>]` |
| Получение содержимого файла. | Текст | `–файл `– абсолютный путь к файлу;`–кодировка `– идентификатор кодовой страницы. | Возвращает пустую строку, если файл пустой или содержит только LF/CR символы.Возвращаемое значение ограничено 16 МБ (включая конечные пробелы, которые усекаются); также применяются ограничения баз данных.Маркер последовательности байтов (BOM) исключен из вывода.Пример:`=> vfs.file.contents[/etc/passwd]` |
| v`fs.file.exists[файл,<типы_вкл>,<типы_искл>]` |
| Проверка существования файла | 0 – файл не найден1 – файл заданного типа существует. | `–файл `– абсолютный путь к файлу;`–типы_вкл `– список включаемых типов файлов, возможные значения: `file `(обычный файл, по умолчанию (если `типы_искл `не задан)), `dir `(директория), `sym `(символическая ссылка), `sock `(сокет), `bdev `(блочное устройство), `cdev `(устройство посимвольного ввода-вывода), `fifo `(FIFO), `dev `(синоним к "`bdev,cdev"`), `all `(все вышеупомянутые типы, по умолчанию если `типы_искл `задан);`–типы_искл `– список исключаемых типов файлов, См. `типы_вкл `для получения возможных значений (по умолчанию никакие типы не исключаются) | Несколько типов необходимо разделять запятой и весь список заключить в "" (кавычки).На Windows двойные кавычки необходимо экранировать обратной косой чертой "\" и весь ключ элемента данных должен быть заключен в двойные кавычки при использовании утилиты zabbix_get.exe или agent2 в командной строке.Если какие-либо типы записей указаны как в `<типы_вкл>,` так и в `<типы_искл>,` файлы этих типов будут исключены.Примеры:`=> vfs.file.exists[/tmp/application.pid]=> vfs.file.exists[/tmp/application.pid,"file,dir,sym"]=> vfs.file.exists[/tmp/application_dir,dir]`Ограничение размера файла зависит от поддержки больших файлов.Обратить внимание, элемент данных может стать неподдерживаемым на Windows, если искомая директория ищется в несуществующей директории, например, `vfs.file.exists[C:\нет\dir,dir] `(где "`нет"` не существует). |
| v`fs.file.get[файл]` |
| Получение информации о файле. | Объект JSON | `–файл `– абсолютный путь к файлу | Поддерживаемые типы файлов в UNIX подобных системах: обычный файл, директория, символическая ссылка, сокет, блочное устройство, устройство посимвольного ввода-вывода, FIFOПоддерживаемые типы файлов на Windows: обычный файл, директория, символическая ссылкаНапример:`=> vfs.file.get[/etc/passwd] `– получение JSON с информацией о файле `/etc/passwd `(тип, пользователь, права доступа, SID, uid и т.п.) |
| v`fs.file.md5sum[файл]` |
| MD5 контрольная сумма файла | Строка (MD5 хеш-сумма файла) | `–файл `– абсолютный путь к файлу | Пример:`=> vfs.file.md5sum[/usr/local/etc/zabbix_agentd.conf]`Пример возвращаемого значения:`b5052decb577e0fffd622d6ddc017e82`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.owner[файл,<тип_владельца>,<тип_результата>]` |
| Получение владельца файла. | Строка символов | `–файл `– абсолютный путь к файлу;`–тип_владельца `– `user `(по умолчанию) или `group `(только в UNIX);`–тип_результата `– `name `(по умолчанию) или `id;` в случае с id – получение uid/gid на UNIX, SID на Windows. | Пример:`=> vfs.file.owner[/tmp/zabbix_server.log] `– получение владельца файла `/tmp/zabbix_server.log;=> vfs.file.owner[/tmp/zabbix_server.log,,id] `– получение ID владельца файла `/tmp/zabbix_server.log.`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.permissions[файл]` |
| Получение строки из 4 цифр, содержащую восьмеричное число с правами доступа UNIX. | Строка | `–файл `– абсолютный путь к файлу | Не поддерживается на Windows.Пример:`=> vfs.file.permissions[/etc/passwd] – `получение прав доступа к `/etc/passwd,` например, "`0644"`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.regexp[файл,регулярное выражение,<кодировка>,<начальная строка>,<конечная строка>,<вывод>]` |
| Поиск строки в файле. | Строка, содержащая совпадающую подстроку, или то, что определено в дополнительном параметре `вывод.` | `–файл `– абсолютный путь к файлу;`–регулярное выражение `– регулярное выражение, описывающее требуемый шаблон;`–кодировка `– идентификатор кодовой страницы;`–начальная строка `– номер первой строки для поиска (по умолчанию, первая строка файла);`–конечная строка `– номер последней строки для поиска (по умолчанию, последняя строка файла);`–вывод `– дополнительный шаблон форматирования вывода;`–\0 `– управляющая последовательность заменяется найденной частью текста (начиная от первого символа совпадения, заканчивая символом, где совпадение заканчивается), то `\N `(где `N=1..9)` – управляющая последовательность заменяется N-ной совпадающей группой (или пустой строкой, если N превышает количество найденных групп). | Возвращается только первая совпавшая строка.Если совпадений с выражением не найдено, будет возвращена пустая строка.Маркер последовательности байтов (BOM) исключается из вывода.Извлечение содержимого при использовании параметра вывод выполняется Агентом.Параметры `начальная строка,` `конечная строка `и `вывод. `Примеры:`=> vfs.file.regexp[/etc/passwd,zabbix]=> vfs.file.regexp[/path/to/some/file,"([0-9]+)$",,3,5,\1]=> vfs.file.regexp[/etc/passwd,"^zabbix:.:([0-9]+)",,,,\1] `– получение ID пользователя `zabbix`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.regmatch[файл,регулярное выражение,<кодировка>,<начальная строка>,<конечная строка>]` |
| Поиск строки в файле. | 0 – совпадение не найдено1 – найдено | `–файл `– абсолютный путь к файлу;`–регулярное выражение `– регулярное выражение, описывающее требуемый шаблон;–кодировка – идентификатор кодовой страницы;–начальная строка – номер первой строки для поиска (по умолчанию, первая строка файла);`–конечная строка `– номер последней строки для поиска (по умолчанию, последняя строка файла). | Маркер последовательности байтов (BOM) игнорируется.Параметры `начальная строка,` `конечная строка `.Например:`=> vfs.file.regmatch[/var/log/app.log,error]`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.size[файл,<режим>]` |
| Размер файла (в байтах). | Целое число | `–файл `– абсолютный путь к файлу;`–режим `– возможные значения:`Bytes `(по умолчанию) или `lines `(пустые строки также считаются) | Пользователь `zabbix `должен иметь права на чтение файлаНапример:`=> vfs.file.size[/var/log/syslog]`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.file.time[файл,<режим>]` |
| Информация о времени файла. | Целое число (UNIX timestamp) | `–файл `– полный путь к файлу;`–режим `– возможные значения:`modify `(по умолчанию) – время последней модификации содержимого файла,`access `– время последнего чтения файла,`change `– время последнего изменения свойств файла. | Пример:`=> vfs.file.time[/etc/passwd,modify]`Ограничение размера файла зависит от поддержки больших файлов. |
| v`fs.fs.discovery` |
| Список примонтированных файловых систем и их типы. Используется низкоуровневым обнаружением. | Объект JSON |  |  |
| v`fs.fs.get` |
| Список примонтированных файловых систем, их типов, размеров дисков и статистики по `inode.` Можно использовать низкоуровневым обнаружением. | Объект JSON |  | Этот элемент данных может сообщать о файловых системах с нулевым количеством файловых дескрипторов (inode), что может случаться на файловых системах с динамическим количеством файловых дескрипторов (например, `btrfs)`. |
| v`fs.fs.inode[fs,<режим>]` |
| Количество или процент inodes. | Целое число – для количестваЧисло с плавающей точной – для процентов | `–fs `– файловая система;`–режим `– возможные значения:`total `(по умолчанию), `free,` `used,` `pfree `(свободно, в процентах), `pused `(использовано, в процентах). | Этот элемент данных не будет переходить в неподдерживаемое состояние в режимах `pfree/pused,` если количество `inode `станет нулевым, что может случаться на файловых системах с динамическим количеством файловых дескрипторов (например, `btrfs)`. Вместо этого для таких файловых систем значения `pfree/pused `будут сообщаться как "`100"` и "`0"` соответственно.Пример:`=> vfs.fs.inode[/,pfree]` |
| v`fs.fs.size[fs,<режим>]` |
| Размер диска в байтах или процентах от общего размера. | Целое число – для байтовЧисло с плавающей точкой – для процентов. | `–fs `– файловая система;`–режим `– возможные значения:`total `(по умолчанию), `free,` `used,` `pfree `(доступно, в процентах), `pused `(использовано, в процентах). | Если файловая система не примонтирована, будет возвращен размер локальной файловой системы, где расположена точка монтирования.Пример:`=> vfs.fs.size[/tmp,free]`Зарезервированное место на файловой системе принимается во внимание и не включено при использовании режима `free.` |

1. Ключ элемента данных виртуальной памяти

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| v`m.memory.size[<режим>]` |
| Размер памяти в байтах или в процентах от общего количества. | Целое число – для байтовЧисло с плавающей точкой – для процентов. | `–режим `– возможные значения:`total `(по умолчанию), `active,` `anon,` `buffers,` `cached,` `exec,` `file,` `free,` `inactive,` `pinned,` `shared,` `slab,` `wired,` `used,` `pused `(использовано, в процентах), `available,` `pavailable `(доступно, в процентах) | Этот элемент данных принимает три категории параметров:1) `total `– общее количество памяти.2) зависимые от платформы типы памяти: `active,` `anon,` `buffers,` `cached,` `exec,` `file,` `free,` `inactive,` `pinned,` `shared,` `slab,` `wired.`3) оценка на уровне пользователя как много памяти используется и доступно: `used,` `pused,` `available,` `pavailable.` |

1. Ключи элемента данные веб-мониторинга

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| w`eb.page.get[хост,<путь>,<порт>]` |
| Получение содержимого веб-страницы. | Исходная веб-страница в виде текста (включая заголовки) | `–хост `– имя хоста или URL (в виде `схема://хост:порт/путь,` где обязателен только `хост)`.Разрешенные схемы URL: `http,` `https4`. При отсутствии схемы будет обрабатываться как `http.` Если указан URL, то `путь `и `порт `должны быть пустыми. При подключении к Серверам, которые требуют аутентификацию, возможность указать имя пользователя / пароль, например: `http://user:password@www.example.com,` имеется только с поддержкой cURL 4.В именах хостов поддерживается ;`–путь `– путь к HTML документу (по умолчанию /);`–порт `– номер порта (по умолчанию 80 для HTTP) | Этот элемент данных становится неподдерживаемым, если заданный ресурс в `хост `не существует или недоступен.`хост `может быть именем хоста, доменным именем, адресом IPv4 или IPv6. Но для поддержки IPv6-адресов Агент должен быть скомпилирован с включенной поддержкой IPv6. |
| w`eb.page.perf[хост,<путь>,<порт>]` |
| Время полной загрузки веб-страницы (в секундах). | Число с плавающей точкой | `–хост `– имя хоста или URL (в виде `схема://хост:порт/путь,` где обязателен только `хост)`.Разрешенные схемы URL: `http,` `https4`. При отсутствии схемы будет обрабатываться как `http.` Если указан URL, то `путь `и `порт `должны быть пустыми. При подключении к Серверам, которые требуют аутентификацию, возможность указать имя пользователя / пароль, например: `http://user:password@www.example.com,` имеется только с поддержкой cURL 4.В именах хостов поддерживается ;`–путь `– путь к HTML документу (по умолчанию /);`–порт `– номер порта (по умолчанию 80 для HTTP). | Этот элемент данных становится неподдерживаемым, если заданный ресурс в `хост `не существует или недоступен.`хост `может быть именем хоста, доменным именем, адресом IPv4 или IPv6. Но для поддержки IPv6-адресов Агент должен быть скомпилирован с включенной поддержкой IPv6. |
| w`eb.page.regexp[хост,<путь>,<порт>,регулярное выражение,<длина>,<вывод>]` |
| Поиск строки на веб-странице. | Совпадающая строка, или указанная опциональным параметром `вывод` | `–хост `– имя хоста или URL (в виде `схема://хост:порт/путь,` где обязателен только `хост)`.Разрешенные схемы URL: `http,` `https4`. При отсутствии схемы будет обрабатываться как `http.` Если указан URL, то `путь `и `порт `должны быть пустыми. При подключении к Серверам, которые требуют аутентификацию, возможность указать имя пользователя / пароль, например: `http://user:password@www.example.com,` имеется только с поддержкой cURL 4.В именах хостов поддерживается ;`–путь `– путь к HTML документу (по умолчанию /);`–порт `– номер порта (по умолчанию 80 для HTTP);`–регулярное выражение `– регулярное выражение, описывающее требуемый шаблон;`–длина –` максимальное количество возвращаемых символов;`–вывод `– дополнительный шаблон форматирования вывода. `\0 `– управляющая последовательность заменяется найденной частью текста (начиная от первого символа совпадения, заканчивая символом, где совпадение заканчивается), при этом `\N `(где `N=1..9)` – управляющая последовательность заменяется N-ой совпадающей группой (или пустой строкой, если N превышает количество найденных групп). | Этот элемент данных становится неподдерживаемым, если заданный ресурс в `хост `не существует или недоступен.`хост `может быть именем хоста, доменным именем, адресом IPv4 или IPv6. Но для поддержки IPv6-адресов Агент должен быть скомпилирован с включенной поддержкой IPv6.Извлечение содержимого при использовании параметра вывод производится на стороне Агента. |

1. Специфичные ключи элементов данных для Агента-2

Агент-2 поддерживает все ключи элементов данных, которые поддерживаются Агентом в UNIX и Windows. В таблицах 59-69 представлена подробная информация о дополнительных ключах элементов данных, которые можно использовать только с Агентом-2; эти ключи сгруппированы по плагинам, которым они принадлежат.

Параметры без угловых скобок обязательны. Параметры, обозначенные угловыми скобками, "< >" опциональны.

1. Ключ `Ceph`

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| C`eph.df.details [строка_подкл, <пользователь>, <ключ_api>]` |
| Использование данных кластера и распределение между пулами. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.osd.stats [строка_подкл, <пользователь>, <ключ_api>]` |
| Агрегированная статистика и статистика по каждому OSD. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.osd.discovery [строка_подкл, <пользователь>, <ключ_api>]` |
| Список обнаруженных OSD. Используется низкоуровневым обнаружением. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.osd.dump [строка_подкл, <пользователь>, <ключ_api>]` |
| Пороги использования и состояния OSD. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.ping [строка_подкл, <пользователь>, <ключ_api>]` |
| Проверка, можно ли установить подключение к `Ceph.` | 0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками)1 – подключение успешно. | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.pool.discovery [строка_подкл, <пользователь>, <ключ_api>]` |
| Список обнаруженных пулов. Используется низкоуровневым обнаружением. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |
| C`eph.status [строка_подкл, <пользователь>, <ключ_api>]` |
| Общее состояние кластера. | Объект JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– Учетные данные для входа в `Ceph.` |  |

1. Ключи Docker

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| d`ocker.container_info [<ID>,<info>]` |
| Низкоуровневая информация о контейнере. | Вывод API вызова , преобразованный в JSON | `ID `– ID или имя контейнера`info `– объем возвращаемой информации. Возможные значения: `short `(по умолчанию) или `full.` | Agent2 пользователь (`zabbix)` должен быть добавлен в  "docker" для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.container_stats [<ID>]` |
| Статистика использования ресурсов контейнером. | Вывод API вызова  и использование CPU в процентах, преобразованные в JSON | `ID `– ID или имя контейнера | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.containers` |
| Список контейнеров. | Вывод API запроса , преобразованный в JSON | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.containers.discovery[<опции>]` |
| Список контейнеров. Используется низкоуровневым обнаружением. | Объект JSON | `опции `– задает, следует ли обнаруживать все или только запущенные контейнеры. Поддерживаемые значения:`true `– возвращать все контейнеры;`false `– возвращать только запущенные контейнеры (по умолчанию). | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.data_usage` |
| Информация о текущем использовании данных. | Вывод API запроса , преобразованный в JSON | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.images` |
| Список образов. | Вывод API запроса , преобразованный в JSON | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.images.discovery` |
| Список образов. Используется низкоуровневым обнаружением. | Объект JSON | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.info` |
| Информация о системе. | Вывод API вызова , преобразованный в JSON | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |
| d`ocker.ping` |
| Проверка, активен или нет Docker демон. | 1 – подключение установлено0 – подключение разорвано | - | Agent2 пользователь (`zabbix)` должен быть добавлен в "docker"- для достаточных привилегий. Иначе проверка завершится с ошибкой. |

1. Ключи Memcached

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| m`emcached.ping[строка_подкл,<пользователь>,<пароль>]` |
| Проверка можно ли установить подключение. | 1 – подключение активно0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками) | `строка_подкл `– URI или имя сессии. |  |
| m`emcached.stats[строка_подкл,<пользователь>,<пароль>,<тип>]` |
| Получение вывода команды STATS. | JSON – вывод, преобразованный в JSON | `строка_подкл `– URI или имя сессии.`пользователь, пароль `– учетные данные для входа в Memchached.`тип `– тип возвращаемой статистики: `items,` `sizes,` `slabs `или `settings `(по умолчанию пусто, возвращается общая статистика). |  |

1. Ключи MongoDB

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| m`ongodb.collection.stats[строка_подкл,<имя_пользователя>,<пароль>,<база_данных>,коллекция]` |
| Получение различной статистики хранилища по заданной коллекции. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB.`база_данных `– имя базы данных (по умолчанию: admin).`коллекции `— имя коллекции. |  |
| m`ongodb.collections.discovery[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение списка обнаруженных коллекций. Используется низкоуровневым обнаружением. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.collections.usage[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение статистики использования по коллекциям. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.connpool.stats[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение информации касательно открытых исходящих подключений с текущего экземпляра базы данных к другим членам кластера сегментов или набора реплик. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.db.stats[строка_подкл,<имя_пользователя>,<пароль>,<база_данных>]` |
| Получение статистики, отражающей состояние системы заданной базы. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB.`база_данных `– имя базы (по умолчанию: admin). |  |
| m`ongodb.db.discovery[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение списка обнаруженных баз данных. Используется низкоуровневым обнаружением. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.jumbo_chunks.count[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение количества `jumbo chunk.` | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.oplog.stats[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение состояния набора реплик, используя данные, полученные от `oplog.` | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.ping[строка_подкл,<имя_пользователя>,<пароль>]` |
| Проверка, можно ли установить подключение. | 1 – подключение успешно0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками). | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.rs.config[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение текущей конфигурации набора реплик. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.rs.status[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение состояния набора реплик с точки видимости члена, откуда вызывается метод. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.server.status[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение состояния базы данных. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.sh.discovery[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение списка обнаруженных сегментов, находящихся в кластере. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |
| m`ongodb.version[строка_подкл,<имя_пользователя>,<пароль>]` |
| Получение версии сервера базы данных. | `String` | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные к MongoDB. |  |

1. Ключи MQTT

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| m`qtt.get[<url_ брокера>,тема,<имя_пользователя>,<пароль>]` |
| Подписка на заданную тему или темы (с шаблонами), которые предоставляются брокером, и ожидание публикаций. | Зависит от содержимого темы.Если использовался шаблон, возвращает содержимое темы в виде JSON. | `url_брокера `– URL брокера MQTT (если пустой, используется `localhost `с портом 1883).`тема `– тема MQTT (обязательно). Поддерживаются шаблоны (+,#).`имя_пользователя, пароль `– учетные данные для аутентификации (если требуется) | Элемент данных необходимо настроить активной проверкой (тип элемента данных "`Агент (активный)"`).Можно использовать сертификаты TLS-шифрования, сохранив их в место по умолчанию (например, в Ubuntu директория `/etc/ssl/certs/)`. Для TLS использовать схему `tls://.` |

1. Ключ MySQL

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| m`ysql.custom.query[строка_подкл,<имя_пользователя>,<пароль>,имяЗапроса,<аргументы...>]` |
| Возвращает результат пользовательского запроса. | Объект JSON | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL.`имяЗапроса `– имя пользовательского запроса, должно совпадать с именем SQL-файла без расширения.`аргументы `– один или несколько перечисленных через запятую аргументов, которые будут переданы запросу. |  |
| m`ysql.db.discovery[строка_подкл, <имя_пользователя>, <пароль>]` |
| Список баз данных MySQL. Используется низкоуровневым обнаружением. | Результат SQL запроса "`show databases"` в формате LLD JSON. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL. |  |
| m`ysql.db.size[строка_подкл, <имя_пользователя>, <пароль>,имя_базы]` |
| Размер базы данных в байтах. | Результат SQL запроса "`select coalesce(sum(data_length + index_length),0) as size from information_schema.tables where table_schema=?"` для указанной базы данных в байтах. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL.`имя_базы `– имя базы данных. |  |
| m`ysql.get_status_variables[строка_подкл, <имя_пользователя>, <пароль>]` |
| Значения переменных глобального состояния. | Результат SQL запроса "`show global status"` в формате JSON. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL. |  |
| m`ysql.ping[строка_подкл, <имя_пользователя>, <пароль>]` |
| Проверка, можно ли установить подключение. | 1 – подключение успешно0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками). | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL. |  |
| m`ysql.replication.discovery[строка_подкл, <имя_пользователя>, <пароль>]` |
| Список репликаций MySQL. Используется низкоуровневым обнаружением. | Результат SQL запроса "`show slave status"` в формате LLD JSON. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL. |  |
| mysql.replication.get_slave_status[`строка_подкл,` <имя_пользователя>, <пароль>, <хост_мастера>] |
| Состояние репликации. | Результат SQL запроса "`show slave status"` в формате JSON. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL.`хост_мастера `– Имя хоста мастера репликации. Если не найдено, возвращается ошибка. Если данный параметр не указан, возвращаются все хосты. |  |
| m`ysql.version[строка_подкл, <имя_пользователя>, <пароль>]` |
| Версия MySQL. | Строка с версией MySQL экземпляра. | `строка_подкл `– URI или имя сессии.`имя_пользователя, пароль `– учетные данные для входа в MySQL. |  |

1. Ключи PostgreSQL

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| p`gsql.autovacuum.count[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Количество `autovacuum worker.` | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| pgsql.archive[uri,<имя_пользователя>,<пароль>, <`имя_бд>`] |
| Информация об архивных файлах. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.archive.count_archived_files – количество успешно заархивированных WAL-файлов.pgsql.archive.failed_trying_to_archive – количество неудачных попыток архивирования WAL-файлов.pgsql.archive.count_files_to_archive – количество файлов для архивирования.pgsql.archive.size_files_to_archive – размер файлов для архивирования. |
| p`gsql.bgwriter[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Общее количество контрольных точек (checkpoint) по кластеру базы данных, с разбивкой по типу контрольной точки. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.bgwriter.buffers_alloc – количество выделенных буферов.pgsql.bgwriter.buffers_backend – количество буферов, записанных самим серверным процессом.pgsql.bgwriter.maxwritten_clean – сколько раз фоновый процесс записи останавливал сброс грязных страниц на диск из-за того, что записал слишком много буферов.pgsql.bgwriter.buffers_backend_fsync – сколько раз серверному процессу пришлось выполнить fsync самостоятельно, вместо фонового процесса.pgsql.bgwriter.buffers_clean – количество буферов, записанных фоновым процессом записи.pgsql.bgwriter.buffers_checkpoint – количество буферов, записанных при выполнении контрольных точек.pgsql.bgwriter.checkpoints_timed – количество запланированных контрольных точек, которые уже были выполнены.pgsql.bgwriter.checkpoints_req – количество запрошенных контрольных точек, которые уже были выполнены.pgsql.bgwriter.checkpoint_write_time – общее время, которое было затрачено на этап обработки контрольной точки, в котором файлы записываются на диск, в миллисекундах.pgsql.bgwriter.sync_time – общее время, которое было затрачено на этап обработки контрольной точки, в котором файлы синхронизируются с диском, в миллисекундах. |
| p`gsql.cache.hit[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Коэффициент успешности кэша буфера PostgreSQL. | Число с плавающей точкой | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.connections[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Подключения по типу. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.connections.active – серверный процесс выполняет запрос.pgsql.connections.fastpath_function_call – серверный процесс выполняет fast-path функцию.pgsql.connections.idle – серверный процесс ожидает новой команды от клиента.pgsql.connections.idle_in_transaction – серверный процесс находится внутри транзакции, но в настоящее время не выполняет никакой запрос.pgsql.connections.prepared – общее количество prepared подключений.pgsql.connections.total – общее количество подключений.pgsql.connections.total_pct – процентное отношение общего количества подключений к "max_connections" настройке сервера PostgreSQL.pgsql.connections.waiting – количество подключений в состоянии в запросе.pgsql.connections.idle_in_transaction_aborted – это состояние подобно idle in transaction, за исключением того, что один из операторов в транзакции вызывал ошибку. |
| p`gsql.custom.query[uri,<имя_пользователя>,<пароль>,имя_запроса,<аргументы...>]` |
| Получение результата пользовательского запроса. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_запроса `– имя пользовательского запроса, должно совпадать с именем sql- файла без расширения.`аргументы `– один или несколько аргументов (через запятую), которые будут переданы запросу. |  |
| p`gsql.dbstat[uri,<имя_пользователя>,<пароль>, имя_бд]` |
| Сбор статистики по каждой базе данных. Используется низкоуровневым обнаружением. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:`pgsql.dbstat.numbackends["{#DBNAME}"] –` количество обслуживающих процессов, в настоящее время подключенных к этой базе данных, либо `NULL `для общих объектов.`pgsql.dbstat.sum.blk_read_time["{#DBNAME}"] `– время, которое затратили обслуживающие процессы в этой базе на чтение блоков из файлов данных, в миллисекундах.`pgsql.dbstat.sum.blk_write_time["{#DBNAME}"] –` время, которое затратили обслуживающие процессы в этой базе на запись блоков в файлы данных, в миллисекундах.`pgsql.dbstat.sum.checksum_failures["{#DBNAME}"] `– количество ошибок контрольных сумм в страницах данных этой базы (или общего объекта) либо `NULL,` если контрольные суммы не проверяются.(только PostgreSQL версии 12)`pgsql.dbstat.blks_read.rate["{#DBNAME}"] –` количество прочитанных дисковых блоков в этой базе данных.`pgsql.dbstat.deadlocks.rate["{#DBNAME}"] `– количество взаимных блокировок, зафиксированное в этой базе данных.`pgsql.dbstat.blks_hit.rate["{#DBNAME}"] `– сколько раз дисковые блоки обнаруживались в буферном кэше, так что чтение с диска не потребовалось (в значение входят только случаи обнаружения в буферном кэше PostgreSQL Pro, а не в кэше файловой системы ОС).`pgsql.dbstat.xact_rollback.rate["{#DBNAME}"] `– количество транзакций в этой базе данных, для которых был выполнен откат транзакции.`pgsql.dbstat.xact_commit.rate["{#DBNAME}"] `– количество зафиксированных транзакций в этой базе данных.`pgsql.dbstat.tup_updated.rate["{#DBNAME}"] –` количество строк, измененных запросами в этой базе данных.`pgsql.dbstat.tup_returned.rate["{#DBNAME}"] `– количество строк, возвращенных запросами в этой базе данных.`pgsql.dbstat.tup_inserted.rate["{#DBNAME}"] `– количество строк, вставленных запросами в этой базе данных.`pgsql.dbstat.tup_fetched.rate["{#DBNAME}"] `– количество строк, извлеченных запросами в этой базе данных.`pgsql.dbstat.tup_deleted.rate["{#DBNAME}"] `– количество строк, удаленных запросами в этой базе данных.`pgsql.dbstat.conflicts.rate["{#DBNAME}"] `– количество запросов, отмененных из-за конфликта с восстановлением в этой базе данных (конфликты происходят только на ведомых серверах).`pgsql.dbstat.temp_files.rate["{#DBNAME}"] –` количество временных файлов, созданных запросами в этой базе данных. Подсчитываются все временные файлы независимо от причины их создания (например, для сортировки или для хеширования) и независимо от установленного значения `log_temp"_files.pgsql.dbstat.temp_Bytes.rate["{#DBNAME}"] `– общий объем данных, записанных во временные файлы запросами в этой базе данных. Учитываются все временные файлы, вне зависимости от того, по какой причине они созданы и вне зависимости от значения `log_temp_files.` |
| p`gsql.dbstat.sum[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Обобщенные данные по всем базам данных в кластере. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.dbstat.numbackends – количество обслуживающих процессов, в настоящее время подключенных к этой базе данных.pgsql.dbstat.sum.blk_read_time – время, которое затратили обслуживающие процессы в этой базе на чтение блоков из файлов данных, в миллисекундах.pgsql.dbstat.sum.blk_write_time – время, которое затратили обслуживающие процессы в этой базе на запись блоков в файлы данных, в миллисекундах.pgsql.dbstat.sum.checksum_failures – количество ошибок контрольных сумм в страницах данных этой базы (или общего объекта) либо `NULL,` если контрольные суммы не проверяются (только PostgreSQL версия 12).pgsql.dbstat.sum.xact_commit – количество зафиксированных транзакций в этой базе данных.pgsql.dbstat.sum.conflicts – количество запросов, отмененных из-за конфликта с восстановлением на ведомых серверах в этой базе данных.pgsql.dbstat.sum.deadlocks – количество взаимных блокировок, зафиксированное в этой базе данных.pgsql.dbstat.sum.blks_read – количество прочитанных дисковых блоков в этой базе данных.pgsql.dbstat.sum.blks_hit – сколько раз дисковые блоки обнаруживались в буферном кэше, так что чтение с диска не потребовалось (в значение входят только случаи обнаружения в буферном кэше PostgreSQL Pro, а не в кэше файловой системы ОС).pgsql.dbstat.sum.temp_Bytes – общий объем данных, записанных во временные файлы запросами в этой базе данных. Учитываются все временные файлы, вне зависимости от того, по какой причине они созданы и вне зависимости от значения log_temp_files.pgsql.dbstat.sum.temp_files – количество временных файлов, созданных запросами в этой базе данных. Подсчитываются все временные файлы независимо от причины их создания (например, для сортировки или для хеширования) и независимо от установленного значения log_temp_files.pgsql.dbstat.sum.xact_rollback – количество транзакций в этой базе данных, для которых был выполнен откат транзакции.pgsql.dbstat.sum.tup_deleted – количество строк, удаленных запросами в этой базе данных.pgsql.dbstat.sum.tup_fetched – количество строк, извлеченных запросами в этой базе данных.pgsql.dbstat.sum.tup_inserted – количество строк, вставленных запросами в этой базе данных.pgsql.dbstat.sum.tup_returned – количество строк, возвращенных запросами в этой базе данных.pgsql.dbstat.sum.tup_updated – количество строк, измененных запросами в этой базе данных. |
| p`gsql.db.age[uri,<имя_пользователя>,<пароль>, имя_бд]` |
| Возраст самого старого FrozenXID в базе данных. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.db.bloating_tables[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Количество "распухших" (bloating) таблиц по каждой базе данных. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.db.discovery[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Список баз данных PostgreSQL. Используется низкоуровневым обнаружением. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.db.size[uri,<имя_пользователя>,<пароль>, имя_бд]` |
| Размер базы данных в байтах. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.locks[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Информация о предоставленных блокировках по каждой базе данных. Используется низкоуровневым обнаружением. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.locks.shareupdateexclusive["`{#DBNAME}"`] – количество share update exclusive блокировок.pgsql.locks.accessexclusive["`{#DBNAME}"`] – количество access exclusive блокировок.pgsql.locks.accessshare["`{#DBNAME}"`] – количество access share блокировок.pgsql.locks.exclusive["`{#DBNAME}"`] – количество exclusive блокировок.pgsql.locks.rowexclusive["`{#DBNAME}"`] – количество row exclusive блокировок.pgsql.locks.rowshare["`{#DBNAME}"`] – количество row share блокировок.pgsql.locks.share["`{#DBNAME}"`] – количество shared блокировок.pgsql.locks.sharerowexclusive["`{#DBNAME}"`] – количество share row exclusive блокировок. |
| p`gsql.oldest.xid[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Возраст самого старого XID. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.ping[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Проверка, можно ли установить подключение. | 1 – подключение успешно0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками). | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.queries[uri,<имя_пользователя>,<пароль>, <имя_бд>,период_времени]` |
| Измерение времени выполнения запросов. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных.период_времени – ограничение времени выполнения для подсчета медленных запросов (должно быть целым положительным числом). | Полученные данные обрабатываются зависимыми элементами данных:pgsql.queries.mro.time_max["`{#DBNAME}"`] – максимальное время запросов обслуживания.pgsql.queries.query.time_max["`{#DBNAME}"`] – максимальное время выполнения запросов.pgsql.queries.tx.time_max["`{#DBNAME}"`] – максимальное время запросов транзакций.pgsql.queries.mro.slow_count["`{#DBNAME}"`] – количество медленных запросов обслуживания.pgsql.queries.query.slow_count["`{#DBNAME}"`] – количество медленных запросов.pgsql.queries.tx.slow_count["`{#DBNAME}"`] – количество медленных запросов транзакций.pgsql.queries.mro.time_sum["`{#DBNAME}"`] – суммарное время запросов обслуживания.pgsql.queries.query.time_sum["`{#DBNAME}"`] – суммарное время выполнения запросов.pgsql.queries.tx.time_sum["`{#DBNAME}"`] – суммарное время запросов транзакций. |
| p`gsql.replication.count[uri,<имя_пользователя>,<пароль>]` |
| Количество серверов в режиме ожидания. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication.process[uri,<имя_пользователя>,<пароль>]` |
| Отставание сброса, отставания записи и отставания replay по каждому процессу sender. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication.process.discovery[uri,<имя_пользователя>,<пароль>]` |
| Обнаружение имени процесса репликации. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication.recovery_role[uri,<имя_пользователя>,<пароль>]` |
| Состояние восстановления. | 0 – режим мастера1 – восстановление еще в процессе (режим ожидания) | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication.status[uri,<имя_пользователя>,<пароль>]` |
| Состояние репликации. | 0 – передача потока не работает1 – передача потока работает2 – режим мастера | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication_lag.b[uri,<имя_пользователя>,<пароль>]` |
| Отставание репликации в байтах. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.replication_lag.sec[uri,<имя_пользователя>,<пароль>]` |
| Отставание репликации в секундах. | Целое число | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL. |  |
| p`gsql.uptime[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Время работы PostgreSQL в миллисекундах. | Число с плавающей точкой | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.version[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Вернуть версию PostgreSQL. | Строка | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. |  |
| p`gsql.wal.stat[uri,<имя_пользователя>,<пароль>, <имя_бд>]` |
| Статистика WAL. | Объект JSON | `uri – `URI или имя сессии.`имя_пользователя, пароль `– учетные данные PostgreSQL.`имя_бд `– Имя базы данных. | Полученные данные обрабатываются зависимыми элементами данных:pgsql.wal.count — количество WAL файлов.pgsql.wal.write – использовано WAL lsn (в байтах). |

1. Ключи Redis

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| r`edis.config[строка_подкл,<пароль>,<шаблон>]` |
| Получение параметров конфигурации экземпляра Redis, которые соответствуют шаблону | JSON – если использовался шаблон в стиле globодно значение – если шаблон не содержит какого-либо символа подстановки | `строка_подкл `– URI или имя сессии.`пароль `– пароль к Redis.`шаблон `– шаблон в стиле glob (по умолчанию `*)`. |  |
| r`edis.info[строка_подкл,<пароль>,<раздел>]` |
| Получение вывода команды INFO. | JSON – вывод преобразован в JSON | `строка_подкл `– URI или имя сессии.`пароль `– пароль к Redis.`раздел `– раздел информации (по умолчанию `default)`. |  |
| r`edis.ping[строка_подкл,<пароль>]` |
| Проверка, можно ли установить подключение. | 1 – подключение успешно0 – подключение разорвано (если имеется какая-либо ошибка, включая проблемы с аутентификацией или проблемы с настройками) | `строка_подкл `– URI или имя сессии.`пароль `– пароль к Redis. |  |
| r`edis.slowlog.count[строка_подкл,<пароль>]` |
| Количество медленных записей в журнале с момента запуска Redis. | Целое число | `строка_подкл `– URI или имя сессии.`пароль `– пароль к Redis. |  |

1. Ключи S.M.A.R.T.

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| s`mart.attribute.discovery` |
| Получение списка S.M.A.R.T. параметров устройств. | Объект JSON |  | Возвращаются следующие макросы и их значения: `{#NAME},` `{#DISKTYPE},` `{#ID},` `{#ATTRNAME},` `{#THRESH}.`Поддерживаются типы дисков HDD, SSD и NVME. Диски могут быть одиночными или объединенными в RAID. `{#NAME} `будет иметь дополнение в случае RAID, например: `{"{#NAME}"`: "/dev/sda cciss,2"} |
| s`mart.disk.discovery` |
| Получение списка S.M.A.R.T. устройств. | Объект JSON |  | Возвращаются следующие макросы и их значения: `{#NAME},` `{#DISKTYPE},` `{#MODEL},` `{#SN},` `{#PATH},` `{#ATTRIBUTES},` `{#RAIDTYPE}.`Поддерживаются типы дисков HDD, SSD и NVME. Если диск не объединен в RAID, `{#RAIDTYPE} `будет пустым. `{#NAME} `будет иметь дополнение в случае RAID, например: `{"{#NAME}"`: "/dev/sda cciss,2"} |
| s`mart.disk.get[<путь>,<тип_raid>]` |
| Получение всех доступных свойств S.M.A.R.T. устройств. | Объект JSON | `путь `– путь к диску, макрос `{#PATH} `можно использовать значением`тип_raid `– тип RAID, макрос `{#RAID} `можно использовать значением. | Поддерживаются типы дисков HDD, SSD и NVME. Диски могут быть одиночными или объединенными в RAID.Данные включают версию `smartctl `и аргументы вызова, а также дополнительные поля:`disk_name `– содержит имя с требуемым дополнением для обнаружения RAID, например: `{"disk_name": "/dev/sda cciss,2"}disk_type `– содержит тип диска HDD, SSD или NVME, например: `{"disk_type": "ssd"})`Если параметры не указаны, элемент данных вернет информацию обо всех дисках. |

1. Ключи Systemd

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| s`ystemd.unit.get[имя модуля,<интерфейс>]` |
| Получение всех свойств модуля systemd. | Объект JSON | `имя модуля `– имя модуля (возможно потребуется использовать `{#UNIT.NAME} `макрос в прототипе элементов данных для обнаружения имени)`интерфейс `– тип интерфейса модуля, возможные значения: `Unit `(по умолчанию), `Service,` `Socket,` `Device,` `Mount,` `Automount,` `Swap,` `Target,` `Path` | Этот элемент данных поддерживается только на Linux-платформе.`LoadState, ActiveState и UnitFileState `для интерфейса модуля возвращаются в виде текста и целого числа:`"ActiveState":{"state":1,"text":"active"}` |
| s`ystemd.unit.info[имя модуля,<свойство>,<интерфейс>]` |
| Информация о systemd модуле. | Строка | `unit name `– имя модуля (возможно потребуется использовать `{#UNIT.NAME} `макрос в прототипе элементов данных для обнаружения имени)`свойство `– имя свойства (например, `ActiveState `(по умолчанию), `LoadState, Description)интерфейс `– тип интерфейса (например, `Unit `(по умолчанию), `Socket, Service)` | Этот элемент данных позволяет получать определенные свойства с заданного типа интерфейса, которые описаны в .Этот элемент данных поддерживается только на Linux-платформе. |
| s`ystemd.unit.discovery[<тип>]` |
| Список модулей systemd и их деталей. Используется низкоуровневым обнаружением. | Объект JSON | тип – возможные значения: `all,` `automount,` `device,` `mount,` `path,` `service `(по умолчанию), `socket,` `swap,` `target` | Этот элемент данных поддерживается только на Linux-платформе. |

1. Ключ веб-сертификата

| Описание | Возвращаемое значение | Параметры | Описание |
| --- | --- | --- | --- |
| w`eb.certificate.get[имя_хоста,<порт>,<адрес>]` |
| Проверка достоверности сертификатов и получение деталей сертификатов. | Объект JSON | `имя_хоста `– может быть как IP, так и DNS.Может содержать схему URL (только `https)`, путь (будет проигнорирован) и порт.Если порт указывается в первом и втором параметрах, значения портов должны совпадать.Если указан адрес ( 3-ий параметр), имя хоста используется только для удостоверения SNI и имени хоста.`порт `– номер порта (по умолчанию 443 для HTTPS).`адрес `– может быть как IP, так и DNS. Если указан, будет использоваться для подключения и имя хоста (1-ый параметр) будет использоваться для удостоверения SNI и хоста.В случае, если 1-ый параметр IP-адрес и третий параметр DNS, то 1-ый параметр будет использоваться для подключения и третий параметр будет использоваться для удостоверения SNI и хоста. | Этот элемент данных становится неподдерживаемым, если ресурс, указанный в `имя_хоста `не существует или, если TLS-квитирование завершится с любой ошибкой, за исключением ошибочного сертификата.В настоящее время расширение AIA (Authority Information Access) X.509, CRL и OCSP (включая OCSP сшивание), Certificate Transparency и пользовательские хранилища CA не поддерживаются. |

1. Специфичные ключи элементов данных для Windows

В таблице 70 приводится подробная информация о ключах элементов данных, которые можно использовать только с Windows-Агентом.

1. Ключи элементов данных для Windows

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| e`ventlog[имя,<регулярное выражение>,<важность>,<источник>,<eventid>,<макс. кол-во строк>,<режим>]` |
| Мониторинг журналов событий. | Журнал (лог) | `имя `– имя журнала событий.`регулярное выражение `– регулярное выражение, описывающее требуемый шаблон содержимого.`важность –` регулярное выражение, описывающее важность (без учета регистра)Параметр принимает регулярное выражение на основе следующих значений: `Information, Warning, Error, Critical, Verbose)`.`источник `– регулярное выражение, описывающее идентификатор источника.`eventid `– регулярное выражение, описывающее идентификатор(ы) событий.`макс. кол-во строк `– максимальное количество новых строк в секунду, которое Агент будет отправлять Серверу или Прокси. Этот параметр переопределяет значение "`MaxLinesPerSecond"` в `zabbix_agentd.win.conf.режим `– возможные значения:`all `(по умолчанию), `skip `– пропустить обработку старых данных (влияет только на недавно созданные элементы данных). | Элемент данных должен быть настроен активной проверкой.Обратить внимание: Агент не может отправлять события из журнала "`Пересланные события"`.Обратить внимание, что выбор не журнального типа информации для этого элемента данных приведет к потере локального штампа времени, а также важности журнала и информации об источнике. |
| n`et.if.list` |
| Список сетевых интерфейсов (включая тип, состояние, IPv4-адрес, описание интерфейса). | Текст |  | Обратить внимание, что включение/отключение некоторых компонентов Windows могут изменить порядок имен интерфейсов в Windows.В некоторых версиях Windows (к примеру, Server 2008) может потребоваться установка последних обновлений для поддержки не-ASCII символов в именах интерфейсов. |
| p`erf_counter[счетчик,<период>]` |
| Значение любого счетчика производительности Windows. | Целое число, число с плавающей точкой, строка или текст (в зависимости от запроса) | `счетчик `– путь к счетчику`период `– последние N секунд для сохранения усредненного значения.Значение `период `должно быть от 1 до 900 секунд (включительно), значение по умолчанию 1. | Можно использовать Мониторинг производительности для получения списка счетчиков. |
| p`erf_counter_en[счетчик,<период>]` |
| Значение любого счетчика производительности Windows на английском языке. | Целое число, число с плавающей точкой, строка или текст (в зависимости от запроса) | `счетчик `– путь к счетчику на английском языке`период `– последние N секунд для сохранения усредненного значения.Значение `период `должно быть от 1 до 900 секунд (включительно), значение по умолчанию 1. | Этот элемент данных поддерживается только на Windows Server 2008/Vista и более новых версиях.Можно найти список строк на английском языке, заглянув в следующую ветку реестра: `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\009.` |
| p`erf_instance.discovery[объект]` |
| Список экземпляров объекта счетчиков производительности Windows. Используется для низкоуровневого обнаружения. | Объект JSON | `объект `– имя объекта (локализованное) |  |
| p`erf_instance_en.discovery[объект]` |
| Список экземпляров объекта счетчиков производительности Windows, обнаруженных с использованием имен объектов на английском языке. Используется для низкоуровневого обнаружения. | Объект JSON | `объект `– имя объекта (на английском языке) |  |
| p`roc_info[процесс,<параметр>,<тип>]` |
| Различная информация об указанном процессе(-ах). | Число с плавающей точкой | `процесс `– имя процесса`параметр `– запрашиваемый параметр процесса.`тип `– тип представления (имеет смысл, когда есть более одного процесса с одинаковым именем) | Поддерживаются следующие `параметры:vmsize `(по умолчанию) – размер виртуальной памяти процесса в Кбайтах`wkset `– размер working set процесса (количество используемой процессом физической памяти) в Кбайтах`pf `– количество ошибок на страницах`ktime `– время ядра процесса в миллисекундах`utime `– пользовательское время процесса в миллисекундах`io_read_b `– количество байт, прочитанных процессом во время операций ввода/вывода`io_read_op `– количество операций чтения, выполненных процессом`io_write_b `– количество байт, записанных процессом во время операций ввода/вывода`io_write_op `– количество операций записи, выполненных процессом`io_other_b `– количество байт, пересланных процессом во время операций, отличных от чтения и записи`io_other_op `– количество выполненных процессом операций ввода/вывода, отличных от операций чтения и записи`gdiobj `– количество используемых процессом объектов GDI`userobj `– количество используемых процессом объектов USERДопустимые `типы:avg `(по умолчанию) – среднее значение среди всех процессов с именем <процесс>`min `– минимальное значение среди всех процессов с именем <процесс>`max `– максимальное значение среди всех процессов с именем <процесс>`sum `– сумма значений для всех процессов с именем <процесс>Обратить внимание, что для корректной работы этого элемента данных на 64-битной системе потребуется 64-битный Агент.Обратить внимание: Все параметры `io_*,` `gdiobj и` `userobj д`оступны только в Windows 2000 и более поздних версиях Windows, не в Windows NT 4.0. |
| s`ervice.discovery` |
| Список служб Windows. Используется низкоуровневым обнаружением. | Объект JSON |  |  |
| s`ervice.info[служба,<парам>]` |
| Информация о службе. | Целое число – с `парам `равным `state,` `Startup`Строка – с `парам `равным `displayname,` `path,` `user`Текст – с `парам `равным `description`В частности при `state:`0 – запущена,1 – пауза,2 – ожидание старта,3 – ожидание паузы,4 – ожидание продолжения,5 – ожидание остановки,6 – остановлена,7 – неизвестно,255 – такой службы не существуетВ частности при `Startup:`0 – автоматически,1 – автоматически (отложенный запуск),2 – вручную,3 – отключена,4 – неизвестно,5 – автоматический запуск по триггеру,6 – автоматический отложенный запуск по триггеру,7 – ручной запуск по триггеру | `служба `– действительное имя службы или ее отображаемое имя как в оснастке MMC Службы`парам `– `state `(по умолчанию), `displayname,` `path,` `user,` `Startup `или `description` | Примеры:`=> service.info[SNMPTRAP] `– состояние службы SNMPTRAP`=> service.info[SNMP Trap] `– состояние этой же службы, но указано отображаемое имя`=> service.info[EventLog,Startup] `– состояние запуска при загрузке службы Журнала событийЭлементы данных `service.info[служба,state] `и `service.info[служба] в`ернут одинаковую информацию.Обратить внимание, что только `парам `равный `state `у этого элемента данных возвращает значение по несуществующим службам (255). |
| s`ervices[<тип>,<состояние>,<исключения>]` |
| Список служб. | 0 – если список служб пуст.Текст – список служб, разделенных новой строкой. | `тип `– `all `(по умолчанию), `automatic,` `manual,` `disabledсостояние `– `all `(по умолчанию), `stopped,` `Started,` `Start_pending,` `stop_pending,` `running,` `continue_pending,` `pause_pending `или `pausedисключения `– список служб, исключаемых из результата.Исключаемые службы должны быть указаны в двойных кавычках, разделены запятой, без пробелов. | Примеры:`=> services[,Started] `– список запущенных служб`=> services[automatic, stopped] `– список остановленных служб, которые должны быть запущены`=> services[automatic, stopped, "service1,service2,service3"] `– список остановленных служб, которые должны быть запущены, за исключением служб с именами service1,service2 и service3 |
| w`mi.get[<пространство_имен>,<запрос>]` |
| Выполнение WMI запроса и получение первого выбранного объекта. | Целое число, число с плавающей точкой, строка или текст (в зависимости от запроса.) | `пространство_имен `– название пространства имен WMI`запрос `– WMI запрос, возвращающий один объект | WMI запросы выполняются с использованием  [en].Пример:`=> wmi.get[root\cimv2,select status from Win32_DiskDrive where Name like "%PHYSICALDRIVE0%"] –` получение состояния первого физического диска |
| w`mi.getall[<пространство_имен>,<запрос>]` |
| Выполнение WMI запроса и получение полного ответа.Можно использовать для низкоуровневого обнаружения. | Объект JSON | `пространство_имен `– название пространства имен WMI`запрос `– WMI-запрос | Запросы WMI выполняются при помощи  [en].Пример:`=> wmi.getall[root\cimv2,select * from Win32_DiskDrive where Name like "%PHYSICALDRIVE%"] `– получение информации о состоянии физических дисковМожно использовать JSONPath предобработку при обращении к более конкретным значениям в полученном JSON. |
| v`m.vmemory.size[<тип>]` |
| Размер виртуального пространства в байтах или в процентах от общего размера. | Целое число – для байтовЧисло с плавающей точкой – для процентов | `тип `– возможные значения:`available `(доступно виртуальной памяти), `pavailable `(доступно виртуальной памяти, в процентах), `pused `(использовано виртуальной памяти, в процентах), `total `(всего виртуальной памяти, по умолчанию), `used `(использовано виртуальной памяти) | Пример:`=> vm.vmemory.size[pavailable]–` доступно виртуальной памяти, в процентахМониторинг статистики виртуальной памяти основывается на:* Общее количество виртуальной памяти в Windows (всего физической + размер файла подкачки);* Максимального количества памяти, которое может занять Агент;* Текущий лимит выделенной памяти системе или Агенту, смотря что меньше. |

Мониторинг служб Windows

Пошаговые инструкции по настройке мониторинга служб Windows. Предполагается, что Сервер и Агент уже настроены и работают.

Шаг 1. Узнать имя службы.

Можно получить имя, перейдя в оснастку MMC-службы и открыв свойства службы. На вкладке Общие в значении поля, называемого "Имя службы", будет имя, которое используется при настройке элемента данных для наблюдения.

Например, если требуется наблюдать службу workstation, то служба, вероятно, будет называться lanmanworkstation.

Шаг 2. Настроить элемент данных для наблюдения за службой.

Элемент данных service.info[служба,<парам>] возвращает информацию о конкретной службе. В зависимости от требуемой информации, нужно указать опцию парам, которая принимает следующие значения: displayname, state, path, user, Startup или description. Значением по умолчанию является state, если парам не указан (service.info[служба]).

Тип возвращаемого значения зависит от выбранного парам: целое число при state и Startup; строка символов при displayname, path и user; текст при description.

Пример:

- Ключ service.info[lanmanworkstation];
- Тип информации Числовой (целое положительное).

Элемент данных service.info[lanmanworkstation] будет извлекать информацию о состоянии службы как числовое значение. Чтобы преобразовать числовое значение в текстовое представление в веб-интерфейсе ("0" как "Running", "1" как "Paused" и т.д.), можно настроить преобразование значений на узле сети, на котором сконфигурирован элемент данных. Чтобы это сделать, нужно либо присоединить шаблон "Windows services by Zabbix agent" или "Windows services by Zabbix agent active" к узлу сети, либо настроить на узле сети новое преобразование значений, основанное на преобразованиях значений "Windows service state", уже настроенных в упомянутых шаблонах.

Следует обратить внимание, что оба упомянутых шаблона имеют правило обнаружения, настроенное для автоматического обнаружения служб. Если не требуется этого, можно деактивировать правило обнаружения на уровне узла сети после присоединения к нему шаблона.

Низкоуровневое обнаружение дает возможность автоматического создания элементов данных, триггеров и графиков по различных объектам на компьютере. Подсистема может автоматически начать наблюдение за службами Windows на узле без необходимости знания точного имени службы или создания элементов данных по каждой службе вручную. Можно использовать фильтр для генерирования реальных элементов данных, триггеров и графиков только по интересующим службам.

# Г.11 Настройки недостижимости/недоступности интерфейса узла сети

SNMP используется для мониторинга таких устройств, как: принтеры, сетевые коммутаторы, маршрутизаторы или ИБП, которые, как правило, поддерживают SNMP и на которых было бы непрактично пытаться устанавливать полноценные ОС и Агенты.

Чтобы была возможность получать данные, переданные SNMP-агентами с этих устройств, Сервер должен быть изначально сконфигурирован с поддержкой SNMP.

SNMP-проверки выполняются только через UDP-протокол.

Серверы и Прокси опрашивают устройства SNMP по несколько значений за один запрос. Такое поведение влияет на все виды элементов данных SNMP (обычные элементы данных SNMP, элементы данных с динамическими индексами, а также низкоуровневые SNMP обнаружения), и делает работу SNMP более эффективной. Также массовые запросы можно отключить у устройств, которые не способны обработать их должным образом, используя настройку "Использовать массовые запросы", доступную в каждом интерфейсе.

Процессы Сервера и Прокси запишут в журнал строки наподобие следующих в случае получения неправильного/искаженного SNMP-ответа:

```bash Terminal
SNMP response from host "gateway" does not contain all of the requested variable bindings
```

Пока они не покрывают все возможные проблемные случаи, но они полезны для идентификации отдельных SNMP-устройств, на которых массовую обработку нужно отключить.

Сервер/Прокси всегда повторят запрос минимум один раз после неуспешной попытки: либо через механизм библиотеки SNMP, либо через внутренний механизм сбора множества значений за один запрос (bulk).

При мониторинге устройств по SNMPv3 следует убедиться, что msgAuthoritativeEngineID (также известное как snmpEngineID или "Engine ID") никогда не будет общим для двух и более устройств. Согласно RFC 2571 оно должно быть уникальным для каждого устройства.

RFC3414 требует, чтобы SNMPv3-устройства сохраняли свои значения engineBoots. Некоторые устройства не выполняют этого требования, что приводит к тому, что после перезагрузки их SNMP-сообщения отбрасываются как устаревшие. В этой ситуации необходимо вручную очистить кэш SNMP на Сервере/Прокси (используя "-R snmp_cache_reload") или же перезапустить Сервер/Прокси.

Для настройки мониторинга устройства по SNMP нужно выполнить следующие шаги:

1. Шаг 1. Узнать строку SNMP (или OID) элемента данных, который требуется мониторить.

Для получения списка строк SNMP использовать команду snmpwalk или эквивалентную утилиту:

```bash Terminal
snmpwalk -v 2c -c public <IP хоста>
```

где "2c" означает версию SNMP (можно заменить его на "1", чтобы использовать на устройстве SNMPv1).

Эта команда должна показать список SNMP-строк и их последние значения. Если это не произойдет, то возможно, что SNMP-"community" отличается от стандартного "public". В этом случае необходимо узнать это имя.

Для поиска конкретной строки, которую нужно мониторить, используют список; например, если требуется мониторить количество входящих байтов на третьем порту коммутатора, можно использовать IF-MIB::ifInOctets.3 из этой строки:

```yaml
IF-MIB::ifInOctets.3 = Counter32: 3409739121
```

Также можно воспользоваться командой snmpget, чтобы определить цифровой OID для IF-MIB::ifInOctets.3:

```bash Terminal
snmpget -v 2c -c public -On 10.62.1.22 IF-MIB::ifInOctets.3
```

Следует обратить внимание, что последнее число в строке – это номер порта, который ищется для мониторинга.

Вывод команды покажет примерно следующее:

```bash Terminal
.1.3.6.1.2.1.2.2.1.10.3 = Counter32: 3472126941
```

Последнее число в OID является номером порта.

Некоторые из наиболее часто используемых SNMP OID автоматически конвертируются Подсистемой в числовое представление.

В последнем примере тип значения Counter32 (32-битный счетчик) внутренне соответствует типу ASN_COUNTER. Полный список поддерживаемых типов: ASN_COUNTER, ASN_COUNTER64, ASN_UINTEGER, ASN_UNSIGNED64, ASN_INTEGER, ASN_INTEGER64, ASN_FLOAT, ASN_DOUBLE, ASN_TIMETICKS, ASN_GAUGE, ASN_IPADDRESS, ASN_OCTET_STR и ASN_OBJECT_ID. Приведенные типы грубо соответствуют "Counter32", "Counter64", "UInteger32", "INTEGER", "Float", "Double", "Timeticks", "Gauge32", "IpAddress", "OCTET STRING", "OBJECT IDENTIFIER" в выводе утилиты snmpget, но могут также отображаться как "STRING", "Hex-STRING", "OID" и другими в зависимости от наличия подсказки.

1. Шаг 2. Создать узел сети, соответствующий устройству.

Добавить к узлу сети SNMP-интерфейс:

1. ввести IP-адрес/DNS-имя и номер порта;
2. выбрать "`Версия SNMP"` из выпадающего списка;
3. добавить учетные данные к интерфейсу в зависимости от выбранной версии SNMP:
- SNMPv1, v2 требуют только community (обычно "public");
- SNMPv3 требует более специфичные опции (таблица 71);
  1. оставить выбранным "Использовать массовые запросы", чтобы разрешить массовую обработку SNMP-запросов.
  1. Параметр SNMPv3

| Параметр SNMPv3 | Описание |
| --- | --- |
| Имя контекста | Ввести контекстное имя для определения элемента данных в SNMP подсети.В данном поле раскрываются пользовательские макросы. |
| Имя безопасности | Ввести имя безопасности.В данном поле раскрываются пользовательские макросы. |
| Уровень безопасности | Выбрать уровень безопасности:`noAuthNoPriv `– ни аутентификация, ни протокол безопасности не используются;`AuthNoPriv `– используется протокол аутентификации, протокол безопасности – нет.`AuthPriv `– используются и протокол аутентификации, и протокол безопасности |
| Протокол аутентификации | Выбрать протокол аутентификации – `MD5,` `SHA1,` `SHA224,` `SHA256,` `SHA384 `или `SHA512.` |
| Пароль аутентификации | Ввести фразу-пароль для аутентификации.В данном поле раскрываются пользовательские макросы. |
| Протокол безопасности | Ввести протокол безопасности – `DES,` `AES128,` `AES192,` `AES256,` `AES192C `(Cisco) или `AES256C `(Cisco).Следует обратить внимание, что:- на некоторых более старых системах net-snmp может не поддерживать AES256.- на некоторых более новых системах (например, RHEL9) поддержка DES в пакете net-snmp может быть убрана. |
| Ключевая фраза безопасности | Ввести фразу-пароль безопасности.В данном поле раскрываются пользовательские макросы. |

В случае некорректных учетных данных SNMPv3 (имя безопасности, протокол/фраза-пароль аутентификации, протокол безопасности):

- Подсистема получит ERROR от net-snmp, за исключением ошибочного значения "`Ключевая фраза безопасности"`, в этом случае – ошибку превышения "ВРЕМЕНИ ОЖИДАНИЯ" от net-snmp;
- доступность интерфейса SNMP переключится на красный цвет (недоступно).

Изменения в "Протокол аутентификации", "Пароль аутентификации", "Протокол безопасности" или "Ключевая фраза безопасности" без изменения "Имя безопасности" вступят в силу только после ручной очистки кэша на Сервере/Прокси (используя "-R snmp_cache_reload") или при перезапуске Сервера/Прокси. В случае если "Имя безопасности" также меняется, все параметры будут обновлены немедленно.

Можно использовать один из поставляемых шаблонов SNMP ("Template SNMP Device" и другие), которые автоматически добавят набор элементов данных. Но шаблон может быть несовместим с узлом сети. Далее нажать на кнопку Добавить для сохранения узла сети.

1. Шаг 3. Создать элемент данных для мониторинга.

В меню Подсистемы нажать на Элементы данных у ранее созданного SNMP узла сети. В зависимости от того, использовался ли шаблон при создании узла сети или нет, можно увидеть или список элементов данных SNMP, связанных с узлом сети, или пустой список. Для самостоятельного создания элемента данных с помощью собранной информации, используя snmpwalk или snmpget, нажать на Создать элемент данных. В окне нового элемента данных (рисунок 3):

1. ввести имя элемента данных;
  1. изменить поле Тип на "SNMP Агент";
  2. ввести в поле Ключ, например: SNMP-InOctets-Bps;
  3. убедиться, что в поле "Интерфейс узла сети" указан нужный коммутатор/роутер;
  4. ввести в поле "SNMP OID" текстовый или числовой OID, который получен ранее, например: .1.3.6.1.2.1.2.2.1.10.3;
  5. установить "Тип информации" в значение равное "Числовой (с плавающей точкой)";
  6. ввести "Интервал обновления" и период "Хранения истории", если нужно, чтобы значения параметров отличались от значений по умолчанию;
  7. на вкладке Предобработка добавить шаг "Изменение в секунду"` (`это важно, так как иначе с SNMP-устройства будут получены накопленные значения вместо последнего изменения); выбрать пользовательский множитель при необходимости.

::sign-image
---
src: /image8.png
sign: Рисунок 32 – Окно ввода
---
::

1. Окно ввода

Теперь нужно сохранить элемент данных и перейти в "Мониторинг → Последние данные", чтобы увидеть данные SNMP.

## Г.11.1 Недостижимый интерфейс

Сервер и Прокси одним запросом опрашивают множество SNMP-элементов данных. Такое поведение затрагивает следующие типы SNMP-элементов данных:

- обычные SNMP-элементы данных;
- SNMP-элементы данных с динамическими индексами;
- правила низкоуровневого SNMP-обнаружения.

Все элементы данных SNMP с одного интерфейса планируются на опрос в одно время. Первые два типа элементов данных собираются поллерами порциями не более чем по 128 элементов данных, в то время как правила низкоуровневого обнаружения обрабатываются индивидуально, как и ранее.

На низком уровне есть два вида операций, выполняемых при опросе значений: получение нескольких заданных объектов и обход дерева OID.

Для "получения" используется GetRequest-PDU c не более чем 128 привязанных переменных. Для "обхода" используется GetNextRequest-PDU для SNMPv1 и GetBulkRequest с полем "max-repetitions" с наибольшим количеством в 128 полученных значений для SNMPv2 и SNMPv3.

Таким образом, преимущества массовой обработки для каждого типа SNMP элемента данных описаны ниже:

- обычные SNMP элементы данных получают преимущество от улучшенного получения;
- SNMP-элементы данных с динамическими индексами получают преимущество и от улучшенного "получения "и "обхода": "получение" используется для проверки индексов, а "обход" – для построения кэша значений;
- правила низкоуровневого SNMP обнаружения получают преимущество от улучшенного "обхода".

Тем не менее есть техническая проблема: не все устройства способны вернуть 128 значений за один запрос. Некоторые всегда возвращают корректный ответ, но другие либо отвечают с ошибкой "tooBig(1)", либо не отвечают вообще, если потенциальный запрос превышает определенный лимит.

Для вычисления оптимального количества объектов, запрашиваемых с данного устройства, Подсистема использует итерационную стратегию. Начинается с осторожного запроса одного значения. Если запрос выполнен успешно, запрашивается 2 значения за один запрос. Если запрос снова выполнен успешно, запрашивается 3 значения за запрос и продолжается аналогично путем умножения количества запрашиваемых значений на 1.5, в результате получается следующая последовательность размера запросов: 1, 2, 3, 4, 6, 9, 13, 19, 28, 42, 63, 94, 128.

Как только устройство отказывается давать корректный ответ (к примеру, на 42 переменных), Подсистема выполняет два действия.

Во-первых, для текущей серии элементов данных Подсистема делит пополам количество объектов на один запрос и запрашивает 21 переменную. Если устройство доступно, то запрос должен работать в большинстве случаев, потому что было известно, что с 28 переменными работало, а 21 значительно меньше. Если проблема продолжается, Подсистема возвращается к опросу значений по одному. Если проблемы есть и в этом случае, значит устройство определенно не отвечает и проблема не в размере запроса.

Во-вторых, для дальнейших порций элементов данных Подсистема начинает с последнего удачного количества переменных (28 в нашем случае) и продолжает, увеличивая количество переменных за запрос на 1 до достижения лимита. Например, если наибольший размер ответа – это 32 переменных, то последующие запросы будут размерами 29, 30, 31, 32 и 33. Последний запрос будет неудачным, и Подсистема никогда более не запросит 33 значения за один запрос. С этого момента Подсистема всегда будет опрашивать максимум по 32 переменных для этого устройства.

Если большие запросы неудачно завершаются с этим количеством переменных, это может означать одно из двух. Точный критерий, используемый устройством для ограничения размера ответа, неизвестен, но пытаются приблизительно оценить это, используя количество переменных. Поэтому первая возможность – в общем случае это количество переменных около реального ограничения размера ответа для данного устройства: иногда ответ меньше этого предела, иногда больше. Вторая возможность – что UDP-пакет (в любом направлении) просто был потерян. По этим причинам, если Подсистема сталкивается с неудачным запросом, то он уменьшает максимальное количество переменных, чтобы попытаться перейти в приемлемый для устройства диапазон, но только до 2 раз.

В примере выше, если запрос с 32 переменными будет неудачен, Подсистема уменьшит количество до 31. Если неудача случится снова, Подсистема уменьшит количество до 30. Тем не менее Подсистема не будет уменьшать количество ниже 30, потому что он предположит, что дальнейшие проблемы по причине потерянных UDP-пакетов, нежели из-за ограничения устройства.

Если устройство не умеет обрабатывать массовые запросы корректно и описанная выше эвристика не работает, то у каждого интерфейса имеется настройка "Использовать массовые запросы", позволяющая отключить массовые запросы у этого устройства.

## Г.11.2 Недоступный интерфейс

Не всегда требуемый номер индекса (например, сетевого интерфейса) из всех SNMP OID остается таким же.

Индексы могут быть динамическими – они могут изменяться время от времени и, как следствие, элемент данных может перестать работать.

Чтобы избежать этого, имеется возможность указать OID, который принимает во внимание возможность изменения номера индекса.

Например, если необходимо получить значение индекса, который относится к ifInOctets, которое соответствует интерфейсу GigabitEthernet0/1 на устройстве Cisco, используют следующий OID:

```bash Terminal
ifInOctets["index","ifDescr","GigabitEthernet0/1"]
```

Для OID используется специальный синтаксис (параметры – в таблице 72).

```bash Terminal
<OID данных>["index","<базовый OID индекса>","<искомая строка>"]
```

1. Синтаксис OID

| Параметр | Описание |
| --- | --- |
| O`ID данных` | `О`сновной OID, который используется для получения данных по элементу данных. |
| i`ndex` | `М`етод обработки. |
| б`азовый OID индекса` | `Э`тот OID будет просматриваться для получения значения индекса, соответствующего заданной строке. |
| и`скомая строка` | `С`трока, используемая для точного совпадения со значением при выполнении поиска, зависит от регистра. |

Например, для получения использования памяти процессом apache, если используется этот синтаксис OID:

```yaml
HOST-RESOURCES-MIB::hrSWRunPerfMem["index","HOST-RESOURCES-MIB::hrSWRunPath", "/usr/sbin/apache2"]
```

номер индекса будет искаться здесь:

```bash Terminal
...
HOST-RESOURCES-MIB::hrSWRunPath.5376 = STRING: "/sbin/getty"
HOST-RESOURCES-MIB::hrSWRunPath.5377 = STRING: "/sbin/getty"
HOST-RESOURCES-MIB::hrSWRunPath.5388 = STRING: "/usr/sbin/apache2"
HOST-RESOURCES-MIB::hrSWRunPath.5389 = STRING: "/sbin/sshd"
...
```

Теперь при наличии индекса, равного 5388, он будет присоединен к OID данных, чтобы получить требуемое значение:

```yaml
HOST-RESOURCES-MIB::hrSWRunPerfMem.5388 = INTEGER: 31468 KBytes
```

При запросе динамического индекса элемента данных Подсистема извлекает и кэширует всю таблицу SNMP под базовым OID, даже если совпадение будет найдено ранее. Это делается на тот случай, если другой элемент данных в дальнейшем ссылается на тот же самый базовый OID – Подсистема будет искать индекс в кэше вместо еще одного запроса к наблюдаемому устройству. Следует обратить внимание, что каждый процесс поллера использует свой собственный кэш.

Во всех последующих операциях получения значений проверяется только найденный индекс. Если он не изменился, значение запрашивается. Если он изменился, кэш перестраивается – каждый поллер, который встречает измененный индекс, снова обходит и кэширует таблицу индексов SNMP.

# Г.12 Удаленный мониторинг статистики

Некоторые OID, наиболее часто используемые в SNMP, автоматически преобразовываются в числовые представления самим Подсистемой. Например, ifIndex преобразовывается в 1.3.6.1.2.1.2.2.1.1, ifIndex.0 преобразовывается в 1.3.6.1.2.1.2.2.1.1.0.

В таблице 73 содержится перечень специальных OID.

1. Перечень специальных OID

| Специальный OID | Идентификатор | Описание |
| --- | --- | --- |
| i`fIndex` | `1`.3.6.1.2.1.2.2.1.1 | Уникальное значение каждого интерфейса. |
| i`fDescr` | `1`.3.6.1.2.1.2.2.1.2 | Текстовая строка, которая содержит информацию о интерфейсе. Эта строка может включать в себя название компании производителя, имя продукта, аппаратную версию интерфейса. |
| i`fType` | `1`.3.6.1.2.1.2.2.1.3 | Тип интерфейса выделяется в соответствии с физическим/канальным протоколом(-ами) непосредственно "под" сетевым уровнем стека сетевых протоколов. |
| i`fMtu` | `1`.3.6.1.2.1.2.2.1.4 | Размер наибольшей дейтаграммы, которую может отправить/получить интерфейс, указывается в байтах |
| i`fSpeed` | `1`.3.6.1.2.1.2.2.1.5 | Оценочная скорость интерфейса текущей пропускной способности в битах за секунду. |
| i`fPhysAddress` | `1`.3.6.1.2.1.2.2.1.6 | Физический адрес интерфейса на канальном уровне непосредственно "под" сетевым уровнем в стеке сетевых протоколов. |
| i`fAdminStatus` | `1`.3.6.1.2.1.2.2.1.7 | Текущее административное состояние интерфейса. |
| i`fOperStatus` | `1`.3.6.1.2.1.2.2.1.8 | Текущее рабочее состояние интерфейса. |
| i`fInOctets` | `1`.3.6.1.2.1.2.2.1.10 | Полное число полученных байтов, включая символы заголовков. |
| i`fInUcastPkts` | `1`.3.6.1.2.1.2.2.1.11 | Количество пакетов одноадресной рассылки, доставленных на верхний уровень стека сетевых протоколов. |
| i`fInNUcastPkts` | `1`.3.6.1.2.1.2.2.1.12 | Количество пакетов НЕ одноадресной рассылки (broadcast и multicast), доставленных на верхний уровень стека сетевых протоколов. |
| i`fInDiscards` | `1`.3.6.1.2.1.2.2.1.13 | Количество входящих, но отвергнутых пакетов, даже если не было обнаружено ошибок, мешающих доставке пакетов на верхний уровень стека сетевых протоколов. Одной из возможных причин для отвержения пакета могло быть освобождение места в буфере. |
| i`fInErrors` | `1`.3.6.1.2.1.2.2.1.14 | Количество входящих пакетов, полученных с ошибкой, из-за которой пакеты не были доставлены на верхний уровень стека сетевых протоколов. |
| i`fInUnknownProtos` | `1`.3.6.1.2.1.2.2.1.15 | Количество пакетов, полученных через интерфейс, но отвергнутых из-за неизвестного или не поддерживаемого протокола. |
| i`fOutOctets` | `1`.3.6.1.2.1.2.2.1.16 | Полное количество отправленных октетов с интерфейса, включая символы заголовков. |
| i`fOutUcastPkts` | `1`.3.6.1.2.1.2.2.1.17 | Полное количество пакетов, которые пытался отправить верхний уровень стека сетевых протоколов, и которые адресованы не на broadcast или multicast-адреса на этом подуровне, включая те, которые были отвергнуты или не отправлены. |
| i`fOutNUcastPkts` | `1`.3.6.1.2.1.2.2.1.18 | Полное количество пакетов, которые пытался отправить верхний уровень стека сетевых протоколов, и которые адресованы на broadcast или multicast-адреса на этом подуровне, включая те, которые были отвергнуты или не отправлены. |
| i`fOutDiscards` | `1`.3.6.1.2.1.2.2.1.19 | Количество исходящих пакетов, которые были отвергнуты даже если не было обнаружено ошибок, мешающих отправке. Одной из возможных причин отвержения пакета могло быть освобождение места в буфере. |
| i`fOutErrors` | `1`.3.6.1.2.1.2.2.1.20 | Количество исходящих пакетов, которые не могут быть отправлены из-за ошибок. |
| i`fOutQLen` | `1`.3.6.1.2.1.2.2.1.21 | Длина очереди исходящих пакетов (в пакетах). |

# Г.13 Настройка Kerberos

MIB (база управляющей информации) – это виртуальная база данных, используемая для управления объектами в сети связи. MIB-файлы позволяют использовать текстовое представление OID. При мониторинге Подсистемой устройств SNMP можно использовать первичные OID, но для комфортного использования текстовых представлений потребуется установить MIB-файлы.

Например, ifHCOutOctets является текстовым представлением OID 1.3.6.1.2.1.31.1.1.1.10.

Установка MIB-файлов на ОС на основе Debian:

```bash Terminal
apt install snmp-mibs-downloader
download-mibs
```

Установка MIB-файлов на ОС на основе RedHat:

```bash Terminal
dnf install net-snmp-libs
```

На ОС на основе RedHat MIB-файлы должны быть подключены по умолчанию. На ОС на основе Debian нужно отредактировать файл /etc/snmp/snmp.conf и закомментировать строку, которая содержит mibs:

```bash Terminal
As the snmp packages come without MIB files due to license reasons, loading# of MIBs is disabled by default. If you added the MIBs you can re-enable# loading them by commenting out the following line.
mibs :
```

Тестирование snmp MIB-файлов можно выполнить с использованием утилиты snmpwalk. Если эта утилита не установлена, можно воспользоваться следующими инструкциями:

1. для ОС на основе Debian:
2. для ОС на основе RedHat:

```bash Terminal
apt install snmp
```

```bash Terminal
dnf install net-snmp-utils
```

После этого следующая команда должна не выдавать ошибку при выполнении запроса к сетевому устройству:

```bash Terminal
$ snmpwalk -v 2c -c public <IP СЕТЕВОГО УСТРОЙСТВА> ifInOctets
IF-MIB::ifInOctets.1 = Counter32: 176137634
IF-MIB::ifInOctets.2 = Counter32: 0
IF-MIB::ifInOctets.3 = Counter32: 240375057
IF-MIB::ifInOctets.4 = Counter32: 220893420
[...]
```

Следует обратить внимание, что процессы Подсистемы не определяют изменения, выполненные с MIB-файлами, поэтому после каждого изменения необходимо перезапускать Сервер или Прокси, например:

```bash Terminal
service zabbix-server reStart
```

После выполнения этой команды изменения, сделанные в MIB-файлах, вступят в силу.

# Г.14 Параметры modbus.get

Получение SNMP-трапов является полной противоположностью запросам к SNMP-устройствам.

В этом случае информация отправляется с SNMP-устройства и собирается или определяется Подсистемой.

Обычно трапы отправляются при наступлении некоторых условий, и Агент подключается на 162-ый порт Сервера (в отличие от 161-ого порта на стороне Агента, который используется для запросов). Использование трапов может помочь обнаружить некоторые кратковременные проблемы, которые происходят между интервалами опроса и могут быть пропущены при запросах данных.

Получение SNMP-трапов в Подсистеме рассчитано на работу с snmptrapd и с одним из встроенных механизмов передачи трапов в Подсистема – либо bash/perl- скрипты, либо SNMPTT.

Самый простой способ настройки мониторинга трапов после настройки Подсистемы – это использовать решение на основе Bash-скрипта, так как Perl и SNMPTT зачастую отсутствуют в современных дистрибутивах и требуют более сложной настройки. Данное решение использует скрипт, который настраивается в виде traphandle. Для повышения производительности в производственных системах используют встроенное решение Perl (либо скрипт с "do perl"-опцией, либо SNMPTT).

Последовательность действий при получении трапа следующая:

1. `snmptrapd `получает трап;
2. `snmptrapd `передает трап скрипту получателю (Bash, Perl) или SNMPTT;
3. получатель разбирает, форматирует и записывает трап в файл;
4. SNMP-траппер читает и анализирует файл с трапами;
5. для каждого трапа Подсистема находит все элементы данных с типом "SNMP трап" и интерфейсом узла сети, совпадающим с полученным адресом из трапа;

> Примечание – В процессе поиска соответствия используется только выбранный "IP" или "DNS" у интерфейса узла сети.

1. у каждого найденного элемента данных трап сравнивается с регулярным выражением "`snmptrap\[регулярное выражение\]".` Трап записывается в качестве значения для всех совпавших элементов данных. Если совпадений не найдено, но существует элемент данных `snmptrap.fallback,` то трап записывается в качестве значения для этого элемента данных;
2. если трап не был записан в качестве значения для какого-либо элемента данных, Подсистема по умолчанию журналирует не совпавшие трапы. Это поведение настраивается в "Журналировать не совпадающие SNMP трапы" в меню "Администрирование → Общие → Прочие").