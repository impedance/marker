# Приложение Е. Пользовательские команды

Использование каких-либо больших чисел, например "86400", для представления количества секунд в сутках бывает затруднительно и чревато ошибками. Поэтому можно использовать некоторые соответствующие символы единиц измерения (или суффиксы) для упрощения выражений триггеров и ключей элементов данных в Подсистеме.

Вместо "86400" можно ввести просто "1d". Функции суффиксов работают как множители.

Суффиксы времени можно использовать для указания времени:

- `s `– секунды (если используется, то работает так же, как и исходное значение);
- `m `– минуты;
- `h `– часы;
- `d `– сутки;
- `w `– недели;
- `M `– месяцы (только в функциях динамики изменений);
- `y `– годы (только в функциях динамики изменений).

Суффиксы времени поддерживают только целые числа (поэтому "1h" поддерживается, а "1,5h" или "1.5h" – нет; использовать вместо этого "90m").

Суффиксы времени поддерживаются в следующих местах:

- константы и параметры функций выражений триггеров;
- константы формул вычисляемых элементов данных;
- параметры внутренних элементов данных "`zabbix[queue,<от>,<до>]";`
- параметр период времени агрегированных вычислений;
- настройка элементов данных (поля "`Интервал обновления"`, "`Пользовательские интервалы"`, "`Период хранения истории"` и "`Период хранения динамики изменений"`);
- настройка прототипов элементов данных (поля "`Интервал обновления"`, "`Пользовательские интервалы"`, "`Период хранения истории"` и "`Период хранения динамики изменений"`);
- настройка правил низкоуровневого обнаружения (поля "`Интервал обновления"`, "`Пользовательские интервалы"`, "`Период сохранения потерянных ресурсов"`);
- настройка сетевого обнаружения (поле "`Интервал обновления"`);
- настройка веб-сценария (поля "`Интервал обновления"`, "`Время ожидания"`);
- настройка операции действия (поля "`Длительность шага операции по умолчанию"`, "`Длительность шага"`);
- настройки профиля пользователя (поля "`Авто-выход"`, "`Обновить"`, "`Время отображения сообщения"`);
- виджет графика в разделе "`Мониторинг → Панель" (`поле "`Сдвиг по времени"`);
- "`Администрирование → Общие → Очистка истории" (`поля периодов хранения);
- "`Администрирование → Общие → Опции отображения триггеров"` (поля "`Отображать триггеры в состоянии ОК в течение"`, "`Мигание триггеров при изменении состояния"`);
- "`Администрирование → Общие → Другое" (`поле "`Интервал блокировки входа в систему" и` поля, относящиеся к взаимодействию с Сервером);
- опция управления работой Сервера "`ha_set_failover_delay=задержка".`

Суффиксы размера памяти поддерживаются в следующих местах:

- константы и параметры функций выражений триггера;
- константы формул вычисляемых элементов данных.

Для размера памяти можно использовать:

- `К `– килобайт;
- `M `– мегабайт;
- `G `– гигабайт;
- `T `– терабайт.

Символы единиц измерения также используются для более удобного представления данных в веб-интерфейсе.

Эти символы поддерживает как Сервер, так и веб-интерфейс:

- `K `– кило;
- `M `– мега;
- `G `– гига;
- `T `– тера.

Когда в веб-интерфейсе отображаются значения элементов данных в B, Bps, то применяется основание 2 (1K = 1024). Иначе используется основание 10 (1K = 1000).

Дополнительно веб-интерфейс также поддерживает отображение:

- `P `– пета;
- `E `– экса;
- `Z `– зетта;
- `Y `– иотта.

При использовании некоторых соответствующих суффиксов можно написать выражения триггеров, которые легче понимать и поддерживать, например, такие выражения:

```bash Terminal
last(/host/system.uptime[])<86400s
avg(/host/system.cpu.load,600s)<10
last(/host/vm.memory.size[available])<20971520
```

можно заменить на:

```bash Terminal
last(/host/system.uptime[])<1d
avg(/host/system.cpu.load,10m)<10
last(/host/vm.memory.size[available])<20M
```

# Е.1 zabbix_agent2

Чтобы указать период времени, должен использоваться следующий формат:

```bash Terminal
d-d,hh:mm-hh:mm
```

где символы означают:

- `d `– день недели: 1 – понедельник, 2 – вторник, ... , 7 – воскресенье;
- `hh –` часы: 00-24;
- `mm `– минуты: 00-59.

Можно указать более одного периода времени, используя разделитель в виде точки с запятой (;):

```bash Terminal
d-d,hh:mm-hh:mm;d-d,hh:mm-hh:mm...
```

Если оставить период времени пустым, это будет эквивалентно "1-7,00:00-24:00", что является значением по умолчанию.

Верхняя граница периодов времени не включается. Таким образом, если указать период 09:00-18:00, то последней секундой в периоде будет 17:59:59.

Например, рабочее время. С понедельника по пятницу с 9:00 до 18:00:

```bash Terminal
1-5,09:00-18:00
```

Рабочие часы плюс выходные. С понедельника по пятницу с 9:00 до 18:00, а также суббота и воскресенье с 10:00 до 16:00:

```bash Terminal
1-5,09:00-18:00;6-7,10:00-16:00
```

# Е.2 zabbix_agentd

Подсистема использует единый функционал для внешних проверок, пользовательских параметров, элементов данных system.run, пользовательских скриптов оповещений, удаленных команд и глобальных скриптов.

По умолчанию все скрипты в Подсистеме выполняются с использованием оболочки sh, и оболочку по умолчанию изменить нельзя. Чтобы использовать другую оболочку, можно применить следующий прием: создать файл скрипта и вызвать этот скрипт при выполнении команды.

Команда/скрипт выполняется одинаково как на UNIX, так и на Windows-платформах:

1. Подсистема (родительский процесс) создает конвейер для связи;
2. Подсистема настраивает данный конвейер для вывода данных от создаваемого дочернего процесса;
3. Подсистема создает дочерний процесс (выполняет команду/скрипт);
4. создается новая группа процесса (в UNIX) или задача (в Windows) для дочернего процесса;
5. Подсистема считывает из конвейера данные до тех пор, пока не истечет установленное время ожидания или до момента, когда прекратится запись с другой стороны (закрыты все обработчики/файловые дескрипторы). Следует обратить внимание, что дочерний процесс может создать еще некоторое количество процессов и выйти до того, как эти процессы завершатся или будет закрыт обработчик/файловый дескриптор;
6. если установленное время ожидания не было достигнуто, Подсистема ждет завершения начального дочернего процесса или ждет достижения установленного времени ожидания;
7. если начальный дочерний процесс завершил свою работу и время ожидания не окончилось, то Подсистема проверяет код завершения начального дочернего процесса и сравнивает его с 0 (ненулевое значение считается ошибкой выполнения только для пользовательских скриптов оповещений, удаленных команд и пользовательских скриптов, выполняемых на Сервере и Прокси);
8. на этот момент подразумевается, что все выполнено, и все дерево процессов (т.е. группа процессов или задача) завершается.

Подсистема определяет, что команда/скрипт завершили обработку в тот момент, когда завершился изначальный дочерний процесс, и никакие другие процессы не держат открытым обработчик/файловый дескриптор вывода. Когда обработка завершена, все созданные процессы завершаются.

Все двойные кавычки и обратная косая черта в команде экранируются обратной косой чертой, и вся команда заключается в двойные кавычки.

Код завершения проверяется на соответствие следующим условиям:

- только для пользовательских скриптов оповещений, удаленных команд и пользовательских скриптов, выполняемых на Сервере и Прокси;
- любой код завершения, отличный от 0, считается ошибкой выполнения;
- содержимое стандартного вывода ошибки и стандартного вывода собирается при ошибочных выполнениях и доступно в веб-интерфейсе (где отображается результат выполнения);
- дополнительная запись добавляется в журнал удаленных команд на Сервере, чтобы сохранить вывод выполнения скрипта; эту возможность можно включить, используя параметр Агента LogRemoteCommands.

Возможные сообщения в веб-интерфейсе и записи в журналах при ошибочных командах/скриптах:

- содержимое стандартного вывода ошибки и стандартного вывода при ошибочных выполнениях (если имеется);
- "Process exited with code: N." (при пустом выводе и отличном от 0 коде выхода);
- "Process killed by signal: N." (при завершении процесса сигналом, только на Linux);
- "Process terminated unexpectedly." (при завершениях процесса по неизвестным причинам).

# Е.3 zabbix_get

Если Подсистема определяет, что его БД недоступна, он отправляет оповещение и продолжает попытки подключения к БД. Для некоторых механизмов БД распознаются определенные коды ошибок.

Например, для БД MySQL:

- CR_CONN_HOST_ERROR;
- CR_SERVER_GONE_ERROR;
- CR_CONNECTION_ERROR;
- CR_SERVER_LOST;
- CR_UNKNOWN_HOST;
- ER_SERVER_SHUTDOWN;
- ER_ACCESS_DENIED_ERROR;
- ER_ILLEGAL_GRANT_FOR_TABLE;
- ER_TABLEACCESS_DENIED_ERROR;
- ER_UNKNOWN_ERROR.

# Е.4 zabbix_js

В ОС Windows приложения могут отправлять данные в Сервер/Прокси напрямую с помощью библиотеки динамической компоновки sender (zabbix_sender.dll) вместо запуска внешнего процесса (zabbix_sender.exe).

Динамическая библиотека с файлами разработки находится в директории bin. Для ее использования нужно включать заголовочный файл zabbix_sender.h и связывать с библиотекой zabbix_sender.lib. Пример файла с использованием API sender можно найти в директории build_sender.

Динамическая библиотека sender предоставляет следующий функционал:

| int zabbix_sender_send_values( const char *address, unsigned short port, const char *source, const zabbix_sender_value_t *values, int count, char **result); |
| --- |
| char **result);`{.c} |

Следующие структуры данных используются динамической библиотекой sender:

```bash Terminal
typedef struct
{
/* имя узла сети, должно совпадать с именем целевого узла сети в Подсистеме */
char*host;
/* ключ элемента данных */
char*key;
/* значение элемента данных */
char*value;
}
zabbix_sender_value_t;
typedef struct
{
/* общее количество обработанных значений */
int total;
/* количество неуспешных значений */
int failed;
/* время в секундах, потраченное сервером на обработку отосланных значений */
doubletime_spent;
}
zabbix_sender_info_t;
```

# Е.5 zabbix_proxy

zabbix_utils [en] – это библиотека Python для:

- работы с API;
- действий в качестве sender;
- действий в качестве утилиты get.

# Е.6 zabbix_sender

Рекомендуется создать пользователя zabbix как системного, то есть без возможности входа в Подсистему. Некоторые пользователи игнорируют эту рекомендацию и используют ту же самую учетную запись для входа (например, используя SSH) на хост с работающим Подсистемой. Это может привести к аварийному останову демона Подсистемы при выходе. В этом случае в журнале Сервера получают примерно следующее:

```bash Terminal
zabbix_server [27730]: [file:"selfmon.c",line:375] lock failed: [22] Invalid argument
zabbix_server [27716]: [file:"dbconfig.c",line:5266] lock failed: [22] Invalid argument
zabbix_server [27706]: [file:"log.c",line:238] lock failed: [22] Invalid argument
```

и в журнале Агента:

```bash Terminal
zabbix_agentd [27796]: [file:"log.c",line:238] lock failed: [22] Invalid argument
```

Это происходит из-за того, что по умолчанию настройка systemd в файле /etc/systemd/logind.conf равна RemoveIPC=yes. Когда выполняется выход из Подсистемы, ранее созданные компонентами Подсистемы семафоры удаляются, что приводит к сбою.

В случае с systemd:

```bash Terminal
RemoveIPC=
Controls whether System V and POSIX IPC objects belonging to the user shall be removed when the user fully logs out. Takes a boolean argument. If enabled, the user may not consume IPC resources after the last of the user"s sessions terminated. This covers System V semaphores, shared memory and message queues, as well as POSIX shared memory and message queues. Note that IPC objects of the root user and other system users are excluded from the effect of this setting. Defaults to "yes".
```

Имеется 2 способа решения этой проблемы:

- (рекомендуемый) Прекратить использование аккаунт `zabbix д`ля чего-либо, кроме процессов Подсистемы, выделить отдельную учетную запись для остальных потребностей.
- (не рекомендуемый) Задать `RemoveIPC=no в` `/etc/systemd/logind.conf и` перезагрузить ОС. Следует обратить внимание, что RemoveIPC является общесистемным параметром, его изменение повлияет на всю ОС.

Если веб-интерфейс работает за Прокси-сервером, путь cookie в файле конфигурации Прокси необходимо переписать, чтобы он соответствовал reverse-proxied path (обратному пути Прокси). Если путь cookie не переписан, пользователи могут столкнуться с проблемами авторизации при попытке войти в веб-интерфейс.

Пример конфигурации для Nginx:

```bash Terminal
..
location / {
..
proxy_cookie_path /zabbix /;
proxy_pass http://192.168.0.94/zabbix/;
..
```

Пример конфигурации для Apache:

```bash Terminal
..
ProxyPass "/" http://host/zabbix/
ProxyPassReverse "/" http://host/zabbix/
ProxyPassReverseCookiePath /zabbix /
ProxyPassReverseCookieDomain host mon.rosa.dev
..
```

# Е.7 zabbix_server

В таблице 113 описываются отличия между Агентом-1 и Агентом-2.

1. Отличия между Агентом-1 и Агентом-2

| Параметр | Агент-1 | Агент-2 |
| --- | --- | --- |
| Язык программирования | C | Go с некоторыми частями на C |
| Демонизация | да | только с помощью systemd (да на Windows) |
| Поддерживаемые расширения | Пользовательские загружаемые модули на C. | Пользовательские плагины на Go. |
| Требования |
| Поддерживаемые платформы | Linux, IBM AIX, FreeBSD, NetBSD, OpenBSD, HP-UX, Mac OS X, Solaris: 9, 10, 11, Windows: все настольные и серверные версии, начиная с XP | Linux, Windows: все настольные и серверные версии, на которых может быть установлена актуальная поддерживаемая версия Go. |
| Поддерживаемые криптобиблиотеки | GnuTLS 3.1.18 и вышеOpenSSL 1.0.1, 1.0.2, 1.1.0, 1.1.1, 3.0.x. LibreSSL – протестирована с версиями 2.7.4, 2.8.2 (применяются определенные ограничения, см. раздел Шифрование). | Linux: OpenSSL 1.0.1 и выше MS Windows: OpenSSL 1.1.1 или выше.В библиотеке OpenSSL должны быть включена поддержка PSK. LibreSSL не поддерживается. |
| Процессы мониторинга |
| Процессы | Отдельный процесс активных проверок для каждой записи Сервера/Прокси. | Один процесс с автоматически созданными потоками.Максимальное количество потоков определяется переменной окружения `GOMAXPROCS.` |
| Метрики | UNIX: см. список поддерживаемых элементов данных.Windows: см. список дополнительных элементов данных, специфичных для Windows. | UNIX: все метрики, поддерживаемые Агентом.Кроме того, Агент-2 предоставляет нативное решение для мониторинга с помощью Подсистемы: Docker, Memcached, MySQL, PostgreSQL, Redis, systemd и других объектов мониторинга – см. полный список элементов данных, специфичных для Агента 2.Windows: все метрики, поддерживаемые Агентом, а также `net.tcp.service* `проверки для HTTPS, LDAP.Кроме того, Агент-2 предоставляет нативное решение для мониторинга с помощью Подсистемы: PostgreSQL, Redis. |
| Параллелизм | Активные проверки для одного Сервера выполняются последовательно. | Проверки из разных плагинов или множественные проверки в одном плагине могут выполняться параллельно. |
| Пользовательские/гибкие интервалы | Поддерживаются только для пассивных проверок. | Поддерживаются для пассивных и активных проверок. |
| Сторонние трапы | нет | да |
| Дополнительный функционал |
| Постоянное хранилище | нет | да |
| Постоянные файлы для элементов данных `log*[]` | да (только на UNIX) | нет |
| Передача данных журнала | Может выполняться во время сбора данных журнала, чтобы освободить буфер. | Сбор данных журнала останавливается при заполнении буфера, поэтому параметр `BufferSize `должен быть равен как минимум `MaxLinesPerSecond*2.` |
| Настройки тайм-аутов | Задаются только на уровне Агента. | Тайм-аут плагина может переопределить таймаут, заданный на уровне Агента. |
| Смена пользователя во время выполнения | да (только UNIX-подобные системы) | нет (управляется systemd) |
| Настраиваемые пользователем шифры | да | нет |

# Е.8 zabbix_web_service

В этом разделе представлены примеры правильного экранирования при использовании регулярных выражений в различных контекстах.

При использовании конструктора триггерных выражений правильное экранирование в регулярных выражениях добавляется автоматически.

Пользовательский макрос с контекстом:

Регулярное выражение: \.+\"[a-z]+

Пользовательский макрос с контекстом: {$MACRO:regex:"\.+\\"[a-z]+"}

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Функция макросов низкоуровневого обнаружения (LLD):

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Функция макросов LLD внутри контекста пользовательского макроса:

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Пользовательский макрос с контекстом: {$MACRO:"{{#MACRO}.iregsub(\".+\\\"[a-z]+\", \1)}"}

Замечания:

- экранирование обратных слешей для LLD не меняется;
- при вставке макроса LLD в контекст пользовательского макроса нужно поместить это в строку;
- выражение макроса заключается в кавычки;
- кавычки экранируются; всего добавляется 3 новых обратных слеша.

Строковый параметр функции, не относящейся к истории

Содержимое строки: \.+\"[a-z]+

Выражение: concat("abc", "\\.\\\"[a-z]+")

Замечание:

- строковый параметр требует экранирования как для обратных слешей, так и для кавычек.

Строковый параметр функции истории

Содержимое строки: \.+\"[a-z]+

Выражение: find(__ITEM_KEY__,,"regexp","\.+\\"[a-z]+")

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Функция макросов LLD внутри строкового параметра функции, не относящейся к истории

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Выражение: concat("abc, "{{#MACRO}.iregsub(\"\\.+\\\\\"[a-z]+\", \\1)}")

Замечания:

- строковые параметры требуют экранирования как для обратных слешей, так и для кавычек;
- добавляется еще один уровень экранирования, так как макрос будет раскрыт только после раскрытия кавычек в строке.

Функция макросов LLD внутри строкового параметра функции истории

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Выражение: find(__ITEM_KEY__,,"eq","{{#MACRO}.iregsub(\"\.+\\\"[a-z]+\", \1)}")

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Пользовательский макрос с контекстом внутри строкового параметра функции, не относящейся к истории

Регулярное выражение: \.+\"[a-z]+

Пользовательский макрос с контекстом: {$MACRO:regex:"\.+\\"[a-z]+"}

Выражение: concat("abc, "{$MACRO:regex:\"\\.+\\\\\"[a-z]+\"}")

Замечания:

- как и в предыдущем примере, необходим дополнительный уровень экранирования;
- обратные слеши и кавычки экранируются только для экранирования верхнего уровня (поскольку это строковый параметр).

Пользовательский макрос с контекстом внутри строкового параметра функции истории

Регулярное выражение: \.+\"[a-z]+

Пользовательский макрос с контекстом: {$MACRO:regex:"\.+\\"[a-z]+"}

Выражение: find(__ITEM_KEY__,,"eq","{$MACRO:regex:\"\.+\\\"[a-z]+\"}")

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Функция макросов LLD внутри контекста пользовательского макроса внутри функции, не относящейся к истории

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Пользовательский макрос с контекстом: {$MACRO:"{{#MACRO}.iregsub(\".+\\\"[a-z]+\", \1)}"}

Выражение: concat("abc, "{$MACRO:\"{{#MACRO}.iregsub(\\\".+\\\\\\\"[a-z]+\\\", \\1)}\"}")

Замечания по трем уровням экранирования:

- для функции макросов LLD; без экранирования обратных слешей;
- для пользовательского макроса с контекстом; без экранирования обратных слешей;
- для строкового параметра функции; с экранированием обратных слешей.

Функция макросов LLD внутри контекста пользовательского макроса внутри функции истории

Регулярное выражение: \.+\"[a-z]+

Макрос LLD: {{#MACRO}.iregsub("\.+\\"[a-z]+", \1)}

Пользовательский макрос с контекстом: {$MACRO:"{{#MACRO}.iregsub(\".+\\\"[a-z]+\", \1)}"}

Выражение: find(__ITEM_KEY__,,"eq","{$MACRO:\"{{#MACRO}.iregsub(\\".+\\\\"[a-z]+\\", \1)}\"}")

Замечания:

- обратные слеши не экранируются;
- кавычки экранируются.

Пользовательский макрос с контекстом просто внутри строки

Регулярное выражение: \.+\"[a-z]+

Пользовательский макрос с контекстом: {$MACRO:regex:"\.+\\"[a-z]+"}

Внутри строки некоторого выражения, например: func(arg1, arg2, arg3)="{$MACRO:regex:\"\\.+\\\\\"[a-z]+\"}"

Замечания:

- строки также требуют экранирования обратных слешей;
- строки также требуют экранирования кавычек;
- снова случай с двумя уровнями экранирования:
- экранирование для контекста пользовательского макроса; без экранирования обратных слешей;
- экранирование, поскольку это строка; с экранированием обратных слешей.

Перечень терминов и сокращений

| **Сокращение** | **Определение** |
| --- | --- |
| БД | База данных |
| ВМ | Виртуальная машина |
| ИТ | Информационные технологии |
| ОС | Операционная система |
| ПО | Программное обеспечение |
| СИПА | Система идентификации, политик и аудита |
| ЦС | Центр сертификации |
| API | Application programming interface – программный интерфейс приложения |
| CA | Certification authority – центр сертификации (удостоверяющий центр) |
| CSV | Comma separated values – текстовый формат, предназначенный для представления табличных данных |
| DHCP | Dynamic host configuration protocol – протокол динамической настройки сетевой конфигурации хоста |
| DNS | Domain name system – система доменных имен |
| ENC | External node classifier – классификатор внешних хостов |
| ESR | Extended support release – релиз с расширенной (долговременной) поддержкой |
| HA |  |
| HSTS | HTTP Strict Transport Security – механизм, принудительно активирующий защищенное соединение через протокол HTTPS |
| HTTP | Hypertext transfer protocol – протокол передачи гипертекста |
| HTTPS | Hypertext transfer protocol secure – защищенная версия протокола передачи гипертекста |
| IP | Internet protocol – протокол межсетевого взаимодействия |
| IPA | Identity, policy and audit – система идентификации, политик и аудита (СИПА) |
| JSON | JavaScript Object Notation – формат обмена данными |
| LDAP | Lightweight directory access protocol – протокол доступа к каталогам |
| LDAPS | Lightweight directory access protocol secure – защищенная версия протокола доступа к каталогам |
| MAC | Media access control – уникальный идентификатор сетевого оборудования |
| MTA | Mail transfer agent – Агент передачи почтовых сообщений |
| NTP | Network time protocol – протокол сетевого времени |
| RHEL | Red Hat Enterprise Linux – наименование операционной системы |
| SMTP | Simple mail transfer protocol – протокол передачи почтовых сообщений |
| SSH | Secure shell – защищенная оболочка |
| SSL | Secure sockets layer – уровень защищенных сокетов |
| TCP | Transmission control protocol – протокол управления передачей данных |
| TFTP | Trivial file transfer protocol – протокол передачи файлов |
| UDP | User datagram protocol – протокол пользовательских датаграмм |
| URL | Uniform resource locator – сетевой адрес ресурса |
| YAML | Yet another markup language – язык разметки |

| Термины | Определение |
| --- | --- |
| Узел сети | Любое физическое или виртуальное устройство, приложение, служба или любой другой логически связанный набор параметров мониторинга |
| Группа узлов сети | Логическая группировка узлов сети; группа может содержать узлы сети и шаблоны. Узлы сети и шаблоны в группе узлов сети никаким образом не связаны друг с другом. Группы узлов сети используются при назначении прав доступа к узлам сети различным группам пользователей |
| Элемент данных | Конкретный фрагмент данных, который требуется получать от узла сети; метрика |
| Предобработка значений | Преобразование полученного метрикой значения перед сохранением этого значения в базу данных. |
| Триггер | Логическое выражение, которое определяет порог проблемы и используется для "оценки" данных, полученных элементами данных Если полученные данные превышают порог, триггер переходит из состояния "Ок" в состояние "Проблема". Когда полученные данные ниже порога, триггер остается/возвращается в состояние "Ок" |
| Событие | Одиночное возникновение ситуации, например изменение состояния триггера или обнаружение/авторегистрация Агента |
| Тег события | Предопределенный маркер для события. Его можно использовать в корреляции событий, в определении прав доступа и т.д. |
| Корреляция событий | Метод корреляции проблем с решением этих проблем Например, можно задать, что проблема, которую сообщил один триггер, может быть решена другим триггером, который может использовать даже совершенно другой метод сбора данных |
| Проблема | Триггер, который находится в состоянии "Проблема". |
| Обновление проблемы | Варианты управления проблемами в Подсистеме, такие как добавление комментария, подтверждение, изменение важности и закрытие вручную |
| Действие | Предопределенные средства реагирования на события. Действия состоят из операций (например, отправка оповещений) и условий осуществления операций |
| Эскалация | Пользовательский сценарий выполнения операций в рамках действия; последовательность отправки оповещений/выполнения удаленных команд |
| Способ оповещения | Средство доставки оповещений; канал доставки |
| Оповещение | Сообщение о некотором событии, отправленное пользователю через выбранный канал доставки |
| Удаленная команда | Предопределенная команда, которая автоматически выполняется на наблюдаемом узле сети при наступлении некоторых условий |
| Шаблон | Набор объектов (элементов данных, триггеров, графиков, правил низкоуровневого обнаружения, веб-сценариев), готовых к применению на одном или нескольких узлах сети. Задача шаблонов – ускорить развертывание задач мониторинга узлов сети, а также упростить применение массовых изменений к задачам наблюдения. Шаблоны соединяются напрямую с отдельными узлами сети |
| Веб-сценарий | Один или несколько HTTP-запросов для проверки доступности веб-сайта |
| Веб-Интерфейс | поставляемый с веб-интерфейс. |
| Панель | Настраиваемый раздел веб-интерфейса, который отображает сводку и визуализацию важной информации в визуальных блоках, называемых виджетами |
| Виджет | Визуальный блок, который отображает информацию определенного вида и источника (сводка, карта, график, часы и т.д.), используется на панели |
| API | API позволяет использовать протокол JSON RPC для создания, обновления и получения объектов Подсистемы (например, узлов сети, элементов данных, графиков и прочих) или для выполнения любых других оригинальных задач. |
| Сервер | Центральный процесс программного обеспечения Подсистемы, который выполняет мониторинг, взаимодействует с Прокси и Агентами, вычисляет триггеры, отправляет оповещения; центральное хранилище данных |
| Прокси | Процесс, который может собирать данные от имени Сервера, перенимая часть нагрузки Сервера |
| Агент-1 | Процесс, разворачиваемый на наблюдаемых целях для активного мониторинга локальных ресурсов и приложений |
| Агент-2 | Агент нового поколения для активного мониторинга локальных ресурсов и приложений, который позволяет использовать пользовательские плагины для выполнения функций мониторинга. Поскольку Агент-2 имеет во многом схожий функционал с Агентом-1, термин "Агент" в документации означает как Агента-1, так и Агента-2, если функционал не отличается. Агент-2 указывается отдельно в случае наличия различий в функционале |
| Шифрование | Поддержка шифрованной связи между компонентами Подсистемы (сервером, Прокси, Агентом и утилитами zabbix_sender и zabbix_get) с использованием протокола защиты транспортного уровня (TLS) |
| Обнаружение сети | Автоматическое обнаружение сетевых устройств. |
| Низкоуровневое обнаружение | Автоматическое обнаружение низкоуровневых объектов на конкретном устройстве (например, файловые системы, сетевые интерфейсы и т.д.). |
| Правило низкоуровневого обнаружения | Набор определений для автоматического обнаружения низкоуровневых объектов на устройстве |
| Прототип элементов данных | Метрика, у которой некоторые параметры представлены в виде переменных, готовых для низкоуровневого обнаружения. После низкоуровневого обнаружения эти переменные автоматически заменяются реальными обнаруженными параметрами, и метрика автоматически начинает сбор данных |
| Прототип триггеров | Триггер, у которого некоторые параметры представлены в виде переменных, готовых для низкоуровневого обнаружения. После низкоуровневого обнаружения эти переменные автоматически заменяются реальными обнаруженными параметрами и триггер автоматически начинает оценку данных. Прототипы некоторых других объектов Подсистемы также используются в низкоуровневом обнаружении: прототипы графиков, прототипы узлов сети, прототипы групп узлов сети |
| Авторегистрация Агентов | Автоматизированный процесс, при котором Агент самостоятельно регистрируется в качестве узла сети и начинает наблюдаться |