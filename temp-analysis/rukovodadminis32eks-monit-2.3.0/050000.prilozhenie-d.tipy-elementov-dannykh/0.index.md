# Приложение Д. Типы элементов данных

Настройка следующих полей в веб-интерфейсе является специфичной для этого типа элементов данных:

1. Узел сети должен иметь SNMP-интерфейс. В "Настройка → Узлы сети", в поле "Интерфейсы узла сети" добавляют SNMP-интерфейс с корректными IP- или DNS-адресами. Адрес из каждого полученного трапа сравнивается с IP- и DNS-адресами всех SNMP-интерфейсов для поиска подходящих узлов сети.
2. Настройка элемента данных. В поле Ключ используют один из ключей SNMP-трапов (таблица 74).
  1. Ключи SNMP-трапов

| Описание | Возвращаемое значение | Комментарии |
| --- | --- | --- |
| s`nmptrap[регулярное выражение]` |
| Отлов всех SNMP-трапов, которые соответствуют регулярному выражению, указанному в поле "`регулярное выражение".` Если регулярное выражение не указано, принимаются все трапы. | SNMP-трап | Этот элемент данных можно привязать только к SNMP-интерфейсам.В параметре этого ключа элемента данных поддерживаются пользовательские макросы и глобальные регулярные выражения. |
| s`nmptrap.fallback` |
| Отлов всех SNMP-трапов, которые не были перехвачены ни одним из элементов данных `snmptrap[] `для этого интерфейса. | SNMP-трап | Такой элемент данных можно привязать только к SNMP- интерфейсам. |

Многострочное совпадение по регулярному выражению времени не поддерживается.

В поле "Тип информации" указывают значение "Журнал (лог)" для обработки штампов времени. Следует обратить внимание, что другие форматы, такие как "Числовой", также приемлемы, но для этого может потребоваться пользовательский обработчик трапов.

Для того чтобы мониторинг SNMP-трапов работал, он должен быть сначала корректно настроен.

# Д.1 Агент

Для чтения трапов Сервер или Прокси должны быть настроены на запуск процесса SNMP-траппера, а также должны знать абсолютный путь к файлу с трапами, который заполняется при помощи SNMPTT или получателя трапов Bash/Perl. Чтобы это сделать, изменяют файл конфигурации (zabbix_server.conf или zabbix_proxy.conf):

```bash Terminal
StartSNMPTrapper=1
SNMPTrapperFile=[TRAP FILE]
```

Если используется system-параметр PrivateTmp, то этот файл не заработает в /tmp.

Для настройки получателя трапов Bash используется только snmptrapd. Можно использовать Bash-скрипт получателя трапов для передачи трапов Серверу напрямую с snmptrapd. Чтобы его настроить, добавляют опцию traphandle в файл конфигурации snmptrapd.conf.

Для настройки SNMPTT snmptrapd необходимо настроить на использование SNMPTT.

Для лучшей производительности SNMPTT нужно сконфигурировать как демон, используя snmptthandler-embedded для передачи ему трапов.

После настройки SNMPTT на получение трапов, конфигурируют snmptt.ini:

1. включить использование модуля Perl из пакета NET-SNMP:
2. включить журналирование трапов в файл с трапами, который Подсистема будет читать:
3. задать формат даты/времени:

```bash Terminal
net_snmp_perl_enable = 1
```

```bash Terminal
log_enable = 1
log_file = [TRAP FILE]
```

```bash Terminal
date_time_format = %H:%M:%S %Y/%m/%d
```

Пакет net-snmp-perl удален в RHEL 8.0-8.2; добавлен заново в RHEL 8.3.

Далее задают формат трапов, чтобы они распознавались Подсистемой (редактируют snmptt.conf):

1. каждая инструкция FORMAT должна начинаться с "ZBXTRAP [адрес]", где [адрес] будет сравниваться с IP- и DNS-адресами у SNMP-интерфейсов в Подсистеме, например:
2. не используют неизвестные трапы, так как Подсистема может их не распознать. Неизвестные трапы могут быть обработаны, если задать общее событие в snmptt.conf:

```bash Terminal
EVENT coldStart .1.3.6.1.6.3.1.1.5.1 "Status Events" Normal
FORMAT ZBXTRAP $aA Device reinitialized (coldStart)
```

```bash Terminal
EVENT general .* "General event" Normal
```

Для настройки получателя Perl-трапов используются Perl, Net-SNMP, скомпилированный с "--enable-embedded-perl".

Получатель трапов Perl (в misc/snmptrap/zabbix_trap_receiver.pl) можно использовать для передачи трапов Серверу напрямую с snmptrapd. Для его настройки нужно:

1. добавить Perl-скрипт в файл конфигурации snmptrapd (snmptrapd.conf), например:
2. настроить сам получатель, например:

```bash Terminal
perl do "[FULL PATH TO PERL RECEIVER SCRIPT]";
```

```bash Terminal
$SNMPTrapperFile = "[TRAP FILE]";
$DateTimeFormat = "[DATE TIME FORMAT]";
```

Если имя скрипта не заключено в кавычки, snmptrapd не будет запускаться с подобными сообщениями:

```bash Terminal
Regexp modifiers "/l" and "/a" are mutually exclusive at (eval 2) line 1, at end of line
Regexp modifier "/l" may not appear twice at (eval 2) line 1, at end of line
```

Все заданные получатели трапов perl и конфигурация SNMPTT-трапов должны форматировать трап следующим образом:

```bash Terminal
[штамп времени] [трап, часть 1] ZBXTRAP [адрес] [трап, часть 2]
```

где:

- [штамп времени] – штамп времени, используемый в элементах данных типа "Журнал (лог)";
- ZBXTRAP – заголовок, который указывает, что с этой строки начался новый трап;
- [адрес] – IP-адрес, используемый для поиска узла сети для этого трапа.

Следует обратить внимание, что ZBXTRAP и [адрес] при обработке отрезаются из сообщения. Если трап форматируется как-то иначе, Подсистема может разобрать такие трапы непредсказуемым образом.

Пример трапа:

```yaml
11:30:15 2011/07/27 .1.3.6.1.6.3.1.1.5.3 Normal "Status Events" localhost – ZBXTRAP 192.168.1.1 Link down on interface 2. Admin state: 1. Operational state: 2
```

приведет к следующему виду трапа для SNMP-интерфейса с IP=192.168.1.1:

```yaml
11:30:15 2011/07/27 .1.3.6.1.6.3.1.1.5.3 Normal "Status Events"
localhost – Link down on interface 2. Admin state: 1. Operational state: 2
```

## Д.1.1 Специфичные ключи элементов данных для Агента-2

В Подсистеме имеется "поддержка больших файлов" при работе с файлами SNMP-трапов. Максимальный размер файла, который Подсистема может прочитать, это 263 (8 эксабайт). Следует обратить внимание, что файловая система может иметь меньшее ограничение на максимальный размер файлов.

Подсистема не предоставляет какой-либо механизм ротации журналов – это должно быть обеспечено пользователем. Ротация журналов должна начинаться с переименования старого файла и только после этого удаления, чтобы никакие трапы не пропали:

1. Подсистема открывает файл с трапами с последней известной позиции и переходит к шагу в);
2. Подсистема проверяет, была ли выполнена ротация открытого в данный момент файла, сравнивая номера inode с заданным у файла трапов номером inode; если открытого файла нет, Подсистема сбрасывает последнюю позицию и переходит к шагу а);
3. Подсистема читает данные из открытого в данный момент файла и устанавливает новую позицию;
4. обрабатываются новые данные; если этот файл был ротирован, то он закрывается, и Подсистема переходит назад к шагу б);
5. если не было новых данных, Подсистема приостанавливается на 1 секунду и возвращается к шагу б).

Из-за реализации файла с трапами для Подсистемы требуется файловая система с поддержкой inode для того, чтобы различать файлы (эта информация берется из вызова stat()).

## Д.1.2 Специфичные ключи элементов данных для Windows

Этот пример использует snmptrapd и Bash-скрипт получателя для передачи трапов Серверу.

Настройка выполняется с помощью следующих действий:

1. настроить Подсистему, чтобы запускался SNMP-траппер, и указать файл с трапами; добавить в `zabbix_server.conf:`
2. загрузить Bash-скрипт в /usr/sbin/zabbix_trap_handler.sh:

```bash Terminal
StartSNMPTrapper=1
SNMPTrapperFile=/tmp/my_zabbix_traps.tmp
```

```bash Terminal
curl -o /usr/sbin/zabbix_trap_handler.sh https://raw.githubusercontent.com/zabbix/zabbix-docker/6.0/Dockerfiles/snmptraps/alpine/conf/usr/sbin/zabbix_trap_handler.sh
```

При необходимости следует подправить в скрипте переменную ZABBIX_TRAPS_FILE. Для использования значения по умолчанию создать сначала родительскую директорию:

```bash Terminal
mkdir -p /var/lib/zabbix/snmptraps
```

1. добавить в snmtrapd.conf:
2. создать SNMP-элемент данных `TEST:`
3. настроить `snmptrapd `на выбранную версию SNMP-протокола и отправить тестовые трапы, используя утилиту `snmptrap.`

```bash Terminal
traphandle default /bin/bash /usr/sbin/zabbix_trap_handler.sh
```

```bash Terminal
SNMP интерфейс узла сети с IP: 127.0.0.1
Ключ: snmptrap["linkup"]
Формат времени в журнале (логе): yyyyMMdd.hhmmss
```

Протоколы SNMPv1 и SNMPv2 основываются на аутентификации по community-строке. В примере ниже используется "secret" как community- строка. У отправителей SNMP-трапов необходимо указать такое же значение.

Следует обратить внимание, что хотя SNMPv2 все еще широко используется в производственных средах, он не предлагает какое-либо шифрование и реальной аутентификации отправителя. Так как данные отправляются в виде обычного текста, то эти версии протоколов можно использовать только в безопасных средах, таких как приватные частные сети, и никогда не использовать в какой-либо общедоступной или в сторонних сетях.

SNMPv1 в настоящее время практически не используется, так как не поддерживает 64-битные счетчики, и считается устаревшим протоколом.

Чтобы включить прием SNMPv1- или SNMPv2-трапов, необходимо добавить следующую строку в snmptrapd.conf, заменив "secret" на значение строки SNMP community, указанное в отправителях SNMP-трапов:

```bash Terminal
authCommunity log,execute,net secret
```

Далее можно отправить тестовый трап, используя команду snmptrap. В этом примере используется типовой OID "link up":

```bash Terminal
snmptrap -v 2c -c secret localhost 0 linkUp.0
```

Протокол SNMPv3 решает проблемы безопасности SNMPv1/v2 и обеспечивает аутентификацию и шифрование. Можно использовать методы аутентификации MD5 или несколько вариантов SHA и шифры DES или несколько вариантов AES.

Чтобы включить прием SNMPv3, добавляют следующие строки в snmptrapd.conf:

```bash Terminal
createUser -e 0x8000000001020304 traptest SHA mypassword AES
authuser log,execute traptest
```

Следует обратить внимание на ключевое слово "execute", которое позволяет выполнять скрипты для этой модели безопасности пользователя.

```bash Terminal
snmptrap -v 3 -n "" -a SHA -A mypassword -x AES -X mypassword -l authPriv -u traptest -e 0x8000000001020304 localhost 0 linkUp.0
```

> Примечание – Если требуется использовать надежные методы шифрования, такие как AES192 или AES256, рекомендуется net-snmp, начиная с версии 5.8. Возможно, потребуется пересобрать его с опцией "configure: --enable-blumenthal-aes". Более старые версии net-snmp не поддерживают AES192/AES256.

В обоих примерах в /var/lib/zabbix/snmptraps/snmptraps.log есть похожие строки:

```bash Terminal
20220805.102235 ZBXTRAP 127.0.0.1
UDP: [127.0.0.1]:35736->[127.0.0.1]:162
DISMAN-EVENT-MIB::sysUpTimeInstance = 0:0:00:00.00
SNMPv2-MIB::snmpTrapOID.0 = IF-MIB::linkUp.0
```

Значение элемента данных в Подсистеме будет таким:

```bash Terminal
2022-08-05 10:22:352022-08-05 10:22:33
20220805.102233 UDP: [127.0.0.1]:35736->[127.0.0.1]:162
DISMAN-EVENT-MIB::sysUpTimeInstance = 0:0:00:00.00
SNMPv2-MIB::snmpTrapOID.0 = IF-MIB::linkUp.0
```

# Д.2 SNMP-агент

В Подсистеме можно наблюдать за состоянием и доступностью устройств Intelligent Platform Management Interface (IPMI). Для выполнения проверок по IPMI Сервер должен быть изначально сконфигурирован с поддержкой IPMI.

IPMI – стандартизованный интерфейс для удаленного управления "lights-out" или "out-of-band" компьютерными инфраструктурами. Он позволяет наблюдать за состоянием аппаратного обеспечения напрямую с так называемых карт управления "out-of-band" независимо от ОС или же от наличия питания на узле.

IPMI-мониторинг работает только с устройствами, имеющими поддержку IPMI (HP iLO, DELL DRAC, IBM RSA, Sun SSP и т.п.).

Процесс IPMI-менеджер выполняет распределение проверок IPMI между IPMI-поллерами. Теперь узел сети всегда опрашивается только одним IPMI-поллером одновременно, уменьшая количество открытых подключений к BMC-контроллерам. Благодаря этим изменениям можно безопасно увеличивать количество IPMI-поллеров, не беспокоясь о перегрузке BMC-контроллеров. Процесс IPMI-менеджер автоматически запускается, если запускается хотя бы один IPMI-поллер.

# Д.2.1 Обработка массовых SNMP-запросов

Узел сети необходимо настроить для обработки проверок IPMI. Нужно добавить интерфейс IPMI с соответствующими IP-адресом и номером порта, а также задать параметры аутентификации IPMI.

По умолчанию Сервер не запускает IPMI-поллеры, поэтому любые добавленные элементы данных IPMI не будут работать. Чтобы изменить это, нужно открыть файл конфигурации (zabbix_server.conf) Сервера из-под root и найти следующую строку:

```bash Terminal
StartIPMIPollers=0
```

Далее раскомментировать эту строку и задать количество поллеров, например, равное 3:

```bash Terminal
StartIPMIPollers=3
```

Затем сохранить файл и перезапустить zabbix_server.

Для настройки элемента данных на уровне узла сети:

1. в поле Тип выбрать "IPMI Агент";
2. ввести ключ элемента данных, уникальный в пределах узла сети (например, ipmi.fan.rpm);
3. в поле "Интерфейс узла сети" выбрать подходящий IPMI-интерфейс (IP и порт). Следует обратить внимание, что IPMI-интерфейс должен уже существовать на узле сети;
4. указать "IPMI датчи`к"`, с которого нужно забирать метрику (например, "FAN MOD 1A RPM" на Dell Poweredge). По умолчанию необходимо указать ID датчика. Также имеется возможность использования префиксов до самого значения:
  1. `id: `– чтобы указать ID датчика;
    1. `name: `– чтобы указать полное имя датчика. Эта опция может быть полезна в ситуациях, когда датчики можно отличить, только указав полное имя;
5. выбрать соответствующий тип информации ("Числовой (с плавающей точкой)" – в данном случае; для дискретных датчиков – "Числовой (целое положительное)"), единицы измерения (например, "rpm") и любые другие требуемые параметры элемента данных.

Таблица 75 описывает встроенные элементы данных, которые поддерживаются в проверках IPMI-агента.

1. Ключ в проверках IPMI-агента

| ▲ | Описание | Возвращаемое значение | Комментарии |
| --- | --- | --- | --- |
| i`pmi.get` |
|  | Информация, связанная с IPMI-датчиком. | Объект JSON | Этот элемент данных можно использовать для обнаружения IPMI-датчиков. |

# Д.2.2 Динамические индексы

Время ожидания IPMI-сообщений и количество попыток определены в библиотеке OpenIPMI. В связи с текущим дизайном OpenIPMI невозможно сделать эти значения настраиваемыми из Подсистемы ни на уровне интерфейса, ни на уровне элемента данных.

Время ожидания неактивности IPMI-сессии для LAN равняется 60±3 секунды. В Подсистеме невозможно реализовать периодическую отправку команды активации сессии в OpenIPMI. Если проверки IPMI-элементов данных от Подсистемы к конкретному BMC не выполняются в течение времени большего, чем время ожидания сессии, настроенное в BMC, то следующая проверка IPMI после истечения времени ожидания приведет к ошибкам из-за превышения времени ожидания отдельного сообщения, повторных попыток или к ошибке при получении. После этого открывается новая сессия и инициируется полное повторное сканирование BMC. Если требуется избежать лишнего сканирования BMC, рекомендуется установить интервал опроса IPMI-элементов данных ниже времени ожидания неактивности IPMI-сессии, настроенного в BMC.

# Д.2.3 Специальные OID

Для поиска датчиков на узле сети запускают Сервер с включенным DebugLevel=4. После ожидания в течение двух минут можно поискать записи об обнаруженных датчиках в журнале Сервера:

```bash Terminal
$ grep "Added sensor" zabbix_server.log
8358:20130318:111122.170 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:7 id:"CATERR" reading_type:0x3 ("discrete_state") type:0x7 ("processor") full_name:"(r0.32.3.0).CATERR"
8358:20130318:111122.170 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:15 id:"CPU Therm Trip" reading_type:0x3 ("discrete_state") type:0x1 ("temperature") full_name:"(7.1).CPU Therm Trip"
8358:20130318:111122.171 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:17 id:"System Event Log" reading_type:0x6f ("sensor specific") type:0x10 ("event_logging_disabled") full_name:"(7.1).System Event Log"
8358:20130318:111122.171 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:17 id:"PhysicalSecurity" reading_type:0x6f ("sensor specific") type:0x5 ("physical_security") full_name:"(23.1).PhysicalSecurity"
8358:20130318:111122.171 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:14 id:"IPMI Watchdog" reading_type:0x6f ("sensor specific") type:0x23 ("watchdog_2") full_name:"(7.7).IPMI Watchdog"
8358:20130318:111122.171 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:16 id:"Power Unit Stat" reading_type:0x6f ("sensor specific") type:0x9 ("power_unit") full_name:"(21.1).Power Unit Stat"
8358:20130318:111122.171 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:16 id:"P1 Therm Ctrl %" reading_type:0x1 ("threshold") type:0x1 ("temperature") full_name:"(3.1).P1 Therm Ctrl %"
8358:20130318:111122.172 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:16 id:"P1 Therm Margin" reading_type:0x1 ("threshold") type:0x1 ("temperature") full_name:"(3.2).P1 Therm Margin"
8358:20130318:111122.172 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:13 id:"System Fan 2" reading_type:0x1 ("threshold") type:0x4 ("fan") full_name:"(29.1).System Fan 2"
8358:20130318:111122.172 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:13 id:"System Fan 3" reading_type:0x1 ("threshold") type:0x4 ("fan") full_name:"(29.1).System Fan 3"
8358:20130318:111122.172 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:14 id:"P1 Mem Margin" reading_type:0x1 ("threshold") type:0x1 ("temperature") full_name:"(7.6).P1 Mem Margin"
8358:20130318:111122.172 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:17 id:"Front Panel Temp" reading_type:0x1 ("threshold") type:0x1 ("temperature") full_name:"(7.6).Front Panel Temp"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:15 id:"Baseboard Temp" reading_type:0x1 ("threshold") type:0x1 ("temperature") full_name:"(7.6).Baseboard Temp"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:9 id:"BB +5.0V" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +5.0V"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:14 id:"BB +3.3V STBY" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +3.3V STBY"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:9 id:"BB +3.3V" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +3.3V"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:17 id:"BB +1.5V P1 DDR3" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +1.5V P1 DDR3"
8358:20130318:111122.173 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:17 id:"BB +1.1V P1 Vccp" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +1.1V P1 Vccp"
8358:20130318:111122.174 Added sensor: host:"192.168.1.12:623" id_type:0 id_sz:14 id:"BB +1.05V PCH" reading_type:0x1 ("threshold") type:0x2 ("voltage") full_name:"(7.1).BB +1.05V PCH"
```

Для расшифровки типов датчиков IPMI и их состояний следует скачать копию спецификаций IPMI 2.0.

Для расшифровки кода "тип_чтения"("reading_type") используют раздел "Table 42-1, Event/Reading Type Code Ranges" из спецификации. Большинство датчиков из приведенного примера имеют "reading_type:0x1", означающих "порог" датчика. "Table 42-3, Sensor Type Codes" показывает, что "type:0x1" – датчик температуры, "type:0x2" – датчик напряжения, "type:0x4" – датчик частоты вращения вентилятора системы охлаждения и так далее. Пороговые датчики иногда называют "аналоговыми" датчиками, так как они измеряют непрерывные параметры, такие как температуру, напряжение, частоту вращения в минуту.

Другой пример – датчик с "reading_type:0x3". В "Table 42-1, Event/Reading Type Code Ranges" поясняется, что коды типов чтения 02h-0Ch означают "Общий Дискретный" датчик. Дискретные датчики имеют до 15 возможных состояний (другими словами, до 15 значащих бит). Например, для датчика "CATERR" с "type:0x7" "Table 42-3, Sensor Type Codes" показывает, что этот тип обозначает "Процессор" и значение отдельных битов: 00h (наименьший значащий бит) – IERR (внутренняя ошибка процессора), 01h – перегрев процессора и т.д.

В примере есть несколько датчиков с "reading_type:0x6f". Для этих датчиков "Table 42-1, Event/Reading Type Code Ranges" советуют использовать "Table 42-3, Sensor Type Codes" для расшифровки значений битов. Например, датчик "Power Unit Stat" имеет тип "type:0x9", который означает "Блок питания". Смещение 00h означает "Выключено/Обесточено". Другими словами, если младший значащий бит равен 1, то Сервер выключен. Для проверки этого бита можно воспользоваться функцией band с маской "1". Выражение триггера для предупреждения о выключенном Сервере может выглядеть следующим образом:

```bash Terminal
bitand(last(/www.example.com/Power Unit Stat,#1),1)=1
```

Имена дискретных датчиков в OpenIPMI-2.0.16, 2.0.17 и 2.0.18 зачастую имеют дополнительный символ "0" (или какую-то другую цифру или символ), добавленный в конце имени. Например, если ipmitool и OpenIPMI-2.0.19 отображают имена датчиков как "PhysicalSecurity" или "CATERR", то в OpenIPMI-2.0.16, 2.0.17 и 2.0.18 эти имена – "PhysicalSecurity0" или "CATERR0", соответственно.

При настройке элемента данных IPMI для Сервера, использующего OpenIPMI-2.0.16, 2.0.17 и 2.0.18, нужно добавить к их именам "0" в поле "IPMI датчик" для элементов данных IPMI-агента. Когда Сервер будет обновлен в новом Linux-дистрибутиве, использующем OpenIPMI-2.0.19 (или более позднюю), элементы данных с такими IPMI-дискретными датчиками перейдут в состояние "НЕ ПОДДЕРЖИВАЕТСЯ", и потребуется изменить их имена "IPMI датчик" (удалить "0" в конце) и подождать некоторое время, пока они станут "Активированными" снова.

Некоторые IPMI-агенты предоставляют одновременно пороговые и дискретные датчики под одним именем. Предпочтение всегда отдается пороговому датчику.

Если IPMI-проверки не выполняются (по любой из причин: все элементы данных IPMI деактивированы/не поддерживаются на узле сети; сам узел сети деактивирован/удален; узел сети находится в режиме обслуживания и так далее), то соединение будет разорвано со стороны Сервера и Прокси через 3-4 часа в зависимости от времени запуска Сервера/Прокси.

# Д.2.4 MIB-файлы

Простые проверки в основном используются для удаленных безагентных проверок сервисов.

Следует обратить внимание, что для простых проверок Агент не требуется. За обработку простых проверок (создание внешних подключений и т.д.) отвечает Сервер/Прокси.

Примеры использования простых проверок:

```bash Terminal
net.tcp.service[ftp,,155]
net.tcp.service[http]
net.tcp.service.perf[http,,8080]
net.udp.service.perf[ntp]
```

Список поддерживаемых простых проверок приведен в таблице 76.

1. Ключи элемента данных простых проверок

| Описание | Возвращаемое значение | Параметры | Комментарии |
| --- | --- | --- | --- |
| i`cmpping[<цель>,<пакеты>,<интервал>,<размер>,<время ожидания>]` |
| Доступность хоста через пинг по ICMP. | 0 – ошибка при пинге по ICMP1 – успешный пинг по ICMP | `цель `– IP хоста или DNS-имя`пакеты `– количество пакетов`интервал `– время между последовательными пакетами в миллисекундах`размер `– размер пакета в байтах`время ожидания `– время ожидания в миллисекундах | Пример:`=> icmpping[,4] `– если хотя бы один пакет из четырех вернется, элемент данных возвратит 1. |
| i`cmppingloss[<цель>,<пакеты>,<интервал>,<размер>,<время ожидания>]` |
| Процентное отношение потерянных пакетов. | Число с плавающей точкой. | `цель `– IP хоста или DNS-имя`пакеты `– количество пакетов`интервал `– время между последовательными пакетами в миллисекундах`размер `– размер пакета в байтах`время ожидания `– время ожидания в миллисекундах |  |
| i`cmppingsec[<цель>,<пакеты>,<интервал>,<размер>,<время ожидания>,<режим>]` |
| Время ответа на пинг по ICMP (в секундах). | Число с плавающей точкой | `цель `– IP хоста или DNS-имя`пакеты `– количество пакетов`интервал `– время между последовательными пакетами в миллисекундах`размер `– размер пакета в байтах`время ожидания `– время ожидания в миллисекундах`режим `– один из `min, max, avg `(по умолчанию) | Потерянные пакеты либо пакеты с превышенным временем ожидания при вычислениях не учитываются.Если хост недоступен (превышено время ожидания), элемент данных вернет 0.Если возвращаемое значение меньше 0.0001 секунд, то оно будет выставлено в 0.0001 секунд. |
| n`et.tcp.service[сервис,<ip>,<порт>]` |
| Проверка запущен ли сервис и отвечает ли на TCP подключения. | 0 – сервис недоступен1 – сервис работает | `сервис `– возможные значения: `ssh,` `ldap,` `smtp,` `ftp,` `http,` `pop,` `nntp,` `imap,` `tcp,` `https,` `telnet ip `– IP-адрес или DNS-имя (по умолчанию, используется IP/DNS узла сети)`порт `– номер порта (по умолчанию используется стандартный для сервиса номер порта). | Пример:`=> net.tcp.service[ftp,,45]` – можно использовать для проверки доступности FTP-сервера на 45 порту TCP.Следует обратить внимание, что для сервиса `tcp `обязательно нужно указывать порт.Эти проверки могут привести к дополнительным записям в системных лог файлах (обычно сессии SMTP и SSH журналируются).Проверка шифрованных протоколов (таких как IMAP на 993 порту или POP на 995 порту) в настоящее время не поддерживается. Как обходной вариант решения, использовать `net.tcp.service[tcp,<ip>,порт] `для подобных проверок. |
| n`et.tcp.service.perf[сервис,<ip>,<порт>]` |
| Проверка производительности TCP-сервиса. | Число с плавающей точкой.0.000000 – сервис недоступен;секунды – количество секунд, потребовавшихся для подключения к сервису | `сервис –` возможные значения: `ssh,` `ldap,` `smtp,` `ftp,` `http,` `pop,` `nntp,` `imap,` `tcp,` `https,` `telnet` `ip `– IP-адрес или DNS-имя (по умолчанию, используется IP/DNS узла сети)`порт `– номер порта (по умолчанию используется стандартный для сервиса номер порта). | Пример ключа:`=> net.tcp.service.perf[ssh] –` можно использовать для проверки скорости начального ответа от SSH-сервера.Следует обратить внимание, что для сервиса `tcp `обязательно нужно указывать порт.Проверка шифрованных протоколов (таких как IMAP на 993 порту или POP на 995 порту) в настоящее время не поддерживается. Как обходной вариант решения, использовать `net.tcp.service.perf[tcp,<ip>,порт]` для подобных проверок. |
| n`et.udp.service[сервис,<ip>,<порт>]` |
| Проверка запущен ли сервис и отвечает ли на UDP-запросы. | 0 – сервис недоступен1 – сервис работает | `сервис `– возможные значения: `ntp ip `– IP-адрес или DNS-имя (по умолчанию, используется IP/DNS узла сети)`порт –` номер порта (по умолчанию используется стандартный для сервиса номер порта). | Пример:`=> net.udp.service[ntp,,45] – `можно использовать для тестирования доступности NTP-сервиса на 45 порту UDP. |
| n`et.udp.service.perf[сервис,<ip>,<порт>]` |
| Проверка производительности UDP-сервиса. | Число с плавающей точкой.0.000000 – сервис недоступенсекунды – количество секунд, потребовавшихся на ожидание ответа от сервиса | `сервис `– возможные значения: `ntp ip `– IP-адрес или DNS-имя (по умолчанию, используется IP/DNS узла сети)`порт `– номер порта (по умолчанию используется стандартный для сервиса номер порта). | Пример:`=> net.udp.service.perf[ntp] –` можно использовать для тестирования времени ответа от NTP-сервиса. |

Для поддержки SourceIP в простых проверках LDAP (например в net.tcp.service[ldap]) требуется OpenLDAP версии 2.6.1 или новее.

Подсистема не будет обрабатывать простую проверку дольше Timeout (времени ожидания) секунд, заданном в файле конфигурации Сервера/Прокси.

# Д.3 SNMP-трапы

Для обработки ICMP-пингов Подсистема использует внешнюю утилиту fping.

Эта утилита не является частью дистрибутива Подсистемы и должна быть установлена дополнительно. Если утилиты нет, у нее выставлены неверные разрешения или ее размещение не совпадает с размещением, заданным в файле конфигурации Сервера/Прокси (параметры "FpingLocation"), ICMP-пинги (icmpping, icmppingloss, icmppingsec) не будут обрабатываться.

fping должен быть выполняемым под пользователем демонов и должен иметь "setuid root". Выполняют такие команды из-под root для выставления корректных разрешений:

```bash Terminal
chown root:zabbix /usr/sbin/fping
chmod 4710 /usr/sbin/fping
```

После выполнения этих двух команд проверяют владельца исполняемого файла fping. В некоторых случаях владелец может сброситься при выполнении команды chmod.

Также проверяют, принадлежит ли пользователь zabbix к группе zabbix, запустив команду:

```bash Terminal
groups zabbix
```

и, если нет, добавляют следующей командой:

```bash Terminal
usermod -a -G zabbix
```

Значения по умолчанию, ограничения и описания значений для параметров ICMP-проверок приведены в таблице 77.

1. Значения для параметров ICMP-проверок

| Параметр | Ед. изм. | Описание | Флаг у fping | Значения по умолчанию у | Разрешенные ограниченияв Подсистеме |
| --- | --- | --- | --- | --- | --- |
|  |  |  |  | fping | Подсисема | мин | макс |
| п`акеты` | `к`оличество | количество запросов пакетов к цели | -C |  | 3 | 1 | 10000 |
| и`нтервал` | `м`иллисекунды | время ожидания между последовательными пакетами | -p | 1000 |  | 20 | без ограничений |
| р`азмер` | `б`айты | размер пакета в байтах56 байтов на x86, 68 байтов на x86_64 | -b | 56 или 68 |  | 24 | 65507 |
| в`ремя ожидания` | `м`иллисекунды | fping v3.x – время ожидания после отправки последнего пакета, на которое влияет флаг `-C`fping v4.x – отдельное время ожидания по каждому пакету | -t | fping v3.x – 500fping v4.x – наследуется от `-p `флага, но не более 2000 |  | 50 | без ограничений |

Кроме того, Подсистема использует опции "fping -i интервал мс" (не путать с параметром интервал элемента данных, упомянутым выше в таблице, который соответствует опции -p) и "-S исходящий IP-адрес" (или -I в более старых версиях fping). Эти параметры автоматически определяются при выполнении проверок с различными комбинациями опций. Подсистема пытается определить минимальное значение в миллисекундах, которое fping позволяет использовать с "-i", перебирая три значения: 0, 1 и 10. Первое удачное значение затем используется для последующих ICMP-проверок. Этот процесс выполняется каждым процессом ICMP-пинг отдельно.

Автоматически определенные опции fping аннулируются каждый час, и процесс определения выполняется снова при следующей попытке выполнения ICMP-проверки. Следует задать DebugLevel>=4 для просмотра сведений об этом процессе в файлах журналов Сервера или Прокси.

> Примечание – Значения по умолчанию для fping могут различаться в зависимости от платформы и версии. См. документацию по fping.

Подсистема записывает IP-адреса, проверяемые по всем трем ключам icmpping*, во временный файл, который затем передается утилите fping. Если элементы данных имеют различные параметры ключа, то только элементы данных с идентичными параметрами ключа записываются в один файл.Все записанные в один файл IP-адреса проверяются утилитой fping в параллельном режиме, таким образом процесс "icmp pinger" тратит фиксированное время вне зависимости от количества IP-адресов в файле.

# Д.3.1 Настройка SNMP-трапов

Подсистему можно использовать для централизованного мониторинга и анализа файлов журналов с поддержкой или без поддержки ротации журналов.

Можно использовать оповещения для предупреждения пользователей, если файл журнала содержит конкретные строки или шаблоны строк.

Для наблюдения за файлом журнала необходимы:

- Агент, работающий на узле сети;
- Настроенный элемент данных для мониторинга журнала.

Максимальный размер наблюдаемого файла журнала зависит от поддержки больших файлов.

# Д.3.2 Настройка мониторинга SNMP-трапов

Необходимо убедиться, что в файле конфигурации Агента:

- параметр "Hostname" совпадает с именем узла сети в веб-интерфейсе;
- в параметре "ServerActive" указаны Серверы для обработки активных проверок.

Далее задать параметры элемента данных для мониторинга журнала (рисунок 4).

::sign-image
---
src: /image9.png
sign: Рисунок 39 – Настройка элемента данных для мониторинга журнала
---
::

1. Настройка элемента данных для мониторинга журнала

> Примечание – Все обязательные поля во всех окнах ввода отмечены красной звездочкой.

Специально для элементов данных наблюдения за журналами необходимо указать параметры (таблица 78).

1. Параметры элементов данных

| Параметр | Описание |
| --- | --- |
| `Тип` | `В`ыбрать Агент (активный). |
| `Ключ` | `И`спользовать один из следующих ключей: `log[] `или `logrt[`] – эти два ключа элементов данных позволяют выполнять мониторинг файлов журналов и фильтровать записи в журналах по их содержимому при помощи регулярного выражения, если оно присутствует.Например, `log[/var/log/syslog,error].` Нужно убедиться, что у файла имеются права на чтение для пользователя `zabbix,` иначе состояние элемента данных будет "не поддерживается".`log.count[] `или `logrt.count[] `– эти два ключа элементов данных позволяют получить только количество соответствующих строк. |
| `Тип информации` | `З`аполняется автоматически:Для элементов данных `log[] `или `logrt[`] – `Журнал (лог);`для элементов данных `log.count[] `или `logrt.count[] `– `Числовой (целое положительное).`Если используется опциональный параметр `вывод,` можно вручную выбрать подходящий тип информации, отличный от "Журнал (лог)".Следует обратить внимание, что выбор не журнального типа информации приведет к потере локального штампа времени. |
| `Интервал обновления (в сек)` | `Э`тот параметр определяет, как часто Агент будет проверять наличие любых изменений в файле журнала. Указав этот параметр равным 1 секунде, можно получить новые записи незамедлительно. |
| `Формат времени журнала` | `В` этом поле можно опционально задать шаблон для анализа штампа времени строки журнала.Если оставить пустым, штамп времени не будет анализироваться.Поддерживаемые заменители:* y: Год (0001-9999)* M: Месяц (01-12)* d: День (01-31)* h: Час (00-23)* m: Минута (00-59)* s: Секунда (00-59)Например, следующая строка из файла журнала Агента:" 23480:20100328:154718.045 Zabbix agent Started. Zabbix 1.8.2 (revision 11211)."Она начинается с шести символьных позиций для PID, далее следуют дата, время и остальная часть строки.Форматом времени журнала для такой строки могло бы являться "pppppp:yyyyMMdd:hhmmss".Следует обратить внимание, что символы "p" и ":" являются лишь заменителями и могут быть любыми символами, за исключением "yMdhms". |

Примечания:

- Сервер и Агент следят за размером наблюдаемого журнала и временем последней модификации (для `logrt)` при помощи двух счетчиков, кроме того:
- Агент также использует номера inode (на UNIX/GNU/Linux), индексы файлов (на Microsoft Windows) и MD5 суммы первых 512 байтов файла журнала для улучшения выбора в случае, когда файлы журнала усекаются и ротируются.
- На ОС UNIX/GNU/Linux предполагается, что файловые системы, где хранятся файлы журналов, сообщают номера inode-ов, которые могут быть использованы для отслеживания файлов.
- На ОС Microsoft Windows Агент определяет тип файловой системы, на которой находятся файлы журналов, и использует:
- на файловых системах NTFS – 64-битные файловые индексы;
- на файловых системах ReFS (только с Microsoft Windows Server 2012) – 128-битные ID файлов;
- на файловых системах, в которых файловые индексы меняются (т.е. FAT32, exFAT), используется запасной алгоритм для получения разумного подхода в неопределенных условиях, когда ротация файла журнала приводит в результате к множеству файлов журналов с одинаковым временем изменения.
- Номера `inode,` индексы файлов и суммы MD5 собираются Агентом. Они не передаются Серверу и теряются в случае остановки Агента.
- Не стоит менять время последней модификации файлов журналов утилитой touch, не копировать файл журнала с последующим восстановлением его имени (это изменит идентификатор `inode-`файла). В обоих случаях файл будет рассматриваться как другой и будет проанализирован с самого начала, что может привести к дубликатам оповещений.
- Если имеется несколько совпадающих файлов журналов для элемента данных `logrt[], `и Агент следит за наиболее новым из них, и этот более новый файл журнала удаляется, то будет записано сообщение с предупреждением: "`There are no files matching '<шаблон регулярного выражения>' in '<директория>'"`. Агент игнорирует файлы журналов со временем модификации меньшим, чем последнее время модификации, полученное Агентом во время проверки элемента данных `logrt[].`
  - Агент начинает читать файл журнала с той позиции, на которой он остановился последний раз.
  - Количество уже проанализированных байтов (счетчик размера) и время последней модификации (счетчик времени) сохраняются в БД и отправляются Агенту, чтобы убедиться, что Агент начнет читать файл журнала с этой позиции в случаях, когда Агент только что был запущен или Агент получил элементы данных, которые были ранее деактивированы или не поддерживались. Если Агент получает ненулевой счетчик размера от Сервера, но элементу данных `logrt[] `или `logrt.count[] `не удается найти соответствующие файлы, то счетчик размера сбрасывается в 0, чтобы начать анализ с самого начала, если файлы появятся позже.
  - Всякий раз, когда файл журнала становится меньше, чем известное Агенту значение счетчика размера, счетчик обнуляется, и Агент начинает читать файл журнала с самого начала, принимая во внимание счетчик времени.
  - Если в директории есть несколько соответствующих файлов журналов с одинаковым временем последней модификации, Агент пытается корректно проанализировать все файлы журналов с одинаковым временем модификации и избежать пропуска данных или повторного анализа тех же данных, хотя этого и нельзя гарантировать во всех возможных ситуациях. Агент ни предполагает какую-либо определенную схему ротации файлов журналов, ни определяет ее. Когда есть несколько файлов журналов с одинаковым временем последнего изменения, Агент будет обрабатывать их лексикографически в порядке убывания. Таким образом, для некоторых схем ротации файлы журналов будут проанализированы в их оригинальном порядке. Для других же схем ротации журналов первоначальный порядок файла журнала не будет соблюдаться, что может привести к получению найденных по шаблону строк файла журнала в измененном порядке (проблема не возникает, если файлы журнала имеют разное время последней модификации).
  - Агент обрабатывает новые записи файла журнала один раз за "`Период обновления"` секунд.
  - Агент отправляет не более чем "макс. кол-во строк" записей из файла журнала за секунду. Это ограничение предотвращает перегрузку сети и ресурсов процессора и переопределяет значение по умолчанию, предусмотренное параметром MaxLinesPerSecond в файле конфигурации Агента.
  - Для поиска необходимой строки Подсистема обработает в 10 раз больше строк, чем указано в параметре MaxLinesPerSecond. Таким образом, например, если элемент данных `log[] `или `logrt[] `имеет "Интервал обновления" в 1 секунду, то по умолчанию Агент за одну проверку проанализирует не более чем 200 строк файла журнала и отправит Серверу не более 20 совпавших записей. Увеличением параметра MaxLinesPerSecond в файле конфигурации Агента или указанием параметра "макс. кол-во строк" в ключе элемента данных лимит можно увеличить вплоть до 10000 проанализированных записей в журнале и 1000 совпадающих записей для отправки Серверу за одну проверку. Если для параметра "Интервал обновления" указано значение 2 секунды, лимиты для одной проверки могут быть установлены вдвое больше, чем для "Интервал обновления" в 1 секунду.
  - Кроме того, значения `log `и `log.count `всегда ограничены 50% размера буфера отправки у Агента, даже если в буфере нет значений, не связанных с данными из файлов журналов. Таким образом, чтобы значения "макс. кол-во строк" были отправлены за одно подключение (а не за несколько подключений), параметр Агента `BufferSize `должен быть равен по крайней мере "макс. кол-во строк", умноженному на 2. Агент может отсылать данные во время сбора данных из журналов и таким образом освобождать буфер, в то время как Агент-2 остановит сбор данных из журналов до тех пор, пока данные не будут отосланы и буфер освобожден, что выполняется асинхронно.
  - При отсутствии элементов данных журналов весь размер буфера используется для значений, не связанных с данными из журналов. Когда появляются значения от файлов журналов, они при необходимости заменяют более старые данные, не связанные с файлами журналов, до максимально предусмотренного уровня 50%.
  - Если в файле журнала строка длиннее 256 КБ, то только первые 256 КБ сопоставляются с регулярным выражением, остальная часть игнорируется. Но если Агент был остановлен в процессе обработки длинной строки, внутреннее состояние Агента теряется и после перезапуска Агента длинная строчка может быть проанализирована заново и иначе.
  - Специальное примечание для разделителей пути `"\":` если формат_файла представлен как "file\.log", то там не должно быть директории "file", поскольку невозможно однозначно определить, экранируется ли это символ `"." `или же точка является первым символом в имени файла.
  - Регулярные выражения для `logrt `поддерживаются только в именах файлов, совпадение регулярного выражения с директорией не поддерживается.
  - На платформах UNIX элементы данных `logrt[] с`тановятся неподдерживаемыми в случае, если директория, где должен был бы находиться файл журнала, не существует.
  - В Microsoft Windows, если директория не существует, то элемент данных не переводится в состояние "НЕ ПОДДЕРЖИВАЕТСЯ" (например, если в ключе элемента данных директория указана с ошибкой).
  - Отсутствие файла журнала для элемента данных `logrt[] `не переводит его в состояние "НЕ ПОДДЕРЖИВАЕТСЯ". Ошибки чтения файлов журналов для элемента данных `logrt[] `записываются в журнал Агента как предупреждения, но не переводят элемент данных в состояние "НЕ ПОДДЕРЖИВАЕТСЯ".
  - Журнал Агента может быть очень полезен для поиска причин, почему элементы данных `log[] `или `logrt[] `становятся неподдерживаемыми. Подсистема может мониторить свой файл журнала Агента, за исключением случая, когда он в режиме DebugLevel=4 или DebugLevel=5.
  - Поиск знака вопроса при помощи регулярного выражения, например: "`\?"`, может давать ложные срабатывания, если текстовый файл содержит символы NUL, поскольку они заменяются Подсистемой на `"?",` чтобы продолжать обрабатывать строку до символа перевода строки.

# Д.3.3 Требования к системе

Иногда при обнаружении совпадения с регулярным выражением требуется извлечь из требуемого файла только интересующие значения вместо получения всей строки.

Элементы данных файлов журналов имеют возможность извлекать из строк файла желаемые значения. Это достигается с помощью дополнительного параметра "вывод" у элементов данных log и logrt.

Использование параметра "вывод" позволяет обозначить рассматриваемую "подгруппу совпадения".

Например,

```bash Terminal
log[/путь/к/файлу,"large result buffer allocation.*Entries: ([0-9]+)",,,,\1]
```

позволит получить количество элементов (Entries) из следующего содержимого:

```bash Terminal
Fr Feb 07 2014 11:07:36.6690 */ Thread Id 1400 (GLEWF) large result
buffer allocation – /Length: 437136/Entries: 5948/Client Ver: >=10/RPC
ID: 41726453/User: AUser/Form: CFG:ServiceLevelAgreement
```

Будет возвращено только число, так как "\1" ссылается только на первую и единственную интересующую подгруппу ([0-9]+).

Вместе с возможностью извлечения и получения числа значение можно использовать в определениях триггеров.

# Д.3.4 Примеры с использованием разных версий SNMP-протоколов

Параметр максзадержка в элементах данных журналов позволяет игнорировать некоторые более старые строки с целью получения наиболее новых строк, проанализированных в течение максзадержка секунд.

Параметр maxdelay>0 может привести к игнорированию важных записей в файлах журналов и пропуску оповещений. Этот параметр используют только по необходимости.

По умолчанию элементы данных мониторинга журналов забирают все новые строки, появляющиеся в файлах журналов. Но имеются приложения, которые в некоторых ситуациях начинают записывать огромное количество сообщений в свои файлы журналов. Например, если БД или DNS-сервер недоступны, то такие приложения могут заполнять файлы журналов тысячами практически идентичных сообщений об ошибке до тех пор, пока не восстановится нормальный режим работы. По умолчанию все эти сообщения анализируются и совпадающие строки оправляются на Сервер, как это настроено в элементах данных log и logrt.

Встроенная защита от перегрузки состоит из настраиваемого параметра "макс. кол-во строк" (защищает Сервер от получения слишком большого количества совпадающих строк в журнале) и ограничения в 10*"макс. кол-во строк" (защищает CPU и I/O хоста от перегрузки Агентом за одну проверку). Тем не менее имеется две проблемы со встроенным механизмом защиты. Во-первых, на Сервер будет отправлено большое количество потенциально не очень информативных сообщений, которые займут место в БД. Во-вторых, по причине ограниченного количества строк, анализируемых в секунду, Агент может отставать на несколько часов от самых новых записей в журнале. Вполне вероятно, что необходимо оперативно получать информацию о текущей ситуации в файлах журналов вместо длительного анализа старых записей.

Решением обеих проблем является использование параметра максзадержка. Если параметр максзадержка>0, во время каждой проверки измеряются количество обработанных байтов, количество оставшихся байтов и время обработки. Отталкиваясь от этих чисел, Агент вычисляет предполагаемую задержку в секундах на анализ всех оставшихся в файле журнала записей.

Если задержка не превышает максзадержка, то Агент поступает с анализом файла журнала как обычно.

Если задержка больше, чем максзадержка, то Агент игнорирует часть файла журнала, пропуская эту часть к новой оценочной позиции таким образом, чтобы оставшиеся строки можно было проанализировать за максзадержка секунд.

Следует обратить внимание, что Агент не читает проигнорированные строки в буфер, а вычисляет приблизительную позицию для перехода в файле.

Факт пропуска строк в файле журнала записывается в файл журнала Агента примерно следующим образом:

```yaml
14287:20160602:174344.206 item:"logrt["/home/zabbix32/test[0-9].log",ERROR,,1000,,,120.0]"
LogFile:"/home/zabbix32/test1.log" skipping 679858 Bytes
(from Byte 75653115 to Byte 76332973) to meet maxdelay
```

Количество "to Byte" является приблизительным, потому что после перехода Агент скорректирует позицию в файле на начало строки в журнале, которая может быть в файле чуть дальше или ближе.

В зависимости от того, как скорость роста соотносится со скоростью анализа файла журнала, можно не увидеть полных переходов, а лишь фиксировать редкие или частые переходы, большие или маленькие переходы, или даже маленькие переходы по каждой проверке. Колебания загрузки системы и сетевых задержек также влияют на вычисления задержки и, следовательно, переходов вперед, чтобы не отставать от параметра максзадержка.

Не рекомендуется указывать максзадержка<"интервал обновления" (это может привести к частым маленьким переходам).

# Д.4 Проверки IPMI

Элемент данных logrt с опцией copytruncate подразумевает, что разные файлы журналов имеют разные записи (по крайней мере в них отличаются штампы времени), поэтому MD5-суммы начальных блоков (до первых 512 байт) будут отличаться. Два файла с одинаковыми MD5-суммами начальных блоков означают, что один из них оригинал, а второй – копия.

Элемент данных logrt с опцией copytruncate делает попытку корректной обработки копий файлов журналов без дубликатов сообщений. Тем не менее такие варианты, как: создание нескольких копий файлов журналов с одинаковыми штампами времени, ротация файлов журналов чаще чем интервал обновления logrt[] элемента данных, частый перезапуск Агента – не рекомендуются. Агент пытается справиться со всеми этими ситуациями, но хорошие результаты не гарантируются при любых обстоятельствах.

# Д.4.1 Настройка

Постоянный файл элементов данных обновляется после успешной отправки каждой партии данных (содержащей данные по элементам данных) на Сервер. Например, по умолчанию BufferSize равен 100. Если элемент данных журнала нашел 70 совпадающих записей, то первые 50 записей будут отправлены одной партией, постоянный файл будет обновлен, затем оставшиеся 20 записей будут отправлены второй партией (возможно, с некоторой задержкой на буферизацию большего количества данных), и затем постоянный файл будет снова обновлен.

# Д.4.2 Время ожидания и завершение сессии

Каждая совпадающая строка с элементов данных log[] и logrt[] и результат проверки каждого элемента данных log.count[] и logrt.count[] требует свободного слота в выделенных 50% области буфера отправки в Агенте. Элементы буфера периодически отправляются Серверу (или Прокси), и слоты буфера становятся снова пустыми.

Пока имеются свободные слоты в выделенной области для журналов в буфере отправки в Агенте, и связь между Агентом и Сервером (или Прокси) нарушена, результаты мониторинга журналов накапливаются в буфере отправки. Такое поведение позволяет смягчить кратковременные нарушения связи.

Во время длительных нарушений связи все слоты журналов становятся занятыми и выполняются следующие действия:

- Проверки элементов данных `log[] `и `logrt[] `останавливаются. Когда связь восстановится и появятся свободные слоты, проверки возобновятся с предыдущей позиции. Совпадающие строки не будут потеряны, они просто будут отправлены позже.
- Проверки `log.count[] и` `logrt.count[] о`станавливаются, если `maxdelay=0 (`по умолчанию). Такое поведение похоже на поведение элементов данных `log[] и` `logrt[],` описанное выше. Следует обратить внимание, что потеря связи может повлиять на результаты `log.count[] `и `logrt.count[]. `Например, одна проверка насчитывает 100 совпадающих строк в файле журнала, но по причине отсутствия свободных слотов в буфере проверка остановлена. Когда связь восстановится, Агент насчитает те же 100 совпадающих строк, а также 70 новых совпадающих строк. После этого Агент отправит количество равное 170, как будто они были найдены за одну проверку.
- Проверки `log.count[] `и `logrt.count[] `при `максзадержка>0:` если не было перехода во время проверки, то поведение аналогично описанному выше. Если все же был переход через строки файла журнала, то позиция после перехода сохранится, а вычисленный результат будет отброшен. Таким образом, Агент пытается не отставать от увеличивающегося файла журнала даже в случае проблем со связью.

# Д.4.3 Дискретные датчики IPMI

Если регулярное выражение, использованное в элементах данных log[], logrt[], log.count[] или logrt.count[], не может быть откомпилировано библиотекой PCRE или PCRE2, то элемент данных переходит в неподдерживаемое состояние с сообщением об ошибке. Для продолжения мониторинга журнального элемента данных регулярное выражение необходимо исправить.

Если регулярное выражение компилируется успешно, но дает сбой во время выполнения (на некоторых или на всех записях файла журнала), то журнальный элемент данных остается поддерживаемым и мониторинг продолжается. Ошибка времени выполнения добавляется в файл журнала Агента (без исходной журнальной записи).

Частота добавления в журнал ограничена одной ошибкой времени выполнения на одну проверку, чтобы дать возможность Агенту контролировать свой собственный файл журнала. Например, если анализируются 10 записей, и 3 из них вызывают ошибки времени выполнения, связанные с регулярным выражениями, то в файл журнала Агента будет добавлена одна запись.

Исключение: если MaxLinesPerSecond=1 и Интервал обновления=1 (на каждую проверку разрешено анализировать только одну запись), то ошибки времени выполнения при обработке регулярных выражений вообще не пишутся.

В случае ошибок времени выполнения zabbix_agentd записывает в файл журнала ключ элемента данных, а zabbix_agent2 записывает ID элемента данных, чтобы помочь идентифицировать, какой из элементов данных имеет ошибки времени выполнения. В случае ошибок времени выполнения рекомендуется переделать регулярное выражение.

# Д.5 Простые проверки

При запуске Агент получает список активных проверок от Сервера или Прокси. Для log*[]-метрик Агент получает размер обработанного журнала и время модификации, чтобы найти место начала мониторинга файла журнала. В зависимости от реального размера файла журнала и времени модификации, полученных от файловой системы, Агент решает: либо продолжить мониторинг файла журнала с обработанного размера журнала, либо проанализировать файл журнала с самого его начала.

Работающий Агент поддерживает большой набор параметров для отслеживания между проверками всех наблюдаемых файлов журналов. Это состояние теряется в памяти при остановке Агента.

Новый опциональный параметр "постоянное_хранилище" указывает директорию для хранения этого состояния в файле по log[], log.count[], logrt[] или logrt.count[]-элементам данных. Состояние элемента данных журнала восстанавливается из постоянного файла после перезапуска Агента.

Основным сценарием применения такого подхода является мониторинг файла журнала, который расположен на зеркалируемой файловой системе. До некоторого момента файл журнала записывается в обоих зеркалах. Затем зеркала разделяются. На активном зеркале копия файла журнала продолжает расти, получая новые записи. Агент анализирует их и отправляет на Сервер размер обработанного журнала и время модификации. На стороне пассивного зеркала копия файла журнала остается той же самой, находясь далеко позади активной копии. Затем ОС и Агент перезагружаются с пассивной копии. Полученные от Сервера Агентом размер обработанного журнала и время модификации могут быть недостоверными для ситуации с пассивной копией. Для продолжения наблюдения за файлом журнала с того же места, на котором Агент остановил обработку файла при разделении зеркала, Агент восстанавливает свое состояние из постоянного файла.

# Д.5.1 ICMP-пинг

При запуске Агент ничего не знает о постоянных файлах. Только после получения списка активных проверок от Сервера (Прокси) Агент видит, что некоторые элементы данных журналов необходимо поддерживать при помощи постоянных файлов в указанных директориях.

В процессе работы Агента постоянные файлы открыты на запись (с использованием fopen(имя_файла,"w")) и перезаписываются последними данными. Шанс потери данных постоянного файла, если перезапись и разделение зеркала файловой системы совпадут, очень мал, специальной обработки такого случая нет. После записи в постоянный файл не следует принудительная синхронизация с носителями информации (fsync() не вызывается).

Перезапись последними данными выполняется после успешного сообщения на Сервер о найденной строке файла журнала или о метаданных (размер обработанного журнала и время модификации). Это может происходить так же часто, как и проверки каждого элемента данных, если файл журнала продолжает изменяться.

При остановке Агента не выполняется никаких специальных действий.

После получения списка активных проверок Агент помечает устаревшие постоянные файлы для удаления. Постоянный файл становится устаревшим, если:

1. соответствующий элемент данных журнала более не наблюдается;
  1. элемент данных журнала перенастраивается на другое расположение "постоянного_хранилища", нежели ранее.

Удаление выполняется с задержкой в 24 часа, так как файлы журналов в неподдерживаемом состоянии не включаются в список активных проверок, но могут стать поддерживаемыми позже, и в этом случае их постоянные файлы будут полезны.

Если Агент остановлен до истечения 24 часов, то устаревшие файлы не будут удалены, так как Агент более не получает со стороны Сервера информацию об их расположении.

Перенастройка "постоянного_хранилища" элементов данных назад к старому значению расположения "постоянного_хранилища", пока Агент остановлен, без удаления старого постоянного файла пользователем приведет к восстановлению состояния Агента из старого постоянного файла, что приведет к пропущенным сообщениям или к ложным оповещениям.

# Д.6 Мониторинг файлов журналов

Агент различает активные проверки по их ключам. Например, logrt[/home/zabbix/test.log] и logrt[/home/zabbix/test.log,] – разные элементы данных. Изменение в веб-интерфейсе элемента данных logrt[/home/zabbix/test.log,,,10] на logrt[/home/zabbix/test.log,,,20] приведет к удалению элемента данных logrt[/home/zabbix/test.log,,,10] из списка активных проверок Агента и созданию элемента данных logrt[/home/zabbix/test.log,,,20] (некоторые параметры сохраняются при изменениях в веб-интерфейсе / на стороне Сервера, но не на стороне Агента).

Имя файла состоит из MD5-суммы ключа элемента данных с длиной ключа, добавляемой для уменьшения возможных пересечений. Например, состояние элемента данных

logrt[/home/zabbix50/test.log,,,,,,,,/home/zabbix50/agent_private]

будет храниться в постоянном файле c963ade4008054813bbc0a650bb8e09266.

Несколько элементов данных могут использовать одно и то же значение "постоянного_хранилища".

"постоянное_хранилище" указывается с учетом структуры конкретной файловой системы, точек монтирования и опций монтирования, а также настроек зеркалирования хранилища: постоянный файл должен располагаться на том же зеркале файловой системы, что и наблюдаемый файл журнала.

Если директорию "постоянного_хранилища" не удается создать, или она не существует, или права доступа Агента не позволяют создавать/записывать/читать/удалять файлы, то элемент данных журнала становится неподдерживаемым.

Если права доступа к файлам постоянного хранилища отозваны во время работы Агента или возникают другие ошибки (например, заполнился диск), то ошибки вносятся в файл журнала Агента, но элемент данных не становится неподдерживаемым.

# Д.6.1 Настройка

При помощи вычисляемых элементов данных имеется возможность выполнять подсчеты на основании значений других элементов данных.

Вычисления могут использовать:

- единичные значения отдельных элементов данных;
- сложные фильтры для выбора нескольких элементов данных для последующей агрегации.

Таким образом, вычисляемые элементы – это способ создания виртуальных источников данных. Все вычисления выполняются только на стороне Сервера. Значения периодически рассчитываются на основе использованного арифметического выражения.

Полученные данные записываются в БД Подсистемы так же, как и по любым другим элементам данных; хранятся значения истории и динамики изменений; можно сгенерировать графики.

Если результат вычисления – значение числа с плавающей точкой, то оно будет обрезаться до целого числа, если типом информации вычисляемого элемента данных выбрано "Числовой (целое положительное)".

Вычисляемые элементы данных имеют общий синтаксис с выражениями триггеров. В вычисляемых элементах данных допускается сравнение со строками. На вычисляемые элементы данных можно ссылаться макросами или другими такими же объектами, как и в случае любого другого типа элементов данных.

Для использования вычисляемых элементов данных выбирают Вычисляемый тип элементов данных.

# Д.6.2 Извлечение совпадающей части регулярного выражения

Ключ – уникальный идентификатор элемента данных (в пределах узла сети). Можно создать любое имя ключа, используя поддерживаемые символы.

Формулу вычисления необходимо ввести в поле Формула. Не существует связи между формулой и ключом. Параметры ключа не используются в формуле ни коим образом.

Синтаксис простой формулы:

```bash Terminal
функция(/узел сети/ключ,<параметр1>,<параметр2>,...)
```

где:

- функция – одна из поддерживаемых функций: `last,` `min,` `max,` `avg,` `count `и т.д.;
- узел сети – узел сети элемента данных, который используется в вычислении; текущий узел сети может быть опущен (например, функция(//ключ,параметр,...));
- ключ – ключ элемента данных, который используется в вычислении;
- параметр(ы) – параметры функции, если требуются.

Пользовательские макросы в формуле будут раскрыты, если используется ссылка на параметр функции, параметр фильтра элементов данных или константу. Пользовательские макросы не будут раскрыты при использовании ссылки на функцию, имя узла сети, ключ элемента данных, параметры ключа элементов данных или оператор.

Для получения более сложной формулы можно использовать комбинацию функций, операторов и скобок. Можно использовать все функции и операторы, которые поддерживаются в выражениях триггеров. Логика и приоритет операторов точно такие же.

В отличие от выражений триггеров, Подсистема обрабатывает вычисляемые элементы данных в соответствии с интервалом обновления элемента данных, а не при получении нового значения.

Все элементы данных, на которые имеются ссылки из функций истории в формуле вычисляемого элемента данных, должны существовать и собирать данные. Также при изменении ключа элемента данных, на который ссылается вычисляемый элемент данных, нужно вручную обновить все формулы, в которых этот ключ используется.

Вычисляемый элемент данных может перейти в неподдерживаемое состояние в нескольких случаях:

- элемент(ы) данных, на которые имеется ссылка:
- не найден;
- деактивирован;
- принадлежит деактивированному узлу сети;
- не поддерживается (за исключением функции `nodata() `и операторов с неизвестными значениями);
  - отсутствуют данные для вычисления функции;
  - деление на ноль;
  - использован некорректный синтаксис.
  - Примеры использования

Пример 1. Вычисление процентного отношения свободного места на диске для "/".

Использование функции last:

```bash Terminal
100*last(//vfs.fs.size[/,free])/last(//vfs.fs.size[/,total])
```

Подсистема будет брать последние значения полного и свободного объема диска и затем вычислять процентное отношение в соответствии с заданной формулой.

Пример 2. Вычисление 10-минутного усреднения количества значений, обрабатываемых Подсистемой.

Использование функции avg:

```bash Terminal
avg(/Zabbix Server/zabbix[wcache,values],10m)
```

Следует обратить внимание, что интенсивное использование вычисляемых элементов данных с большими периодами времени может повлиять на производительность Сервера.

Пример 3. Вычисление общей пропускной способности на eth0.

Сумма двух функций:

```bash Terminal
last(//net.if.in[eth0,Bytes])+last(//net.if.out[eth0,Bytes])
```

Пример 4. Вычисление процентного отношения входящего трафика.

Более сложное выражение:

```bash Terminal
100*last(//net.if.in[eth0,Bytes])/(last(//net.if.in[eth0,Bytes])+last(//net.if.out[eth0,Bytes]))
```

# Д.6.3 Использование параметра "максзадержка"

Агрегированные вычисления – это тип вычисляемых элементов данных, который позволяет собирать информацию с нескольких элементов данных Сервером и затем вычислять совокупность в зависимости от использованной функции агрегирования.

Для элементов данных агрегированного вычисления поддерживаются только целочисленные значения и значения с плавающей точкой (тип информации).

Агрегированные вычисления не требуют наличия какого-либо Агента, запущенного на наблюдаемом узле сети.

Для получения агрегирования можно:

- перечислить элементы данных для агрегации:

```bash Terminal
функция_агрегации(функция(/узел_сети/ключ,параметр),функция(/узел_сети2/ключ2,параметр),...)
```

Следует обратить внимание, что здесь функция должна быть функцией истории/динамики изменений.

- использовать функцию foreach в качестве единственного параметра и ее фильтр элементов данных для выбора требуемых элементов данных:

```bash Terminal
функция_агрегации(функция_foreach(/узел_сети/ключ?[group="узел сети"],период_времени))
```

Функция агрегации – одна из поддерживаемых функций агрегации: avg, max, min, sum и т.д.

Функция foreach (такая как avg_foreach, count_foreach и т.п.) возвращает одно совокупное значение по каждому выбранному элементу данных. Элементы данных выбираются с использованием фильтра элементов данных (/узел_сети/ключ?[group="группа узлов сети"]) из истории элементов данных.

Если некоторые элементы данных не имеют данных за требуемый период, они игнорируются в вычислении. Если никакие элементы данных не имеют данных, то функция вернет ошибку.

Для получения более подробных сведений о функции foreach (см. п.Ж.1).

Если в результате агрегации получится значение числа с плавающей точкой, оно будет обрезаться до целого числа, если типом информации вычисляемого элемента данных выбрано "Числовой (целое положительное)".

Агрегированное вычисление может перейти в неподдерживаемое состояние в нескольких случаях:

- ни один из указанных элементов данных не найден (что может произойти, если ключ элемента данных некорректный, элементы данных не существуют или все включенные в вычисление группы узлов сети некорректны);
- отсутствуют данные для вычисления функции.

Примеры ключей для агрегированных вычислений

Пример 1. Общий размер дискового пространства в группе узлов сети "MySQL Servers".

```bash Terminal
sum(last_foreach(/*/vfs.fs.size[/,total]?[group="MySQL Servers"]))
```

Пример 2. Сумма последних значений на узле сети всех элементов данных, совпадающих с net.if.in[*].

```bash Terminal
sum(last_foreach(/host/net.if.in[*]))
```

Пример 3. Средняя загрузка процессора в группе узлов сети "MySQL Servers".

```bash Terminal
avg(last_foreach(/*/system.cpu.load[,avg1]?[group="MySQL Servers"]))
```

Пример 4. Усреднение за 5 минут количества запросов в секунду по группе узлов сети "MySQL Servers".

```bash Terminal
avg(avg_foreach(/*/mysql.qps?[group="MySQL Servers"],5m))
```

Пример 5. Средняя загрузка CPU по всем узлам сети в нескольких группах узлов сети, у которых имеются заданные теги.

```bash Terminal
avg(last_foreach(/*/system.cpu.load?[(group="Servers A" or group="Servers B" or group="Servers C") and (tag="Service:" or tag="Importance:High")]))
```

Пример 6. Вычисление с использованием суммы последних значений элементов данных по всей группе узлов сети.

```bash Terminal
sum(last_foreach(/*/net.if.out[eth0,Bytes]?[group="video"])) / sum(last_foreach(/*/nginx_stat.sh[active]?[group="video"]))
```

Пример 7. Общее количество неподдерживаемых элементов данных в группе узлов сети "Zabbix servers".

```bash Terminal
sum(last_foreach(/*/zabbix[host,,items_unsupported]?[group="Zabbix servers"]))
```

Примеры корректного/некорректного синтаксиса. Выражения (включая вызовы функций) нельзя использовать в качестве параметров к функциям истории, динамики изменений или foreach. Но сами эти функции могут быть использованы в параметрах других (не относящихся к истории) функций (таблица 79).

1. Примеры корректного/некорректного синтаксиса

| Выражение | Пример |
| --- | --- |
| Допустимое | `avg(last(/host/key1),last(/host/key2)*10,last(/host/key1)*100)max(avg(avg_foreach(/*/system.cpu.load?[group="Servers A"],5m)),avg(avg_foreach(/*/system.cpu.load?[group="Servers B"],5m)),avg(avg_foreach(/*/system.cpu.load?[group="Servers C"],5m)))` |
| Недопустимое | `sum(/host/key,10+2)sum(/host/key, avg(10,2))sum(/host/key,last(/host/key2))` |

Следует обратить внимание, что в таком выражении:

```bash Terminal
sum(sum_foreach(//resptime[*],5m))/sum(count_foreach(//resptime[*],5m))
```

нельзя гарантировать, что обе части всегда будут иметь одинаковый набор значений. Пока вычисляется одна часть выражения, может прийти новое значение за запрашиваемый период, и тогда вторая часть выражения будет иметь отличающийся набор значений.

# Д.6.4 Обработка ротации "copytruncate" файлов журналов

Внутренние проверки позволяют наблюдать за внутренним процессами Подсистемы. Другими словами, можно наблюдать, что происходит с Сервером или Прокси.

Внутренние проверки вычисляются:

- на стороне Сервера – если узел сети наблюдается через Сервер;
- на стороне Прокси – если узел сети наблюдается через Прокси.

Внутренние проверки обрабатываются Сервером или Прокси вне зависимости от состояния обслуживания узла сети.

Для использования этого элемента данных выбрать тип элемента данных Внутренний.

Внутренние проверки обрабатываются поллерами.

Использование некоторых внутренних элементов данных может отрицательно повлиять на производительность. Речь идет о следующих элементах данных:

- `zabbix[host,,items];`
- `zabbix[host,,items_unsupported];`
- `zabbix[hosts];`
- `zabbix[items];`
- `zabbix[items_unsupported];`
- `zabbix[queue];`
- `zabbix[requiredperformance];`
- `zabbix[stats,,,queue];`
- `zabbix[triggers].`

```bash Terminal
Поддерживаемые проверки
```

Параметры без угловых скобок являются константами, например, host и available в zabbix[host,<тип>,available]. Их используют в ключе элемента данных без изменения (как есть).

Значения элементов данных и параметров элементов данных, которые "не поддерживаются на Прокси" можно собирать только на узлах сети, которые наблюдаются через Сервер. И наоборот, значения "не поддерживается на Сервере" можно собирать, только если узел сети наблюдается через Прокси (таблица 80).

1. Описание поддерживаемых проверок

| ▲ | Описание | Возвращаемое значение | Комментарии |
| --- | --- | --- | --- |
| zabbix[boottime] |
|  | Время запуска процесса Сервера или Прокси в секундах. | Целое число. |
| zabbix[cluster,discovery,nodes] |
|  | Обнаружение нод кластера высокой доступности | JSON. | Этот элемент данных можно использовать в низкоуровневом обнаружении. |
| z`abbix[history]` |
|  | Количество значений, хранимых в таблице HISTORY | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[history_log]` |
|  | Количество значений, хранимых в таблице HISTORY_LOG | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[history_str]` |
|  | Количество значений, хранимых в таблице HISTORY_STR | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[history_text]` |
|  | Количество значений, хранимых в таблице HISTORY_TEXT | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[history_uint]` |
|  | Количество значений, хранимых в таблице HISTORY_UINT | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[host,,items]` |
|  | Количество активированных элементов данных (поддерживаемых и неподдерживаемых) у узла сети. | Целое число. |  |
| z`abbix[host,,items_unsupported]` |
|  | Количество активированных неподдерживаемых элементов данных у узла сети. | Целое число. |  |
| z`abbix[host,,maintenance]` |
|  | Возвращает текущее состояние обслуживания узла сети. | 0 – узел сети в нормальном состоянии,1 – узел сети в обслуживании со сбором данных,2 – узел сети в обслуживании без сбора данных. | Данный элемент данных всегда обрабатывается Сервером вне зависимости от настроек узла сети (мониторится через Сервер или Прокси). Прокси не получает этот элемент данных при получении своей конфигурации.Второй параметр должен быть пустым и зарезервирован для использования в будущем. |
| z`abbix[host,discovery,interfaces]` |
|  | Детали по всем добавленным интерфейсам к узлу сети в веб-интерфейсе. | Объект JSON. | Этот элемент данных можно использовать в низкоуровневом обнаружении.(не поддерживается на Прокси) |
| z`abbix[host,<тип>,available]` |
|  | Доступность основного интерфейса определенного типа проверок на узле сети. | 0 – недоступен, 1 – доступен, 2 – неизвестно. | Допустимые `типы:` `agent,` `snmp,` `ipmi,` `jmx.`Значение элемента данных вычисляется согласно параметрам конфигурации доступности/недоступности касательно узлов сети. |
| z`abbix[hosts]` |
|  | Количество наблюдаемых узлов сети | Целое число. |
| z`abbix[items]` |
|  | Количество активированных элементов данных (поддерживаемых и неподдерживаемых) | Целое число. |
| z`abbix[items_unsupported]` |
|  | Количество неподдерживаемых элементов данных | Целое число. |
| z`abbix[java,,<параметр>]` |
|  | Получение информации, связанной с Java gateway. | Если `<параметром> я`вляется `ping,` возвращается "1". Можно использовать для проверки доступности Java gateway, используя функцию триггера `nodata().`Если `<параметром> я`вляется `version,` возвращается версия Java gateway. | Допустимые значения для `параметр:ping,` `version`Второй параметр должен быть пустым, т.к. зарезервирован для использования в будущем. |
| z`abbix[lld_queue]` |
|  | Количество значений, помещенных в очередь обработки низкоуровневых обнаружений. | Целое число. | Этот элемент данных можно использовать для мониторинга размера очереди обработки низкоуровневых обнаружений. |
| z`abbix[preprocessing_queue]` |
|  | Количество значений, помещенных в очередь предварительной обработки. | Целое число. | Этот элемент данных можно использовать для мониторинга размера очереди предварительной обработки. |
| z`abbix[process,<тип>,<режим>,<состояние>]` |
|  | Время конкретного процесса или группы процессов (указываются с помощью `<тип> `и `<режим>)`, потраченное на <состояние> в процентах. Расчет производится только за последнюю минуту.Если в поле `<режим> `указан номер процесса Подсистемы, который не запущен (например, при 5 запущенных поллерах, в `<режиме> `указано 6), такой элемент данных перейдет в состояние "`не поддерживается".`Минимум и максимум относится к процентному использованию одним процессом. Таким образом, если в группе из 3 поллеров процентное использование составило 2, 18 и 66, то min должен вернуть 2, а max должен вернуть 66.Процессы сообщают то, что они делают, используя разделяемую память, и процесс само-диагностики обобщает эти данные каждую секунду. Изменения состояний (`busy/idle)` регистрируются при изменении – таким образом, процессы, которые становятся занятыми, регистрируют это состояние и не меняют, и не обновляют его, пока процесс не станет свободным. Такое поведение гарантирует, что даже полностью зависшие процессы будут корректно зарегистрированы как 100% занятые.В настоящее время, "`busy"` означает "не спит", но в будущем могут добавиться дополнительные состояния – ожидание блокировки, выполнение запросов в базу данных, и т.д.В Linux и в большинстве других систем, точность составляет 1/100 секунды. | Процент времени.Число с плавающей точкой. | Поддерживаемые `типы `процессов Сервера:`alert manager,` `alert syncer,` `alerter,` `availability manager,` `configuration syncer,` `discoverer,` `escalator,` `ha manager,` `history poller,` `history syncer,` `housekeeper,` `http poller,` `icmp pinger,` `ipmi manager,` `ipmi poller,` `java poller,` `lld manager,` `lld worker,` `odbc poller,` `poller,` `preprocessing manager,` `preprocessing worker,` `proxy poller,` `self-monitoring,` `service manager,` `snmp trapper,` `task manager,` `timer,` `trapper,` `trigger housekeeper,` `unreachable poller,` `vmware collector`Поддерживаемые `типы `процессов Прокси:`availability manager,` `configuration syncer,` `data sender,` `discoverer,` `heartbeat sender,` `history poller,` `history syncer,` `housekeeper,` `http poller,` `icmp pinger,` `ipmi manager,` `ipmi poller,` `java poller,` `odbc poller,` `poller,` `preprocessing manager,` `preprocessing worker,` `self-monitoring,` `snmp trapper,` `task manager,` `trapper,` `unreachable poller,` `vmware collector`Допустимые `режимы:avg `– среднее значение по всем процессам указанного типа (по умолчанию)`count `– количество экземпляров указанного типа процесса, <состояние> не должно быть указано`max `– максимальное значение`min `– минимальное значение`<номер процесса> `– номер процесса (от 1 до количества экземпляров процессов). Например, если запущенно 4 траппера, то значение от 1 до 4.Допустимые `состояния:busy `– процесс в занятом состоянии, например, обработка запроса (по умолчанию).`idle `– процесс в состоянии простоя, ничего не делающий.Примеры:`=> zabbix[process,poller,avg,busy]– `среднее время, потраченное процессами поллеров, которые что-либо делали за последнюю минуту`=> zabbix[process,"icmp pinger",max,busy] `– максимальное время, потраченное любыми процессами ICMP pinger, которые что-либо делали за последнюю минуту`=> zabbix[process,"history syncer",2,busy]–` время, потраченное на что-то процессом синхронизации истории номер 2 в течение последней минуты`=> zabbix[process,trapper,count] `– общее количество запущенных процессов траппер |
| z`abbix[proxy,<имя>,<параметр>]` |
|  | Информация доступности по Прокси. | Целое число. | `имя:` имя ПроксиДопустимые значения для `параметр:lastaccess `– штамп времени последнего сообщения о доступности от Прокси`delay `– длительность задержки отправки собранных значений, рассчитывается как "задержка Прокси" (разница между текущим временем Прокси и отметкой времени самого старого неотправленного значения на Прокси) + ("текущее время сервера" – "последний доступ Прокси")Например, `=> zabbix[proxy,"Germany",lastaccess]`Можно использовать `функцию fuzzytime() `для проверки доступности Прокси.Этот элемент данных всегда обрабатывается Сервером, независимо от расположения узла сети (на Сервере или Прокси). |
| z`abbix[proxy_history]` |
|  | Количество значений в таблице истории Прокси, ожидающих отправку на сервер | Целое число. | (не поддерживается сервером) |
| z`abbix[queue,<от>,<до>]` |
|  | Количество наблюдаемых элементов данных в очереди, которые задерживаются минимум `<от>,` но менее `<до> `секунд. | Целое число. | `от `– по умолчанию: 6 секунд`до `– по умолчанию: бесконечноДля этих параметров поддерживаются суффиксы времени (s,m,h,d,w). |
| z`abbix[rcache,<кэш>,<режим>]` |
|  | Статистика доступности кэша конфигурации | Целое число (для размера);число с плавающей точкой (для процентов). | `кэш:` `buffer`Допустимые `режимы:total `– полный размер буфера`free `– размер свободного места в буфере`pfree `– процент свободного места в буфере`used `– размер использованного места в буфере`pused `– процент использования буфера |
| z`abbix[requiredperformance]` |
|  | Требуемое быстродействие Сервера или Прокси, новых значений в секунду. | Число с плавающей точкой. | Приблизительно соответствует значению "`Требуемое быстродействие Сервера, новые значения в секунду"` со страницы "`Отчеты → Информация о системе"`. |
| z`abbix[stats,<ip>,<порт>]` |
|  | Внутренние метрики удаленного Сервера или Прокси. | Объект JSON. | `ip `– список IP/DNS/сетевой маски опрашиваемых удаленно Серверов / Прокси (по умолчанию 127.0.0.1)`порт `– порт опрашиваемого удаленно Сервера / Прокси (по умолчанию 10051)Следует обратить внимание, что запрос статистики будет приниматься только с адресов, которые перечислены в параметре "`StatsAllowedIP"` Сервера/Прокси на удаленном экземпляре.Этим элементом данных возвращается выбранный список внутренних метрик. |
| z`abbix[stats,<ip>,<порт>,queue,<от>,<до>]` |
|  | Внутренние метрики очереди удаленного Сервера или Прокси. (см. `zabbix[queue,<от>,<до>])`. | Объект JSON. | `ip `– список IP/DNS/сетевой маски опрашиваемых удаленно Серверов / Прокси (по умолчанию 127.0.0.1)`порт –` порт опрашиваемого удаленно Сервера / Прокси (по умолчанию 10051)`от `– с задержкой по крайней мере (по умолчанию от 6 секунд)`до `– с задержкой не более (по умолчанию до бесконечности)Следует обратить внимание, что запрос статистики будет приниматься только с адресов, которые перечислены в параметре "`StatsAllowedIP"` Cервера / Прокси на удаленном экземпляре. |
| z`abbix[tcache,cache,<параметр>]` |
|  | Статистика эффективности кэша функций динамики изменений. | Целое число (для размера); число с плавающей точкой (для процентов). | Допустимые значения для `параметр:all `– общее количество запросов кэша (по умолчанию)`hits `– количество попаданий в кэш`phits `– процент попаданий в кэш`misses `– количество непопаданий в кэш`pmisses `– процент непопаданий в кэш`items `– количество элементов данных в кэше`requests `– количество кэшируемых запросов`pitems `– процент элементов данных в кэше из кэшируемых элементов данных + запросов. Низкий процент зачастую означает, что размер кэша можно уменьшить.(не поддерживается Прокси) |
| z`abbix[trends]` |
|  | Количество значений, хранимых в таблице TRENDS | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL!(не поддерживается Прокси) |
| z`abbix[trends_uint]` |
|  | Количество значений, хранимых в таблице TRENDS_UINT | Целое число. | Не использовать с MySQL, InnoDB, Oracle или PostgreSQL.(не поддерживается Прокси) |
| z`abbix[triggers]` |
|  | Количество активированных триггеров в базе данных Подсистемы со всеми активированными элементами данных, которые упомянуты в выражениях триггеров на активированных узлах сети. | Целое число. | (не поддерживается Прокси) |
| z`abbix[uptime]` |
|  | Время непрерывной работы процесса Сервера или Прокси в секундах. | Целое число. |
| z`abbix[vcache,buffer,<режим>]` |
|  | Статистика доступности кэша значений. | Целое число (для размера);число с плавающей точкой (для процентов). | Допустимые значения `режим:total `– полный размер буфера`free `– размер свободного места в буфере`pfree `– процент свободного места в буфере`used `– размер использованного места в буфере`pused `– процент использованного места в буфере(не поддерживается Прокси) |
| z`abbix[vcache,cache,<параметр>]` |
|  | Статистика эффективности кэша значений Подсистемы. | Целое число.С параметром `mode:`0 – нормальный режим,1 – режим низкой памяти | Допустимые значения `параметра:requests `– общее количество запросов`hits `– количество попаданий в кэш (значения истории берутся из кэша)`misses `– количество непопаданий в кэш (значения истории берутся из базы данных)`mode `– режим работы кэша значений(не поддерживается Прокси)После переключения в режим низкой памяти, кэш значений будет оставаться в этом состоянии в течение 24 часов – даже если проблема, вызвавшая этот режим, будет решена раньше.Можно использовать этот ключ с шагом предобработки "`Изменение в секунду"` при необходимости получения статистики значений в секунду. |
| z`abbix[version]` |
|  | Версия Сервера или Прокси. | Строка. | Пример возвращаемого значения: 1`.0.0` |
| z`abbix[vmware,buffer,<режим>]` |
|  | Статистика доступности кэша VMware. | Целое число (для размера);число с плавающей точкой (для процентов). | Допустимые значения для `режим:total `– полный размер буфера`free `– размер свободного места в буфере`pfree `– процент свободного места в буфере`used `– размер использованного места в буфере`pused `– процент использованного места в буфере |
| z`abbix[wcache,<кэш>,<режим>]` |
|  | Статистика и доступность кэша записи Подсистемы. | Требуется обязательно указывать `<кэш>.` |
|  | **Кэш** | **Режим** |
|  | values | all(по умолчанию) | Общее количество значений, обрабатываемых Сервером или Прокси, исключая неподдерживаемые. | Целое число. | Счетчик.Можно использовать этот ключ с шагом предобработки "`Изменение в секунду" `при необходимости получения статистики значений в секунду. |
|  |  | float | Количество обработанных значений с плавающей точкой. | Целое число. | Счетчик. |
|  |  | uint | Количество обработанных целочисленных значений. | Целое число. | Счетчик. |
|  |  | str | Количество обработанных символьных/строковых значений. | Целое число. | Счетчик. |
|  |  | log | Количество обработанных значений из файлов журналов. | Целое число. | Счетчик. |
|  |  | text | Количество обработанных текстовых значений. | Целое число. | Счетчик. |
|  |  | not supported | Количество раз, когда обработка элементов данных приводила к тому, что элемент данных становился неподдерживаемым или сохранял это состояние. | Целое число. | Счетчик. |
|  | history | pfree(по умолчанию) | Свободное место в буфере истории в процентах. | Число с плавающей точкой. | Кэш истории используется для хранения значений элементов данных. Низкое количество свободного места отражает проблемы с производительностью на стороне базы данных. |
|  |  | free | Размер свободного места в буфере истории. | Целое число. |
|  |  | total | Полный размер буфера. | Целое число. |
|  |  | used | Размер занятого места в буфере истории. | Целое число. |
|  |  | pused | Занятое место в буфере истории в процентах. | Число с плавающей точкой. |  |
|  | index | pfree(по умолчанию) | Свободное место в буфере индексов истории в процентах. | Число с плавающей точкой. | Кэш индексов истории используется для индексирования значений, записываемых в кэш истории. |
|  |  | free | Свободное место в буфере индексов истории. | Целое число. |
|  |  | total | Полный размер буфера индексов истории. | Целое число. |
|  |  | used | Размер занятого места в буфере индексов истории. | Целое число. |
|  |  | pused | Занятое место в буфере индексов истории в процентах. | Число с плавающей точкой. |  |
|  | trend | pfree(по умолчанию) | Свободное место в буфере динамики изменений в процентах. | Число с плавающей точкой. | Кэш динамики изменений агрегируется за текущий час для всех элементов данных, которые получают данные.(не поддерживается Прокси) |
|  |  | free | Свободное место в буфере динамики изменений. | Целое число. | (не поддерживается Прокси) |
|  |  | total | Полный размер буфера динамики изменений. | Целое число. | (не поддерживается Прокси) |
|  |  | used | Размер занятого места в буфере динамики изменений. | Целое число | (не поддерживается Прокси) |
|  |  | pused | Занятое место в буфере динамики изменений в процентах. | Число с плавающей точкой. | (не поддерживается Прокси) |

# Д.6.5 Постоянные файлы у log*[]-элементов данных при нагрузке на I/O

SSH-проверки выполняются без какого-либо Агента. Агент не требуется для проверок, выполняемых по SSH.

Для выполнения SSH-проверок Сервер должен быть изначально сконфигурирован с поддержкой SSH2 (libssh2 или libssh).

Начиная с RHEL 8, поддерживается только libssh. Для других дистрибутивов вместо libssh2 предлагается libssh.

Проверки SSH предоставляют два метода аутентификации: пара логин пользователя/пароль и на основе файла ключа.

Если не требуется использовать ключи, то (помимо привязки библиотеки libssh2/libssh к Подсистеме при компиляции из исходных кодов) никакой дополнительной настройки не требуется.

Чтобы использовать для элементов данных SSH-аутентификацию по ключу, необходимо произвести некоторые изменения в конфигурации Сервера:

1. открыть файл конфигурации Сервера zabbix_server.conf из-под `root `и найти следующую строку:
2. раскомментировать ее и указать полный путь к директории, в которой размещены открытые и закрытые ключи (public and private keys):

```bash Terminal
SSHKeyLocation=
```

```bash Terminal
SSHKeyLocation=/home/zabbix/.ssh
```

где:

- /home/zabbix – домашняя директория для учетной записи пользователя `zabbix;`
- .ssh` –` директория внутри нее, куда будут по умолчанию сгенерированы с помощью команды ssh-keygen открытые и закрытые ключи.
1. сохранить файл и перезапустить Сервер.

Обычно при установке Сервера из пакетов на разных дистрибутивах ОС создается аккаунт пользователя zabbix с домашней директорией в других местах (не как для системных аккаунтов), например /var/lib/zabbix.

До начала создания ключей следует рассмотреть вариант перемещения домашней директории в обычное место (интуитивно ожидаемое). Этот вариант будет соответствовать упомянутому выше параметру SSHKeyLocation конфигурации Сервера.

Эти шаги можно пропустить, если учетная запись zabbix добавлена вручную в соответствии с разделом установки, потому что в этом случае домашняя директория, скорее всего, уже расположена в /home/zabbix.

Для изменения этой настройки у учетной записи пользователя zabbix все работающие процессы, которые его используют, потребуется остановить:

```bash Terminal
service zabbix-agent stop
service zabbix-server stop
```

Чтобы изменить местоположение домашней директории с попыткой переместить ее (если директория существует), нужно выполнить команду:

```bash Terminal
usermod -m -d /home/zabbix
```

Возможно, что домашняя директория не существует в старом месте, поэтому в новом месте ее необходимо создать. Безопасно сделать это, выполнив:

```bash Terminal
test -d /home/zabbix || mkdir /home/zabbix
```

Для полной безопасности можно выполнить дополнительные команды для установки разрешений к домашней директории:

```bash Terminal
chown zabbix:zabbix /home/Zabbix
chmod 700 /home/zabbix
```

Далее можно снова запустить ранее остановленные процессы:

```bash Terminal
service zabbix-agent Start
service zabbix-server Start
```

Теперь шаги генерирования открытых и закрытых ключей можно выполнить следующими командами (для лучшей читабельности запросы команд закомментированы):

```bash Terminal
sudo -u zabbix ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/zabbix/.ssh/id_rsa):
/home/zabbix/.ssh/id_rsa
Enter passphrase (empty for no passphrase):
<оставить пустым>
Enter same passphrase again:
<оставить пустым>
Your identification has been saved in /home/zabbix/.ssh/id_rsa.
Your public key has been saved in /home/zabbix/.ssh/id_rsa.pub.
The key fingerprint is:
90:af:e4:c7:e3:f0:2e:5a:8d:ab:48:a2:0c:92:30:b9 zabbix@it0
The key"s randomart image is:
+--[ RSA 2048]----+
||
|.|
|o|
| .o|
|+. S|
|.+o =
|# |E .* =|
|=o . ..* .|
|... oo.o+|
+-----------------+
```

Открытые и закрытые ключи (id_rsa.pub и id_rsa соответственно) будут сгенерированы по умолчанию в директории /home/zabbix/.ssh, которая соответствует параметру конфигурации SSHKeyLocation Сервера.

Утилитой ssh-keygen и Сервером SSH могут поддерживаться ключи и других типов, кроме rsa; но они могут не поддерживаться используемой Подсистемой библиотекой libssh2.

# Д.6.6 Действия при ошибке связи между Агентом и Сервером

Этот шаг необходимо выполнить только один раз для каждого хоста, который будет наблюдаться с использованием SSH-проверок.

При использовании следующей команды файл открытого ключа может быть установлен на удаленный хост 10.10.10.10, для того чтобы потом можно было выполнять SSH-проверки при помощи аккаунта root (для лучшей читабельности подсказки команды закомментированы):

```bash Terminal
sudo -u zabbix ssh-copy-id root@10.10.10.10
The authenticity of host "10.10.10.10 (10.10.10.10)" can"t be established.
RSA key fingerprint is 38:ba:f2:a4:b5:d9:8f:52:00:09:f7:1f:75:cc:0b:46.
Are you sure you want to continue connecting (yes/no)?
yes
Warning: Permanently added "10.10.10.10" (RSA) to the list of known hosts.
root@10.10.10.10"s password:
<Введите пароль пользователя root>
Теперь попытайтесь зайти на машину с помощью "ssh "root@10.10.10.10"",
и проверьте, чтобы убедиться, что не добавили лишние нежелательные ключи.
```

Теперь можно проверить вход по SSH с использованием закрытого ключа по умолчанию (/home/zabbix/.ssh/id_rsa) учетной записи пользователя zabbix:

```bash Terminal
sudo -u zabbix ssh root@10.10.10.10
```

Если вход успешен, то часть настройки в командной строке завершена, и удаленную сессию по SSH можно закрыть.

# Д.6.7 Обработка ошибок компиляции и времени выполнения для регулярных выражений

Фактически выполняемые команды необходимо поместить в поле "Выполняемый скрипт" при настройке элемента данных. Можно выполнять несколько команд одну за другой, размещая каждую на новой строке. В этом случае возвращаемые значения также будут отформатированы как многострочные (рисунок 5).

::sign-image
---
src: /image10.png
sign: Рисунок 41 – Поле "Выполняемый скрипт"
---
::

1. Поле "Выполняемый скрипт"

Поля, которые требуют специфичную информацию для SSH-элементов данных, описаны в таблице 81.

1. Параметры для SSH-элементов данных

| Параметр | Описание | Комментарии |
| --- | --- | --- |
| Т`ип` | Выбрать SSH-Агент |  |
| К`люч` | Уникальный (в пределах узла сети) ключ элемента данных в формате `ssh.run[уникальное короткое описание,<ip>,<порт>,<кодировка>,<опции_ssh>]` | `"уникальное короткое описание" `обязательно и должно быть уникальным у всех элементов данных типа SSH в рамках одного узла сети.По умолчанию `порт 22,` а не порт, указанный в интерфейсе узла сети, которому этот элемент данных назначен.`опции_ssh `(требует libssh версии 0.9.0 или выше либо libssh2) позволяют передать дополнительные опции SSH в формате "`ключ1=значение1;ключ2=значение2,значение3".` Несколько значений для одного ключа можно передать через запятую (в этом случае параметр должен быть заключен в кавычки); несколько ключей опций можно передать через разделитель "точка с запятой". Поддерживаемые ключи и значения опций зависят от библиотеки SSH. Следует обратить внимание, что знак "+" для добавления настроек шифров и знак "!" для отключения конкретных настроек шифров (как в GnuTLS и OpenSSL) не поддерживаются. |
| М`етод аутентификации` | Один из "`Пароль"` или "`Публичный ключ"` |  |
| И`мя пользователя` | Имя пользователя для аутентификации на удаленном хосте. Требуется. |  |
| Ф`айл публичного ключа` | Имя файла открытого ключа, если "`Метод аутентификации"` задан значением "`Публичный ключ"`. Требуется. | Например: `id_rsa.pub `– имя по умолчанию файла открытого ключа, сгенерированного командой |
| Ф`айл приватного ключа` | Имя файла закрытого ключа, если "`Метод аутентификации"` задан значением "`Публичный ключ"`. Требуется. | Например: `id_rsa `– имя по умолчанию файла закрытого ключа |
| П`ароль `или`Парольная фраза` | Пароль для аутентификации илиПарольная фраза, если она была использована для закрытого ключа | Оставить поле "`Парольная фраза"` пустым, если фраза не используется. |
| В`ыполняемый скрипт` | Команда(-ы) оболочки, выполняемые с использованием удаленной сессии SSH | Значение, возвращаемое выполняемыми командами оболочки, ограничено 16 МБ (включая конечные пробелы, которые усекаются); также применяются ограничения базы данных.Следует обратить внимание, что библиотека libssh2 может усекать выполняемые скрипты до ~32 килобайт.Примеры:`date +%sservice mysql-server statusps auxww \| grep httpd \| wc -l` |

### Д.6.7.1 Назначение постоянных файлов

Telnet-проверки выполняются без наличия какого-либо Агента. Агент не требуется для проверок через Telnet.

Фактические команды для выполнения необходимо поместить в поле "Выполняемый скрипт" при настройке элемента данных. Можно выполнять несколько команд одну за другой, размещая каждую на новой строке. В этом случае значение результата также будет отформатировано как многострочное.

Поддерживаемые символы, которыми может заканчиваться строка приглашения командной оболочки: $, #, >, %.

Строка telnet с запросом, которая заканчивается одним из этих символов, будет удалена из возвращаемого значения, но только для первой команды из списка команд, то есть только в начале telnet-сессии. Выполнение команды на удаленном устройстве с использованием telnet-соединения:

```bash Terminal
telnet.run[<уникальное короткое описание>,<ip>,<порт>,<кодировка>]
```

Если telnet-проверка возвращает значение с символами не-ASCII и не в кодировке UTF8, то необходимо указать корректный параметр ключа <кодировка>.

### Д.6.7.2 Работа Агента с постоянным файлом

Внешняя проверка производится Сервером путем выполнения shell-скрипта или бинарного файла. Если узлы сети наблюдаются через Прокси, внешние проверки будут выполняться этим Прокси.

Внешние проверки не требуют на наблюдаемом узле сети какого-либо Агента.

Синтаксис ключа элемента данных:

```bash Terminal
скрипт[<параметр1>,<параметр2>,...]
```

где:

- скрипт – имя shell-скрипта или бинарного файла;
- параметр(ы) – опциональные параметры командной строки.

Если не требуется передавать какие-нибудь параметры скрипту, можно использовать:

```bash Terminal
script[]
```

или

```bash Terminal
script
```

Сервер проверит директорию, указанную для размещения внешних скриптов (параметр ExternalScripts в файле конфигурации Сервера), и выполнит заданную команду. Команда будет выполнена от имени пользователя, под которым запущен Сервер, так что любые права доступа или переменные среды должны быть обработаны в оболочке скрипта, если необходимо, и права доступа на команду должны разрешать этому пользователю выполнение скрипта. Для исполнения доступны только те команды, которые имеются в наличии в указанной директории.

Не следует часто использовать внешние проверки, так как каждый скрипт требует запуска Сервером дочернего процесса, а запуск множества скриптов может значительно снизить производительность Подсистемы.

Пример. Выполнение скрипта check_oracle.sh с первым параметром "-h". Второй параметр будет заменен IP-адресом или DNS-именем узла сети в зависимости от выбранного в настройках узла сети:

```bash Terminal
check_oracle.sh["-h","{HOST.CONN}"]
```

Если узел сети настроен на использование IP-адреса, то Подсистема выполнит:

```bash Terminal
check_oracle.sh "-h" "192.168.1.4"
```

### Д.6.7.3 Именование и расположение постоянных файлов

Возвращаемым значением внешней проверки является стандартный вывод вместе со стандартным выводом ошибок, производимые проверкой.

Элемент данных, возвращающий текст (символ,​ журнал или текстовый тип данных), не станет неподдерживаемым в случае появления чего-либо в стандартном выводе ошибок.

Возвращаемое значение ограничено 16 МБ (включая конечные пробелы, которые усекаются); также применяются ограничения БД.

В случае если выполняемый скрипт не найден или Сервер не имеет необходимых прав на его запуск, данный элемент станет неподдерживаемым, и отобразится соответствующее сообщение об ошибке.

В случае превышения времени ожидания элемент данных также станет неподдерживаемым, будет отображено соответствующее сообщение об ошибке, а отдельный процесс этого скрипта будет ликвидирован.

# Д.7 Вычисляемые элементы данных

Траппер-элементы данных принимают входящие данные вместо опроса этих данных. Это полезно для любых данных, которые потребуется передать в Подсистему.

Для использования элемента данных траппера необходимо:

- настроить траппер-элемент данных;
- отправить данные в Подсистему.

Для настройки элемента данных траппер нужно:

1. перейти в "`Настройка → Узлы сети"`;
2. нажать на Э`лементы данных `в строке с узлом сети;
3. нажать на С`оздать элемент данных;`
4. ввести в окно параметры элемента данных (рисунок 6).

::sign-image
---
src: /image11.png
sign: Рисунок 485 – Настройка траппера
---
::

1. Настройка траппера

Поля, которые требуют указания специфичной информации для траппер-элемента данных:

- Т`ип `– выбрать `"Zabbix траппер";`
- `Ключ `– ввести ключ, который будет использован для распознавания элемента данных при отправке данных.
- `Тип информации `– выбрать тип информации, который будет соответствовать формату отсылаемых данных.
- `Разрешенные хосты `– список разделенных запятыми IP-адресов, опционально в CIDR-представлении, или DNS-имен. Если задано, входящие подключения будут приниматься только с перечисленных здесь узлов сети. Если включена поддержка IPv6, то `"127.0.0.1",` `"::127.0.0.1",` `"::ffff:127.0.0.1" `обрабатываются одинаково и `"::/0" `будет разрешать любые IPv4 или IPv6-адреса. `"0.0.0.0/0" `можно использовать, чтобы разрешить любые IPv4-адреса.

> Примечание – Возможно, нужно будет подождать до 60 секунд после сохранения элемента данных, пока Сервер подхватит изменения из обновленного кэша конфигурации, прежде чем получится посылать значения.

В самом простом случае можно использовать утилиту zabbix_sender (см. п. Е.6) для отправки некоторого "тестового значения" траппер-элементу данных:

```bash Terminal
zabbix_sender -z <IP-адрес сервера> -p 10051 -s "New host" -k trap -o "тестовое значение"
```

Для отправки значения используются следующие ключи, чтобы указать:

- -`z –` IP-адрес Сервера;
- `-p –` номер порта Сервера (10051 по умолчанию);
- `-s –` узел сети (следует убедиться, что используется "техническое" имя узла сети, вместо "видимого" имени);
- `-k `– ключ элемента данных, который добавляется;
- `-o `– фактически отправляемое значение.

​Процесс траппера не раскрывает макросы, которые используются в ключе элемента данных в попытке проверки наличия соответствующего ключа элемента данных на целевом узле сети.

Результат можно увидеть в "Мониторинг → Последние данные" (рисунок 7).

::sign-image
---
src: /image12.png
sign: Рисунок 493 – Последние данные
---
::

1. Последние данные

Следует обратить внимание, что, если отправлено одно числовое значение, на графике отобразится горизонтальная линия с левого до правого края от точки времени значения.

# Д.7.1 Настраиваемые поля

Мониторинг JMX можно использовать для мониторинга счетчиков JMX в Java-приложениях.

Когда Серверу нужно определить значение конкретного счетчика JMX у узла сети, он опрашивает Java gateway, который, в свою очередь, используя API- управление JMX, удаленно опрашивает интересующее приложение.

Подключения между Java gateway и наблюдаемым JMX-приложением не должны быть закрыты брандмауэром.